namespace 지역이점
{
    // 주,도시 세팅. 주는 삼국지 14를 기준으로
    array<int> 유주_도시 = { 도시_북평, 도시_계, 도시_양평 };         // 주도 : 북평
    array<int> 병주_도시 = { 도시_진양 };
    array<int> 기주_도시 = { 도시_업, 도시_남피 };
    array<int> 청주_도시 = { 도시_북해, 도시_평원 };
    array<int> 서주_도시 = { 도시_하비, 도시_소패 };
    array<int> 회남_도시 = { 도시_수춘, 도시_여강 };
    array<int> 연주_도시 = { 도시_진류, 도시_복양 };
    array<int> 예주_도시 = { 도시_허창, 도시_여남 };
    array<int> 사예_도시 = { 도시_낙양 };
    array<int> 경조_도시 = { 도시_장안, 도시_상용, 도시_완 };        // 주도 : 장안
    array<int> 량주_도시 = { 도시_무위, 도시_천수, 도시_안정 };      // 주도 : 무위
    array<int> 양주_도시 = { 도시_건업, 도시_오, 도시_회계, 도시_시상 };  // 주도 : 건업
    array<int> 형북_도시 = { 도시_양양, 도시_강릉, 도시_강하, 도시_신야 };  // 주도 : 양양
    array<int> 형남_도시 = { 도시_장사, 도시_무릉, 도시_계양, 도시_영릉 };  // 주도 : 장사
    array<int> 익주_도시 = { 도시_성도, 도시_한중, 도시_자동, 도시_강주, 도시_영안 };   // 주도 : 성도
    array<int> 남중_도시 = { 도시_건녕, 도시_운남 };

    const int 유주 = 0;       // YouZhou
    const int 병주 = 1;       // BingZhou
    const int 기주 = 2;       // JiZhou
    const int 청주 = 3;       // QingZhou
    const int 서주 = 4;       // XuZhou
    const int 회남 = 5;       // HuaiNan
    const int 연주 = 6;       // YanZhou
    const int 예주 = 7;       // YuZhou
    const int 사예 = 8;       // SiLi
    const int 경조 = 9;       // JingZhao
    const int 량주 = 10;      // LiangZhou
    const int 양주 = 11;      // YangZhou
    const int 형북 = 12;      // JingBei
    const int 형남 = 13;      // JingNan
    const int 익주 = 14;      // YiZhou
    const int 남중 = 15;      // NanZhong
    const int 지역_끝 = 16;

    const int 우호_대진국 = 0;   // 사예
    const int 우호_안식국 = 1;   // 경조
    const int 우호_천축국 = 2;   // 형남
    const int 우호_귀상국 = 3;   // 익주
    const int 우호_오환 = 4;     // 유주
    const int 우호_선비 = 5;     // *사용하지 않음
    const int 우호_강 = 6;       // 량주
    const int 우호_남만 = 7;     // 남중
    const int 우호_산월 = 8;     // 양주
    const int 우호_끝 = 9;       
    
    array<string> 주_이름 = {"유주", "병주", "기주", "청주", "서주", "회남", "연주", "예주", "사예", "경조", "량주", "양주", "형북", "형남", "익주", "남중"};
    array<string> 교역대상_이름 = { "대진국", "안식국", "천축국", "귀상국", "오환", "선비", "강", "남만", "산월" };
    array<int> 교역대상_아이디 = { -1, -1, -1, -1, 세력_오환, -1, 세력_강, 세력_남만, 세력_산월 };

    const int 교역불가_교역중 = 0;
    const int 교역불가_지역이점없음 = 1;
    const int 교역불가_기교부족 = 2;
    const int 교역불가_물자부족 = 3;
    const int 교역불가_최대 = 4;
    
    array<int> 오환_영향력 = { 유주, 병주, 기주, 청주, 연주 };
    array<int> 강_영향력 = { 예주,  사예, 경조 , 량주 };
    array<int> 남만_영향력 = { 형남, 익주, 남중 };
    array<int> 산월_영향력 = { 회남, 서주, 양주, 형북 };

    const int 이민족_철군_동맹 = 0;
    const int 이민족_철군_기한 = 1;
    const int 이민족_철군_진상 = 2;
    const int 이민족_철군_끝 = 3;

    const int 대회_항상개최 = 0;
    const int 대회_개최안함 = 1;
    const int 대회_랜덤 = 2;

    const int 대회_무술 = 0;
    const int 대회_설전 = 1;
    const int 대회_끝 = 2;

    const int 대회_8강이상 = 0;
    const int 대회_4강 = 1;
    const int 대회_자세력 = 2;

    const int 홀수년도 = 0;
    const int 짝수년도 = 1;
    const int 매년 = 2;

    const int 고유기교_없음 = 0;       // 고유기교가 없다는 것을 계산할 항목이기 때문에 고유기교_없음에 관련된 것은 수정하지 말것
    const int 고유기교_위무지강 = 1;    // 최대병력에서 줄어들 수록 부대 능력치 강화, 부대의 병량소모 감소
    const int 고유기교_대기대덕 = 2;    // 매 턴 부대의 부상병 일부가 회복, 도시 점령 시 내정시설 추가 보존
    const int 고유기교_맹호조아 = 3;    // 병력차로 인한 혼란 무효, 부대의 일반공격 데미지 증가
    const int 고유기교_소패왕 = 4;      // 적의 영토에서 부대의 공격,방어 강화
    const int 고유기교_수성강화 = 5;    // 아군 영토내의 아군의 모든 건물의 내구력 피해 감소
    const int 고유기교_주지육림 = 6;    // 아군 부대가 적의 도시 근처에서 금을 약탈, 적의 부상병 전환율 감소
    const int 고유기교_비마대 = 7;      // 아군의 모든 기병 부대의 적성이 최소 A가 되고 교란,위보에 당할 확률 감소
    const int 고유기교_자모위용 = 8;    // 최대병력에 근접할 수록 부대 능력치 강화, 아군 도시에 소속된 포로의 충성도 하락이 가속됨
    const int 고유기교_당도고 = 9;      // 작위가 높을수록 자세력 강화, 한실중시 군주는 적용 불가, 보유자가 군주가 아닌경우 효과 반감
    const int 고유기교_백마의종 = 10;   // 기병부대가 적에게 피해를 줄 경우 적 부대의 기력을 소폭 감소, 일반 공격시 기력 증가
    const int 고유기교_유시 = 11;       // 건물의 공격이 낮은확률로 부상유발
    const int 고유기교_팔준 = 12;       // 매 분기마다 교련 발생
    const int 고유기교_오두미도 = 13;   // 아군의 부상병 전환율 추가, 농가가 아닌 시설에서도 군량 일부 획득
    const int 고유기교_서량철기 = 14;   // 기병전법 성공 시, 기병부대의 주변 적에게 추가적으로 피해를 입힘, 고유기교 보유 무장의 경우 효과 2배
    const int 고유기교_남만왕 = 15;     // 아군 영토내의 적 부대 기동력 하락 및 기력감소
    const int 고유기교_속전고수 = 16;   // 아군의 모든부대 기동력 증가 
    const int 고유기교_황천당립 = 17;   // 아군 부대의 기력이 줄어들수록 부대 공격력 증가, 검병부대 공,방,이동 증가
    const int 고유기교_덕왕위덕 = 18;   // 인접한 적 도시의 치안하락 가속, 아군 영토내에 본거지가 발생하지 않음
    const int 고유기교_팔진도 = 19;     // 건물의 공격이 확률로 추가효과 (화계, 교란, 허보, 기력저하)
    const int 고유기교_군신 = 20;       // 아군 부대의 전법 성공률 증가
    const int 고유기교_질풍 = 21;       // 노병전법 성공시 무작위 부대 추가사격
    const int 고유기교_원융노병 = 22;   // 아군의 모든 노병 부대의 적성이 최소 A가 되고 교란,위보에 당할 확률 감소
    const int 고유기교_청주병 = 23;     // 아군의 모든 창병 부대의 적성이 최소 A가 되고 교란,위보에 당할 확률 감소
    const int 고유기교_동주병 = 24;     // 아군의 모든 극병 부대의 적성이 최소 A가 되고 교란,위보에 당할 확률 감소
    const int 고유기교_함진영 = 25;     // 군사시설에 대한 피해량이 증가하고, 거점 병력에 입히는 피해량 증가
    const int 고유기교_미주랑 = 26;     // 불속에 있는 적 부대에 전법 성공 시 크리티컬 확률 증가, 불속에 있는 아군 부대 능력치 상승         
    const int 고유기교_묘수 = 27;       // 전법 성공시 적 부대에 지력차에 비례해 추가 데미지를 입힘 (광역 전법의 경우 경감)
    const int 고유기교_만인지적 = 28;  // 공격력이 낮은 적 부대에 주는 피해 증가, 공격력이 낮은 적 부대에 받는 피해 감소 (부대가 상태이상인 경우 무효)
    const int 고유기교_효명진천 = 29;  // 상태이상인 적 부대에 주는 피해 증가, (인접한 적 부대 수 - 아군 부대 수) 에 비례해 부대 공격력 증가
    const int 고유기교_일신시담 = 30;  // 상태이상인 아군 부대 받는피해 반감, (인접한 적 부대 수 - 아군 부대 수) 에 비례해 부대 방어력 증가
    const int 고유기교_왕좌지재 = 31;  // 거점의 부상병 회복 증가, 거점의 시장이 아닌 다른 건물도 일부 금수입
    const int 고유기교_팔문금쇄 = 32;  // 자세력 영토일 시 부대 방어력 증가 및 반격 데미지 증가
    const int 고유기교_허유엄살 = 33;  // 교란,위보,동토 성공 후 2칸 이내의 임의의 적 1부대에 아군 부대의 병력수 및 적 부대와의 지력차에 비례한 피해, 허유엄살 보유 무장의 경우 효과가 2배가 됩니다.
    const int 고유기교_일치단결 = 34;  // 인접한 아군 부대수에 비례해 부대 능력치 상승
    const int 고유기교_신기 = 35;      // 적의 전법 성공률 하락 (아군 부대에 대한)
    const int 고유기교_후위대 = 36;    // 부대가 전멸 당할 경우 포로 확률 감소
    const int 고유기교_이간계 = 37;    // 무장이 2명 이상인 부대에 계략성공률 증가        
    const int 고유기교_정예수군 = 38;  // 수군의 공,방,기동력 증가
    const int 고유기교_인화 = 39;      // 모든 부대의 지원공격 확률 증가 
    const int 고유기교_침략황폐 = 40;  // 내정시설에 대한 피해 증가, 부대가 일정거리 이하의 도시에 매 턴 치안 감소부여 (6칸, 확률)
    const int 고유기교_결사항전 = 41;  // 미구현
    const int 고유기교_왕귀 = 42;      // 플레이어 전용(1인게임 전용). 고유기교를 채택하면 무장 1명 선택, 4년 뒤 무장의 능력치 증가 (무장의 능력치가 낮을 수록 효과 극대화), 도중 고유기교를 빼거나 무장이 하야, 배신, 사망 시 무효
    const int 고유기교_폐월수화 = 43;  // 미구현
    const int 고유기교44 = 44;
    const int 고유기교45 = 45;
    const int 고유기교46 = 46;
    const int 고유기교47 = 47;
    const int 고유기교48 = 48;
    const int 고유기교49 = 49;
    const int 고유기교50 = 50;
    const int 고유기교51 = 51;
    const int 고유기교52 = 52;
    const int 고유기교53 = 53;
    const int 고유기교54 = 54;
    const int 고유기교55 = 55;
    const int 고유기교56 = 56;
    const int 고유기교57 = 57;
    const int 고유기교58 = 58;
    const int 고유기교59 = 59;
    const int 고유기교60 = 60;
    const int 고유기교61 = 61;
    const int 고유기교62 = 62;
    const int 고유기교63 = 63;
    const int 고유기교64 = 64;
    const int 고유기교65 = 65;
    const int 고유기교66 = 66;
    const int 고유기교67 = 67;
    const int 고유기교68 = 68;
    const int 고유기교69 = 69;
    const int 고유기교70 = 70;
    const int 고유기교71 = 71;
    const int 고유기교72 = 72;
    const int 고유기교73 = 73;
    const int 고유기교74 = 74;
    const int 고유기교75 = 75;
    const int 고유기교76 = 76;
    const int 고유기교77 = 77;
    const int 고유기교78 = 78;
    const int 고유기교79 = 79;
    const int 고유기교80 = 80;
    const int 고유기교81 = 81;
    const int 고유기교82 = 82;
    const int 고유기교83 = 83;
    const int 고유기교84 = 84;
    const int 고유기교85 = 85;
    const int 고유기교86 = 86;
    const int 고유기교87 = 87;
    const int 고유기교88 = 88;
    const int 고유기교89 = 89;
    const int 고유기교90 = 90;
    const int 고유기교91 = 91;
    const int 고유기교92 = 92;
    const int 고유기교93 = 93;
    const int 고유기교94 = 94;
    const int 고유기교95 = 95;
    const int 고유기교96 = 96;
    const int 고유기교97 = 97;
    const int 고유기교98 = 98;
    const int 고유기교99 = 99;

    const int 고유기교_끝 = 40;

    // 출력될 고유기교의 이름. 없음은 수정하지 말것 , 없음을 포함해서 최대 100개까지 사용가능
    const array<string> 고유기교_이름 = 
    {   "\x1b[1x없음\x1b[0x", 
        "\x1b[1x위무지강\x1b[0x", 
        "\x1b[1x대기대덕\x1b[0x", 
        "\x1b[1x맹호조아\x1b[0x", 
        "\x1b[1x소패왕\x1b[0x", 
        "\x1b[1x수성강화\x1b[0x", 
        "\x1b[1x주지육림\x1b[0x", 
        "\x1b[1x비마대\x1b[0x", 
        "\x1b[1x자모위용\x1b[0x", 
        "\x1b[1x당도고\x1b[0x", 
        "\x1b[1x백마의종\x1b[0x" ,
        "\x1b[1x유시\x1b[0x", 
        "\x1b[1x팔준\x1b[0x", 
        "\x1b[1x오두미도\x1b[0x", 
        "\x1b[1x서량철기\x1b[0x", 
        "\x1b[1x남만왕\x1b[0x", 
        "\x1b[1x속전고수\x1b[0x", 
        "\x1b[1x황천당립\x1b[0x", 
        "\x1b[1x덕왕위덕\x1b[0x",
        "\x1b[1x팔진도\x1b[0x", 
        "\x1b[1x군신\x1b[0x", 
        "\x1b[1x질풍\x1b[0x", 
        "\x1b[1x원융노병\x1b[0x", 
        "\x1b[1x청주병\x1b[0x", 
        "\x1b[1x동주병\x1b[0x", 
        "\x1b[1x함진영\x1b[0x", 
        "\x1b[1x미주랑\x1b[0x", 
        "\x1b[1x묘수\x1b[0x",
        "\x1b[1x만인지적\x1b[0x",
        "\x1b[1x효명진천\x1b[0x",
        "\x1b[1x일신시담\x1b[0x",
        "\x1b[1x왕좌지재\x1b[0x",
        "\x1b[1x팔문금쇄\x1b[0x",
        "\x1b[1x허유엄살\x1b[0x",
        "\x1b[1x일치단결\x1b[0x",
        "\x1b[1x신기\x1b[0x",
        "\x1b[1x후위대\x1b[0x",
        "\x1b[1x이간계\x1b[0x",
        "\x1b[1x정예수군\x1b[0x",
        "\x1b[1x인화\x1b[0x",
        "\x1b[1x침략황폐\x1b[0x",
        "\x1b[1x결사항전\x1b[0x",
        "\x1b[1x왕귀\x1b[0x",
        "\x1b[1x폐월수화\x1b[0x",
        "\x1b[1x고유기교44\x1b[0x",
        "\x1b[1x고유기교45\x1b[0x",
        "\x1b[1x고유기교46\x1b[0x",
        "\x1b[1x고유기교47\x1b[0x",
        "\x1b[1x고유기교48\x1b[0x",
        "\x1b[1x고유기교49\x1b[0x",
        "\x1b[1x고유기교50\x1b[0x",
        "\x1b[1x고유기교51\x1b[0x",
        "\x1b[1x고유기교52\x1b[0x",
        "\x1b[1x고유기교53\x1b[0x",
        "\x1b[1x고유기교54\x1b[0x",
        "\x1b[1x고유기교55\x1b[0x",
        "\x1b[1x고유기교56\x1b[0x",
        "\x1b[1x고유기교57\x1b[0x",
        "\x1b[1x고유기교58\x1b[0x",
        "\x1b[1x고유기교59\x1b[0x",
        "\x1b[1x고유기교60\x1b[0x",
        "\x1b[1x고유기교61\x1b[0x",
        "\x1b[1x고유기교62\x1b[0x",
        "\x1b[1x고유기교63\x1b[0x",
        "\x1b[1x고유기교64\x1b[0x",
        "\x1b[1x고유기교65\x1b[0x",
        "\x1b[1x고유기교66\x1b[0x",
        "\x1b[1x고유기교67\x1b[0x",
        "\x1b[1x고유기교68\x1b[0x",
        "\x1b[1x고유기교69\x1b[0x",
        "\x1b[1x고유기교70\x1b[0x",
        "\x1b[1x고유기교71\x1b[0x",
        "\x1b[1x고유기교72\x1b[0x",
        "\x1b[1x고유기교73\x1b[0x",
        "\x1b[1x고유기교74\x1b[0x",
        "\x1b[1x고유기교75\x1b[0x",
        "\x1b[1x고유기교76\x1b[0x",
        "\x1b[1x고유기교77\x1b[0x",
        "\x1b[1x고유기교78\x1b[0x",
        "\x1b[1x고유기교79\x1b[0x",
        "\x1b[1x고유기교80\x1b[0x",
        "\x1b[1x고유기교81\x1b[0x",
        "\x1b[1x고유기교82\x1b[0x",
        "\x1b[1x고유기교83\x1b[0x",
        "\x1b[1x고유기교84\x1b[0x",
        "\x1b[1x고유기교85\x1b[0x",
        "\x1b[1x고유기교86\x1b[0x",
        "\x1b[1x고유기교87\x1b[0x",
        "\x1b[1x고유기교88\x1b[0x",
        "\x1b[1x고유기교89\x1b[0x",
        "\x1b[1x고유기교90\x1b[0x",
        "\x1b[1x고유기교91\x1b[0x",
        "\x1b[1x고유기교92\x1b[0x",
        "\x1b[1x고유기교93\x1b[0x",
        "\x1b[1x고유기교94\x1b[0x",
        "\x1b[1x고유기교95\x1b[0x",
        "\x1b[1x고유기교96\x1b[0x",
        "\x1b[1x고유기교97\x1b[0x",
        "\x1b[1x고유기교98\x1b[0x",
        "\x1b[1x고유기교99\x1b[0x",
    };

    const array<string> 팔준_이름 = { pk::u8encode("통솔 교육"), pk::u8encode("무력 교육"), pk::u8encode("지력 교육"), pk::u8encode("정치 교육"), pk::u8encode("교육 안함") };
    const array<string> 무장능력_이름 = { "\x1b[1x통솔\x1b[0x", "\x1b[1x무력\x1b[0x", "\x1b[1x지력\x1b[0x", "\x1b[1x정치\x1b[0x" };
    const array<string> 칭호_이름 = { "\x1b[2x천하무쌍\x1b[0x", "\x1b[1x천하기재\x1b[0x", "\x1b[16x국사무쌍\x1b[0x" };

    const int KEY = pk::hash("지역이점");
    const int 기본데이터_시작 = 0;          // 0 ~ 125,    42 x 3
    const int 이민족데이터_시작 = 126;      // 126 ~ 129
    const int 황실대회_시작 = 130;          // 130 ~ 131
    const int 세력대회_시작 = 132;          // 132 ~ 173
    const int 부대_부상병_시작 = 200;       // 200 ~ 699     => 최대 500부대만 계산
    const int 거점_부상병_시작 = 700;       // 700 ~ 786     => 거점 개수 87개
    const int 고유기교_시작 = 800;          // 800 ~ 841     => 세력 갯수 42개
    const int 고유기교_카운트_시작 = 900;    // 900 ~ 941     => 세력 갯수 42개
    const int 우승횟수_시작 = 1000;         // 1000 ~ 1998   => 유효무장 999명
    const int 칭호_시작 = 2000;             // 2000 ~ 2002   => 칭호 3개
    const int 세력별_고유기교타입_시작 = 2010; // 2010 ~ 2051 => 세력 42개
    const int AI_고유기교시드_시작 = 2100;   // 2100 ~ 3099  => int 하나당 4개의 고유기교 순서값, 1~40 까지의 랜덤 고유기교 순서를 가지기 위해서 10개의 int값이 필요함. 2100~3099는 세력별 고유기교 랜덤 우선순위값을 100개까지 가짐.
    const int 설정_시작 = 60000;            // 각종 설정을 저장할 인덱스 (최대값 : 65535)
    const int 설정_지역이점_사용여부 = 60000;  // 1 : 사용, 0 : 사용안함
    const int 설정_이민족_지원_사용여부 = 60001;  // 1 : 사용, 0 : 사용안함
    const int 설정_이민족_특기전수_사용여부 = 60002; // 1: 사용, 0 : 사용안함
    const int 설정_무술대회_개최관련 = 60010; // 0 : 개최x  1: 홀수년도 2: 짝수년도 3: 매년
    const int 설정_무술대회_개최달 = 60011;  // 1 ~ 12
    const int 설정_설전대회_개최관련 = 60012; // 0 : 개최x  1: 홀수년도 2: 짝수년도 3: 매년
    const int 설정_설전대회_개최달 = 60013;  // 1 ~ 12 
    const int 설정_자세력_대회_사용여부 = 60014; // 1 : 사용, 0 : 사용안함
    const int 설정_고유기교_사용여부 = 60020;  // 1 : 사용, 0 : 사용안함
    const int 설정_능력연구_표시_사용여부 = 60021; // 1: 사용, 0 : 사용안함
    const int 설정_이민족외교_표시_사용여부 = 60022; // 1: 사용, 0 : 사용안함
    const int 설정_교역_표시_사용여부 = 60023; // 1: 사용, 0 : 사용안함
    const int 설정_왕귀_표시_사용여부 = 60024; // 1: 사용, 0 : 사용안함
    const int 설정_백출_기력반감 = 60030;     // 1 : 사용, 0 : 원본사용
    const int 설정_부상병시스템_사용여부 = 60031;   // 1 : 사용, 0 : 사용안함
    const int 설정_수정된_등용확률 = 60032;   // 3: 유저만 2: AI만  1 : 모두, 0 : 원본
    const int 설정_수정된_포로확률 = 60033;   // 3: 유저만 2: AI만  1 : 모두, 0 : 원본
    const int 설정_멸망시_공적감소 = 60034;   // 1 : 사용, 0 : 원본

    // ============================================== Customize ======================================================

    // ============================================== 지역 이점 =======================================================    

    /* %로 설명해놓은 숫자들은 되도록 (0~100)사이의 값을 추천합니다. 0보다 작아지거나 아주 숫자가 커지면 의도하지 않은 결과가 나올 가능성이 있습니다 */

    array<int> 교역_금 = { 3000, 5000, 10000 };
    array<int> 교역_군량 = { 10000, 20000, 40000 };
    array<int> 교역_병사 = { 5000, 10000, 20000 };
    const int 교역_기교 = 1000;
    const int 교역_일수 = 36;          // (1 ~ 99 사이, 1 = 10일)
    const int 화친_기교 = 1000;
    const int 화친_일수 = 3;          // (1 ~ 3 사이, 1 = 10일)
    const int AI_교역_페널티 = 18;    // (1 = 10일, 교역 일수와 합이 99를 넘지 않게 해야함)
    const int AI_화친_레벨당_페널티 = 3; // (1 = 10일, 99까지 권장)

    const int 대진_1단계_창병방어 = 7;        // (%) 
    const int 대진_2단계_투석공격 = 10;       // (%)
    const int 대진_3단계_창병방어 = 15;       // (%)
    
    const int 안식_1단계_기병공격 = 7;        // (%)
    const int 안식_2단계_추가사격확률 = 20;      
    const int 안식_3단계_기병공격 = 15;       // (%)
    
    const int 천축_1단계_추가보존 = 100;      // 원래 값에 더해짐.  100으로 설정될 경우 (100 + 100)으로 두배.  
    const int 천축_2단계_징병치안보조 = 40;    // 징병시 치안감소를 경감시켜주는 비율
    const int 천축_3단계_공방상승 = 12;       // (%)

    const int 귀상_1단계_수송이동 = 4;          
    const int 귀상_2단계_궁병공격 = 10;       // (%)
    const int 귀상_3단계_진정확률 = 15;       // (%) // (0% ~ 100%)
    
    const int 오환_3단계_포박상승 = 15;      // 0% 일경우는 효과 없음.  1%의 확률일 경우 -> 16%로 상승.

    const int 강_3단계_퇴각상승 = 25;       // (25일 경우 -> 포박확률을 기존의 75%로 경감시킴)  

    const int 남만_3단계_숲강화 = 15;       // (%)

    const int 산월_3단계_포박상승 = 20;      // 0% 일경우는 효과 없음.  1%의 확률일 경우 -> 21%로 상승.

    const int 병주_지역이점_기력상승 = 4;
    const int 병주_지역이점_이동증가 = 4;
    
    const int 기주_지역이점_충성상승 = 2;
    const int 기주_지역이점_최대누적충성 = 110;
    const int 기주_지역이점_녹봉할인 = 40;    // (%)

    const int 청주_지역이점_시설상승 = 10;    // (최대 체력 비율)
    const int 청주_지역이점_치안상승 = 5;     

    const int 서주_지역이점_거점공격 = 25;    // (%)
    const int 서주_지역이점_내구회복 = 6;     // (최대 체력 비율. 관문, 항구는 절반)

    const int 회남_지역이점_기력경감 = 25;    // (%)
    
    const int 연주_지역이점_생산증가 = 25;    // (%)

    const int 예주_지역이점_이동소환경감 = 20;         // 10의 배수로 세팅
    const int 예주_지역이점_귀환경감 = 30;            // 10의 배수로 세팅

    const int 형북_지역이점_기교획득 = 80;
    const int 형북_지역이점_등용상승 = 20;            // (20일 경우 -> 기본확률 x 1.2)  기본확률이 0% 경우 효과없음
    
    // ==============================================================================================================================
    
    // =========================================  이민족 지원 요청 ===================================================================

    const int 이민족_지속기간 = 9;           // 1 = 10일 , (군량은 90일분으로 출전함)
    const int 이민족_원군요청_기교 = 1000;
    const int 이민족_원군요청_기본금 = 2000; 
    const int 이민족_원군요청_추가금 = 500;  // 1년마다 늘어나는 필요 금
    const int AI_이민족지원_기본확률 = 1;    // (요청이 가능한 경우) 턴마다 지원요청을 실행할 확률
    const int AI_이민족지원_추가확률 = 1;    // 2년이 지날때마다 추가될 확률 (최대 4번 추가됨) 

    // ===============================================================================================================================

    // =========================================== 무술, 설전 대회 ====================================================================
    
    /* 무술대회 참가의 자격 요건은 무력 80 이상인 무장의 보유 유무 입니다. 
       마찬가지로 설전대회의 참가 자격 요건은 지력 80 이상인 무장의 보유 유무입니다.
       
       한실의 역적들은 대회 선발과정에서 제외됩니다. 여기서 역적이라함은 황제를 보호중이지 않은 다른 황제 및 황건적을 지칭합니다.

       대회는 황제가 보호중일 경우에만 개최되고, 황제를 보호중인 세력은 우선적으로 참가 자격을 얻습니다. (자격 요건을 충족하지 못한 경우에는 참가 불가)
       자격 요건을 갖춘 세력이 20개 이상인 경우에는 16강부터 대회가 진행되고, 8~19 사이인 경우에는 8강부터 대회가 진행됩니다.
       
       황제가 보호중인 상태가 아니거나 세력이 7개 이하인 경우에는 한황제가 개최하는 대회가 열리지 않지만 
       대신 공 이상의 작위를 가진 세력에 한해서 자체적으로 대회를 개최할 수 있게됩니다.
       
       황제를 참칭한 역적의 경우에는 한실의 대회가 개최되는 경우에도 자체적으로 대회를 개최할 수 있습니다.
    */

    
    const int 대회_랜덤확률 = 50;                      // 대회 개최가 랜덤일 경우 확률, 그 이외에는 사용안함 (0 ~ 100)
    
    const int 대회_개최비용 = 5000;                   // 세력 내 대회 개최비용
    const int 대회_개최기교 = 1000;                   // 세력 내 대회 개최기교

    const int 대회_개최년도_무술 = 홀수년도;            // 대회 개최년도 설정 (홀수년도, 짝수년도, 매년 중 선택가능)
    const int 대회_개최년도_설전 = 짝수년도;

    const bool 대회_4세력개최여부 = true;              // 4세력의 8강대회도 열릴것인지 여부

    int 대회_개최시기_무술 = 4;                  // 대회를 개최하는 월 (해당 월 1일에 개최,  1 ~ 12 사이로 세팅할것)
    int 대회_개최시기_설전 = 4;

    const int 대회_무력제한 = 80;                      // 무술대회 참가자격이 주어지는 최소 무력수치
    const int 대회_지력제한 = 80;                      // 설전대회 참가자격이 주어지는 최소 지력수치

    const int 무술대회_초기우승자 = /*무장_여포*/ -1;          // 시나리오 시작 시 세팅될 대회 최초 우승자 ( 없을 경우 -1, 그 외에는 무장_여포, 무장_관우 이런식으로 세팅)
    const int 설전대회_초기우승자 = -1;
    /* 대회 우승자에 한해서 전투 시 특수한 효과를 부여하는 것을 선택하는 항목입니다. 
       
       무술대회 우승자의 경우 부대 행동 종료 시 부대의 무력 차이에 비례해서 적의 기력을 감소시킵니다.
       설전대회 우승자의 경우 부대 행동 종료 시 주위의 임의의 적 1부대에게 교란을 실행합니다.
       설전대회 특전의 경우에는 시전자나 대상자의 특기와 무관하게 지력차이에 의해 성공률이 결정됩니다.
       
       대회 우승자는 다음 대회가 개최될때까지 해당 효과를 받고, 다른 우승자가 결정되거나 대회가 폐지되는 경우 해당 효과를 상실합니다.

       세력내에서 개최한 대회의 우승자에게는 대회의 종류에 관계없이 주악의 효과를 받습니다.
       세력내에서 개최한 대회의 효과는 매년 1월에 사라집니다.
    */
    const bool 우승자_특전여부 = true;

    // 유저 세력의 대회 강제참가 여부. 개최국이 AI의 세력이면서 유저 8인 플레이라면 유저 세력중 한 세력은 참가하지 못할 수 있음.
    const bool 플레이어_무술대회_참여여부 = true;     // 플레이어 세력이 무조건 무술대회에 참가하는가?(true : 무조건 참여, false : 랜덤참여)  
    const bool 플레이어_설전대회_참여여부 = true;     // 플레이어 세력이 무조건 설전대회에 참가하는가?

    const int 우승_상금 = 3000;             // 무술대회 우승 상금
    const int 우승_기교 = 1500;             // 설전대회 우승 기교
    const int 우승_공적 = 3000;             // 무술,설전 대회 우승 공적

    const int 준우승_상금 = 1000;           // 무술대회 준우승 상금
    const int 준우승_기교 = 500;           // 설전대회 준우승 기교
    const int 준우승_공적 = 1000;           // 무술,설전 대회 준우승 공적

    const int 자세력_우승_공적 = 1000;      // 자세력 대회 우승자 공적
    const int 자세력_준우승_공적 = 500;     // 자세력 대회 준우승자 공적

    const int 헌제_대회_경험치 = 40;         // 한황제가 개최하는 대회 참가자 경험치. 무술 = 통솔,무력   설전 = 지력, 정치
    const int 자체_대회_경험치 = 20;         // 한 세력내에서 자체적으로 개최하는 대회 참가자 경험치.

    // AI의 대회 출전 무장을 뽑기위해 무력에 더해줄 수치 입니다. 부가무력_무장 과 부가무력_수치의 순서가 일치해야 제대로 적용됩니다. 황충의 경우 별도로 계산합니다
    array<int> 부가무력_무장 = { 무장_항적, 무장_여포, 무장_관우, 무장_장비, 무장_조운, 무장_마초, 무장_허저};
    array<int> 부가무력_수치 = { 20, 10, 5, 5, 3, 3, 3};

    // AI의 대회 출전 무장을 선출하는 방식에 더해줄 점수 입니다. 최종 계산은 무력 + 부가무력 + 보물 점수 중 가장 높은 숫자를 지닌 무장이 선택됩니다.
    const int 긴무기_점수 = 5;
    const int 검_점수 = 3;
    const int 활_점수 = 3;
    const int 암기_점수 = 2;

    // AI의 설전 선별무장 성격 점수
    const int 설전_소심 = 11;
    const int 설전_대담 = 6;
    const int 설전_저돌 = 2;
    const int 설전_냉정 = 0;

    // AI의 설전 선별무장 보유화술점수. 서적을 소유하고 있을 경우에는 모든 화술점수를 얻습니다. 
    const int 설전_궤변 = 4;
    const int 설전_대갈 = 5;
    const int 설전_무시 = 1;
    const int 설전_진정 = 2;
    const int 설전_흥분 = 3;        // = 역상

    // ========================================================== 대회 우승자 특전 =======================================================

    const int 무술대회특전_최대사거리 = 2;
    const int 무술대회특전_기력회복값 = 5;
    
    const int 설전대회특전_최대사거리 = 2;
    const int 설전대회특전_기력회복값 = 5;

    const int 대회특전_최대사거리 = 2;
    const int 대회특전_계략실행확률 = 100; // (0~100);

    const int 자체대회특전_기력회복 = 5;

    // ========================================================== 부상병 관련 ===========================================================

    bool 게임화면_부상병_표시 = true;            // 게임화면 하단에 부상병 표시 ( true : 표시함, false : 표시 안함)

    const bool 부상병_흡수_로그_출력 = false;          // 부상병 흡수 확인용 로그 ( true : 출력함 , fasle : 출력 안함 )

    const int 거점_부상병_기본_회복량 = 200;          // 턴당 거점의 부상병 회복량
    const int 도시_시설당_부상병_회복량 = 10;         // 개발된 내정시설 당 부상병 회복량

    const int 부상병_전환율 = 20;  // 함정, 화계를 제외한 부대의 피해가 부상병으로 전환되는 백분율 (0 ~ 100)
    const int 부상병_흡수율 = 25;  // 인접한 부대가 대상 부대를 궤멸시켰을 경우 대상 부대의 부상병을 흡수하는 백분율 (0 ~ 100)
    const int 부상병_귀환율 = 25;  // 부대가 궤멸당했을 경우 해당 부대의 부상병이 소속된 거점으로 귀환되는 백분율 (0 ~ 100)

    // ================================================== 고유기교 ========================================================
    // 
    // 보유한 무장에 따라서 얻을 수 있는 고유기교 
    // 
    // 세력별로 총 4개의 고유기교까지 적용할 수 있습니다.
    // 세력이 개발완료한 기교들의 총합 포인트에 따라서 고유기교 슬롯이 개방됩니다.
    // 
    // 군주 무장의 경우에는 고유기교의 공적제한이 없지만, 수하 무장의 고유기교를 적용시키기 위해서는
    // 수하 무장 자신의 공적치 제한을 만족시켜야 합니다. 
    // 
    //  AI의 세력의 경우 매 달 고유기교 슬롯과 현재 사용 가능한 고유기교 목록에 따라서
    //  게임 시작시 책정된 우선순위에 의해서 자동으로 교체합니다.
    //
    //  플레이어의 경우는 새로운 고유기교를 적용하려면 500의 기교포인트가 필요합니다.

    const array<array<int>> 고유기교_무장목록 = 
    {
        //무장 번호, 고유 기교,  부하무장일 경우 필요 공적
        {무장_조조, 고유기교_위무지강, 40000},
        {무장_유비, 고유기교_대기대덕, 40000},
        {무장_손견, 고유기교_맹호조아, 30000},
        {무장_손책, 고유기교_소패왕, 30000},
        {무장_손권, 고유기교_수성강화, 40000},
        {무장_동탁, 고유기교_주지육림, 45000},
        {무장_여포, 고유기교_비마대, 40000},
        {무장_원소, 고유기교_자모위용, 40000},
        {무장_원술, 고유기교_당도고, 60000},
        {무장_공손찬, 고유기교_백마의종, 40000},
        {무장_유언, 고유기교_동주병, 40000},
        {무장_유장, 고유기교_동주병, 50000},
        {무장_유표, 고유기교_팔준, 30000},
        {무장_장노, 고유기교_오두미도, 40000},
        {무장_마등, 고유기교_서량철기, 40000},
        {무장_마초, 고유기교_서량철기, 40000},
        {무장_맹획, 고유기교_남만왕, 30000},
        {무장_사마의, 고유기교_속전고수, 30000},
        {무장_장각, 고유기교_황천당립, 50000},
        {무장_엄백호, 고유기교_덕왕위덕, 40000},
        {무장_제갈량, 고유기교_팔진도, 10000},
        {무장_관우, 고유기교_군신, 20000},
        {무장_육손, 고유기교_신기, 25000},
        {무장_장임, 고유기교_유시, 20000},
        {무장_주유, 고유기교_미주랑, 20000},
        {무장_장비, 고유기교_만인지적, 30000},
        {무장_장료, 고유기교_효명진천, 30000},
        {무장_조운, 고유기교_일신시담, 30000},
        {무장_순욱, 고유기교_왕좌지재, 10000},
        {무장_노숙, 고유기교_왕좌지재, 10000},
        {무장_조인, 고유기교_팔문금쇄, 30000},
        {무장_가후, 고유기교_이간계, 20000},
        {무장_강유, 고유기교_일치단결, 30000},
        {무장_고순, 고유기교_함진영, 20000},
        {무장_한수, 고유기교_침략황폐, 30000},
        {무장_유우, 고유기교_인화, 40000},
        {무장_채모, 고유기교_정예수군, 25000},
        {무장_황충, 고유기교_질풍, 30000},
        {무장_전풍, 고유기교_허유엄살, 20000},
        {961, 고유기교_효명진천, 20000},
        {962, 고유기교_신기, 20000}

        // 추가 시 {무장_황충, 고유기교_질풍, 30000}  같은 식으로 추가하시면 됩니다.
        // 주의사항 :
        // 
        //    맨 마지막의 괄호 끝에는 ',' 가 없어야 합니다.
        //    신무장의 경우는 신무장의 번호를 직접 적어주셔야 합니다 { 900, 고유기교_함진영, 12000 }
        //    무장을 중복으로 입력하면 안됩니다.
    };
    
    // 개발된 기교의 필요p의 총합을 아래 수치만큼 달성할때마다 슬롯이 하나씩 추가로 개방됩니다. (최대 4개로 고정)
    // 작은 순서대로 입력해야 합니다.
    const array<int> 플레이어_고유기교_개방조건 =
    {
        6000, 12000, 24000, 40000
    };

    const array<int> AI_고유기교_개방조건 =
    {
        4000, 8000, 16000, 32000
    };

    const int 위무지강_병량경감 = 20;       // 0 ~ 100;
    const int 위무지강_공방증가 = 10;       // %
    const int 위무지강_최소병력 = 30;       // 0 ~ 100;    부대의 병사가 최대병력의 30%일때 최고치

    const int 대기대덕_부대_부상병_회복률 = 10;
    const int 대기대덕_부대_부상병_최소_회복 = 100;
    const int 대기대덕_부대_부상병_최대_회복 = 500;
    const int 대기대덕_시설보존 = 50;       // 0 ~ 100;

    const int 맹호조아_데미지_증가 = 20;    // %
    
    const int 소패왕_공방추가 = 12;         // 해당 수치만큼 증가

    const int 수성강화_건물피해_경감 = 40;  // % 만큼 경감

    const int 팔준_능력최소경험치 = 5;
    const int 팔준_능력최대경험치 = 40;
    const int 팔준_적성경험치 = 10;

    const int 주지육림_부상병_경감 = 75;    // % 만큼 경감
    const int 주지육림_금약탈_최대 = 100;  
    const int 주지육림_금약탈_비율 = 3;    // 부대병력의 해당 %만큼 금 약탈, 도시와 거리가 멀어질수록 감소(도시와의 거리가 최소 2)

    const int 자모위용_충성하락 = 2;        // 매달 도시의 포로 충성하락
    const int 자모위용_공방증가 = 10;       // %
    const int 자모위용_최소병력 = 30;       // 0 ~ 100;    부대의 병사가 최대병력의 30%일때 효과 없음
    
    const int 당도고_공방강화 = 2;         // 작위당 높아질 부대 공방, 대장이 한실중시인 경우 무효
    const int 당도고_이속강화 = 1;         // 공 부터는 이동속도도 추가 증가 (+) 
    const int 당도고_전법성공률 = 5;       // 황제인 경우 전법확률 추가 증가 (+)

    const int 백마의종_일반공격_기력증가 = 5;    // 기병의 일반공격 시 증가하는 기력
    const int 백마의종_기력감소_돌진 = 5;       // 기병의 돌진 성공시 감소되는 주변 적부대 기력
    const int 백마의종_기력감소_추가 = 2;       // 기병의 전법 성공시 추가되는 기력하락 (돌진 = 5, 돌파 = 7, 돌격 = 9)

    const int 유시_부상확률 = 8;           // %, 건물의 공격이 부상을 입힐 확률 

    const int 오두미도_추가_전환율 = 20;    // %, 부대의 피해가 부상병으로 전환되는 추가 비율(기본 20, 오두미도 포함 40) 
    const int 오두미도_시설당_추가병량 = 20; // 농장 1단의 추수량의 20%

    const int 서량철기_최대피해 = 300;     //
    const int 서량철기_능력차_배율 = 2;    // 적부대의 방어력과 아군 부대의 공격력 차 x 2 + 임의의 값으로 계산됨 

    const int 남만왕_이동저하 = 20;        // % 로 깎음
    const int 남만왕_기력저하 = 5;

    const int 속전고수_기동력증가 = 5;     // 수치만큼 증가

    const int 황천당립_검병공방증가 = 10;  // (+)
    const int 황천당립_검병이속증가 = 4;   // (+)
    const int 황천당립_공격력증가 = 16;    // 기력이 0일때 증가하는 최대 공격력

    const int 덕왕위덕_치안감소 = 3;       // 매 턴 주변 적도시가 감소하는 치안

    const int 팔진도_상태이상확률 = 8;     // %, 건물의 공격이 상태이상을 일으킬 확률

    const int 군신_전법성공률 = 16;        // 추가될 전법 성공확률 

    const int 신기_전법성공률 = 20;        // 하락시킬 전법 성공률 (%), 부대 상태가 혼란, 위보인 경우에도 적용되지만, 공성전법의 경우는 100%

    const int 미주랑_공방증가 = 10;         // 증가시킬 부대 능력치 (특정값)
    const int 미주랑_크리확률증가 = 20;     // 증가시킬 크리티컬 확률

    const int 만인지적_피해증가 = 8;       // 공격력 우위인 적에게 주는 피해량 증가 비율 (%)
    const int 만인지적_피해경감 = 8;       // 공격력 우위인 적에게서 받는 피해량 감소 비율 (%)

    const int 효명진천_피해증가 = 8;       // 상태이상인 적에게 주는 피해량 증가 비율 (%)
    const int 효명진천_공격증가 = 3;       // 인접한 (적부대 - 아군부대) 당 증가하는 부대 공격력 수치

    const int 일신시담_피해경감 = 12;      // 상태이상인 아군 부대가 받는 피해 경감 비율 (%)
    const int 일신시담_방어증가 = 3;       // 인접한 (적부대 - 아군부대) 당 증가하는 부대 방어력 수치

    const int 왕좌지재_거점_부상병_추가_회복률 = 150;     // 거점의 부상병 추가 회복률 (%)
    const int 왕좌지재_시설당_추가금 = 20; // 시장 1단의 수입의 20%

    const int 묘수_지력차피해_배수 = 5; // 적부대 지력차에 비례한 추가 피해량, 광역전법의 경우 반감

    const int 일치단결_공방증가 = 2;        // 인접한 아군 부대당 증가하는 부대 공방 비율 (%)

    const int 함진영_군사시설피해증가 = 15;  // 군사시설에 입히는 추가 피해량(%)
    const int 함진영_도시병력피해증가 = 15;  // 도시의 병력에 입히는 추가 피해량(%)

    const int 이간계_계략증가 = 25;         // 증가할 계략확률 (%)

    const int 후위대_탈출증가 = 10;         // 부대 전멸시 추가 탈출 확률 (+)

    const int 정예수군_공방증가 = 10;       // (%)
    const int 정예수군_이속증가 = 6;        // (+)

    const int 침략황폐_내정시설피해증가 = 25;    // 내정시설에 입히는 추가 피해량(%) 
    const int 침략황폐_치안감소량 = 1;      //   매 턴 감소시키는 도시의 치안
    const int 침략황폐_치안감소확률 = 50;   //   부대마다 치안을 감소시킬 확률(최소 1000명 이상인 부대만 적용) (%)
    const int 침략황폐_적용거리 = 6;        //   치안 감소가 발생하는 도시와 부대의 최대거리

    const int 팔문금쇄_방어증가 = 15;       // (+)
    const int 팔문금쇄_반격증가 = 30;       // (%)

    const int 인화_지원증가 = 8;            // (+)

    const int 허유엄살_최대피해 = 800;
    const int 허유엄살_최소피해 = 200;
    const int 허유엄살_지력차_배율 = 2;      // 지력차 50을 기준으로 100%의 데미지, 1증감당 2% 씩 차이, 최대 200%까지 
    const int 허유엄살_병력계수 = 20;       // 기본데미지 : 부대 병력 1000명 미만은 무효, 1000~5000 까지는 250, 5000 이상인 경우는 (병력수 / 20)  

    const int 비마대_계략감소 = 20;         // (%)
    const int 청주병_계략감소 = 20;         // (%)
    const int 동주병_계략감소 = 20;         // (%)
    const int 원융노병_계략감소 = 20;         // (%)

    const int 왕귀_날짜 = 144;              // 1년 = 36

    // ==================================================================================================================================
    // ==================================================================================================================================
    class RegionBuff
    {
        array<int> forceRegionBuff(도시_끝);                       // 세력별 확인용
        pk::point rb_checkPoint = pk::point(0, 0);                // 지역이점 스크립트 적용 여부 체크
        array<array<int>> dataArray(도시_끝);                      // 세력별 data
        array<int> barbarianDataArray(4);                         // 이민족 원군요청 데이터. 10000 자리수 : 세력번호, 100자리수 : 목표도시, 99이하 : 잔여일수
        pk::person@ ReturnOfKingMoo = pk::get_person(무장_농민);   // 왕귀무장 데이터를 위한 농민 (공적을 데이터로 사용)
        pk::person@ ReturnOfKingDateMoo = pk::get_person(무장_노동자); // 왕귀무장 기간을 위한 무장 (공적을 데이터로 사용)

        array<int> competitionDataArray(2);                     // 한황제 대회 우승자 데이터  0 : 무술대회, 1 : 설전대회
        array<int> singleCompetitionDataArray(도시_끝);         // 세력별 자세력 대회 우승자 데이터
        bool loadSuccess = false;
        array<array<pk::person@>> barbarianMooArray = 
        {
            {null, null, null, null, null, null, null, null, null, null}, 
            {null, null, null, null, null, null, null, null, null, null},
            {null, null, null, null, null, null, null, null, null, null},
            {null, null, null, null, null, null, null, null, null, null}
        };                                                              // 이민족 무장 재활용 배열
        pk::force@ hostForce;
        pk::list<pk::force@> validPlayerCompetitonList;                // 플레이어 참가 가능 세력 리스트
        pk::list<pk::force@> validAICompetitionList;                   // AI 참가 가능 세력 리스트
        int validForceCount = -1;
        pk::list<pk::person@> competitonParticipantList;               // 대회 참가무장
        array<int> woundedUnitArray(500);                              // 부대 부상병 배열
        array<int> woundedBuildingArray(87);                           // 거점 부상병 배열
        array<int> ai_uniqueTech_perfer_type(도시_끝);                  // ai 고유기교 우선순위 타입
        array<int> uniqueTechArray(도시_끝);                            // 세력별 고유기교 배열(100진수)
        array<int> uniqueTechCount(도시_끝);                            // 세력별 개방된 고유기교 슬롯
        array<int> ai_prefer_uniqueTech_data(1000);                      // 세력별 고유기교 우선순위 배열
        array<int> competitionCountArray(신무장_끝);                   // 대회 우승횟수 카운트 배열. 우승횟수는 1000의 자리가 무술대회, 1의자리가 설전대회가 될것
        array<int> titleArray(3);                                     // 칭호 배열

        int 무술대회_개최여부 = 1;            // 한실 무술 설전대회 개최여부 (개최안함, 짝수, 홀수, 매년)
        int 설전대회_개최여부 = 2;
        int 자세력_대회_개최여부 = 1;         // 세력 내에서 대회를 개최할 조건을 만족할 경우 대회개최 버튼을 활성화시킬 것인지 여부 (true : 가능, false : 불가능)
        int 지역이점_사용여부 = -1;
        int 이민족지원_사용여부 = -1;
        int 이민족_특기전수_사용여부 = -1;
        int 고유기교_사용여부 = -1;
        int 능력연구_표시_사용여부 = -1;
        int 이민족외교_표시_사용여부 = -1;
        int 교역_표시_사용여부 = -1;
        int 왕귀_표시_사용여부 = -1;
        int 백출_기력반감 = -1;
        int 부상병시스템_사용여부 = -1;
        int 수정된_등용확률 = -1;
        int 수정된_포로확률 = -1;
        int 멸망시_공적감소 = -1;
        pk::func101_t@ prev_callback_101;                              // 이전 징병 치안 증감
        pk::func102_t@ prev_callback_102;                              // 이전 병기생산량
        pk::func111_t@ prev_callback_111;                              // 이전 등용확률
        pk::func150_t@ prev_callback_150;                              // 이전 금 수입
        pk::func151_t@ prev_callback_151;                              // 이전 병량 수입
        pk::func158_t@ prev_callback_158;                              // 이전 본거지 발생 확률
        pk::func163_t@ prev_callback_163;                              // 이전 부대 능력치
	    pk::func164_t@ prev_callback_164;         		               // 이전 부대 혼란 확률
	    pk::func165_t@ prev_callback_165;                              // 이전 부대의 병량 소비
        pk::func200_t@ prev_callback_200;                              // 이전 지원 공격 확률;
        pk::func201_t@ prev_callback_201;                              // 이전 공격 크리티컬 확률 
        pk::func202_t@ prev_callback_202;                              // 이전 전법 성공 확률
        pk::func206_t@ prev_callback_206;                              // 이전 계략 성공 확률
        pk::func209_t@ prev_callback_209;                              // 이전 부대 공격 데미지
        pk::func210_t@ prev_callback_210;                              // 이전 지원 공격 데미지
        pk::func211_t@ prev_callback_211;                              // 이전 건물의 공격 데미지

        // 부상병 계산을 위한 변수들
        pk::unit@ temp_attacker;
        pk::list<pk::unit@> target_unit_list;
        pk::list<pk::building@> target_building_list;
        array<int> unit_damage_array(500);            // 부대 최대 갯수 상한을 500으로 가정
        array<int> building_damage_array(건물_거점끝); // 부상병이 존재할 수 있는 거점 갯수
        array<int> origin_unit_leader_array(500);
        array<int> unit_origin_troops_array(500);                       // 부대의 초기 병사
        array<int> building_origin_troops_array(건물_거점끝);           // 건물의 초기 병사
        
        int waiting_leader_id;
        int waiting_unit_id;
        bool is_waiting = false;

        RegionBuff()
        {
            pk::bind(102, pk::trigger102_t(Init));
            pk::bind(102, pk::trigger102_t(OnGameInit));            // 특기 설명 수정을 위해 추가
            pk::bind(104, pk::trigger104_t(OnScenarioEnd));
            pk::bind(105, pk::trigger105_t(SaveData));
            pk::bind(107, pk::trigger107_t(UpdateDayStart));
            pk::bind(108, pk::trigger108_t(UpdateMonthStart));
            pk::bind(109, pk::trigger109_t(UpdateSeasonStart));
            pk::bind(110, pk::trigger110_t(UpdateYearStart));
            pk::bind(111, pk::trigger111_t(UpdateTurnStart));
            pk::bind(112, pk::trigger112_t(UpdateTurnEnd));
            pk::bind(120, pk::trigger120_t(UpdatePerFrame));                      // 매 프레임마다 호출
            pk::bind(170, pk::trigger170_t(UpdateUnitCreate));
            pk::bind(171, pk::trigger171_t(UpdateUnitRemove));
            pk::bind(173, pk::trigger173_t(UpdateUnitExp));
            pk::bind(174, pk::trigger174_t(UpdateUnitTurnEnd));

            @prev_callback_101 = cast<pk::func101_t@>(pk::get_func(101));
            pk::reset_func(101);
            pk::set_func(101, pk::func101_t(func101));                // 101 징병 치안 증감

            @prev_callback_102 = cast<pk::func102_t@>(pk::get_func(102));
            pk::reset_func(102);
            pk::set_func(102, pk::func102_t(func102));                // 102 병기생산량

            pk::reset_func(111);
            pk::set_func(111, pk::func111_t(func111));                // 111 등용확률

            @prev_callback_150 = cast<pk::func150_t@>(pk::get_func(150));
            pk::reset_func(150);
            pk::set_func(150, pk::func150_t(func150));                // 150 금 수입

            @prev_callback_151 = cast<pk::func151_t@>(pk::get_func(151));
            pk::reset_func(151);
            pk::set_func(151, pk::func151_t(func151));                // 151 병량 수입

            @prev_callback_158 = cast<pk::func158_t@>(pk::get_func(158));
            pk::reset_func(158);
            pk::set_func(158, pk::func158_t(func158));                // 158 본거지 발생 확률

            @prev_callback_163 = cast<pk::func163_t@>(pk::get_func(163));
            pk::reset_func(163);
            pk::set_func(163, pk::func163_t(func163));                // 163 부대 능력치

            @prev_callback_164 = cast<pk::func164_t@>(pk::get_func(164));
            pk::reset_func(164);
            pk::set_func(164, pk::func164_t(func164));                // 164 부대 혼란 확률

            @prev_callback_165 = cast<pk::func165_t@>(pk::get_func(165));
            pk::reset_func(165);
            pk::set_func(165, pk::func165_t(func165));                // 165 부대의 병량 소비

            pk::reset_func(168);
            pk::set_func(168, pk::func168_t(func168));                // 168 점령 후 처리

            @prev_callback_200 = cast<pk::func200_t@>(pk::get_func(200));
            pk::reset_func(200);
            pk::set_func(200, pk::func200_t(func200));                // 200 지원 공격 확률

            @prev_callback_201 = cast<pk::func201_t@>(pk::get_func(201));
            pk::reset_func(201);
            pk::set_func(201, pk::func201_t(func201));                // 201 공격 크리티컬 확률

            @prev_callback_202 = cast<pk::func202_t@>(pk::get_func(202));
            pk::reset_func(202);
            pk::set_func(202, pk::func202_t(func202));                // 202 전법 성공 확률

            pk::reset_func(205);
            pk::set_func(205, pk::func205_t(func205));                // 205 계략 소비 기력

            @prev_callback_206 = cast<pk::func206_t@>(pk::get_func(206));
            pk::reset_func(206);
            pk::set_func(206, pk::func206_t(func206));                // 206 계략 성공 확률

            @prev_callback_211 = cast<pk::func211_t@>(pk::get_func(211));
            pk::reset_func(211);
            pk::set_func(211, pk::func211_t(func211));                // 211 건물의 공격 데미지

            pk::reset_func(220);
            pk::set_func(220, pk::func220_t(func220));                // 220 포로 확률

            @prev_callback_209 = cast<pk::func209_t@>(pk::get_func(209));
            pk::reset_func(209);
            pk::set_func(209, pk::func209_t(func209));                // 209 부대의 공격 데미지

            @prev_callback_210 = cast<pk::func210_t@>(pk::get_func(210));
            pk::reset_func(210);
            pk::set_func(210, pk::func210_t(func210));                // 210 지원 공격 데미지

            AddRegionBuffHelpMenu();                                  // Shift 우클릭 지역이점 도움말 
            AddPrintRegionBuffMenu();                                 // Shift 우클릭 지역이점 현황 표시
            AddTradeMenu();                                           // 외국 교역 메뉴 추가
            AddrapprochementMenu();                                   // 이민족 교류 메뉴 추가
            AddSupportMenu();                                         // 이민족 지원요청 메뉴 추가
            AddCompetitionMenu();                                     // 대회개최 메뉴 추가
            AddUniqueTechHelpMenu();                                  // 고유기교 설명
            AddCheckCompetitionCountMenu();                           // 대회 우승횟수 체크
            AddSettingDataMenu();                                     // 지역이점 설정
            AddReturnOfKingMenu();                                    // 왕귀메뉴 추가.
            AddUniqueTechMenu();                                      // 고유기교 세팅메뉴 추가
        }

        // 게임 최초 실행시 지역이점 적용여부 확인작업
        void Init()
        {
            ArrayInit();
            LoadData();
            InitBarbarianMooArray();
 
            validForceUpdate(true);
            
            if(ai_prefer_uniqueTech_data[0] == 0)
                PrioritizeUniqueTech();

            if (pk::get_scenario().loaded)
                return;
            
            if (pk::choose(pk::u8encode("지역이점 스크립트에 대해 설정하시겠습니까?"), { pk::u8encode("예"), pk::u8encode("아니오") }) == 0)
            {
                CheckSettingDataHandler();
            }
            ReturnOfKingMoo.kouseki = 9999;
            ReturnOfKingDateMoo.kouseki = 0;
            //Test();
        }
        
        void LoadData()
        {
            int f = 0;
            int r = 0;
            for (int i = 기본데이터_시작; i < 도시_끝 * 3; ++i)
            {
                f = i / 3;
                r = i % 3;

                dataArray[f][r] = int(pk::load(KEY, i, 0));
            }

            for (int i = 이민족데이터_시작; i < 이민족데이터_시작 + 4; ++i)
            {
                barbarianDataArray[i - 이민족데이터_시작] = int(pk::load(KEY, i, 0));
            }

            for (int i = 황실대회_시작; i < 황실대회_시작 + 2; ++i)
            {
                competitionDataArray[i - 황실대회_시작] = int(pk::load(KEY, i, -1));
            }

            for (int i = 세력대회_시작; i < 세력대회_시작 + 도시_끝; ++i)
            {
                singleCompetitionDataArray[i - 세력대회_시작] = int(pk::load(KEY, i, -1));
            }

            for (int i = 부대_부상병_시작; i < 부대_부상병_시작 + 500; ++i)
            {
                woundedUnitArray[i - 부대_부상병_시작] = int(pk::load(KEY, i, 0));
            }

            for (int i = 거점_부상병_시작; i < 거점_부상병_시작 + 건물_거점끝; ++i)
            {
                woundedBuildingArray[i - 거점_부상병_시작] = int(pk::load(KEY, i, 0));
            }

            for (int i = 고유기교_시작; i < 고유기교_시작 + 도시_끝; ++i)
            {
                uniqueTechArray[i - 고유기교_시작] = int(pk::load(KEY, i, 0));
            }

            for (int i = 고유기교_카운트_시작; i < 고유기교_카운트_시작 + 도시_끝; ++i)
            {
                uniqueTechCount[i - 고유기교_카운트_시작] = int(pk::load(KEY, i, 0));
            }

            for (int i = 우승횟수_시작; i < 우승횟수_시작 + 신무장_끝; ++i)
            {
                competitionCountArray[i - 우승횟수_시작] = int(pk::load(KEY, i, 0));
            }

            for (int i = 칭호_시작; i < 칭호_시작 + 3; ++i)
            {
                titleArray[i - 칭호_시작] = int(pk::load(KEY, i, -1));
            }

            for (int i = 세력별_고유기교타입_시작; i < 세력별_고유기교타입_시작 + 도시_끝; ++i)
            {
                ai_uniqueTech_perfer_type[i - 세력별_고유기교타입_시작] = int(pk::load(KEY, i, 0));
            }

            for (int i = AI_고유기교시드_시작; i < AI_고유기교시드_시작 + 1000; ++i)
            {
                ai_prefer_uniqueTech_data[i - AI_고유기교시드_시작] = int(pk::load(KEY, i, 0));
            }

            지역이점_사용여부 = int(pk::load(KEY, 설정_지역이점_사용여부, 1));
            이민족지원_사용여부 = int(pk::load(KEY, 설정_이민족_지원_사용여부, 1));
            이민족_특기전수_사용여부 = int(pk::load(KEY, 설정_이민족_특기전수_사용여부, 1));
            무술대회_개최여부 = int(pk::load(KEY, 설정_무술대회_개최관련, 1));
            대회_개최시기_무술 = int(pk::load(KEY, 설정_무술대회_개최달, 4));
            설전대회_개최여부 = int(pk::load(KEY, 설정_설전대회_개최관련, 2));
            대회_개최시기_설전 = int(pk::load(KEY, 설정_설전대회_개최달, 4));
            자세력_대회_개최여부 = int(pk::load(KEY, 설정_자세력_대회_사용여부, 1));
            고유기교_사용여부 = int(pk::load(KEY, 설정_고유기교_사용여부, 1));
            능력연구_표시_사용여부 = int(pk::load(KEY, 설정_능력연구_표시_사용여부, 1));
            이민족외교_표시_사용여부 = int(pk::load(KEY, 설정_이민족외교_표시_사용여부, 1));
            교역_표시_사용여부 = int(pk::load(KEY, 설정_교역_표시_사용여부, 1));
            왕귀_표시_사용여부 = int(pk::load(KEY, 설정_왕귀_표시_사용여부, 1));
            백출_기력반감 = int(pk::load(KEY, 설정_백출_기력반감, 1));
            부상병시스템_사용여부 = int(pk::load(KEY, 설정_부상병시스템_사용여부, 1));
            수정된_등용확률 = int(pk::load(KEY, 설정_수정된_등용확률, 3));
            수정된_포로확률 = int(pk::load(KEY, 설정_수정된_포로확률, 3));
            멸망시_공적감소 = int(pk::load(KEY, 설정_멸망시_공적감소, 1));

            loadSuccess = true;
        }

        void SaveData(int file_id)
        {
            int f = 0;
            int r = 0;
            for (int i = 기본데이터_시작; i < 도시_끝 * 3; ++i)
            {
                f = i / 3;
                r = i % 3;

                pk::store(KEY, i, dataArray[f][r]);
            }

            for (int i = 이민족데이터_시작; i < 이민족데이터_시작 + 4; ++i)
            {
                pk::store(KEY, i, barbarianDataArray[i - 이민족데이터_시작]);
            }

            for (int i = 황실대회_시작; i < 황실대회_시작 + 2; ++i)
            {
                pk::store(KEY, i, competitionDataArray[i - 황실대회_시작]);
            }

            for (int i = 세력대회_시작; i < 세력대회_시작 + 도시_끝; ++i)
            {
                pk::store(KEY, i, singleCompetitionDataArray[i - 세력대회_시작]);
            }

            for (int i = 부대_부상병_시작; i < 부대_부상병_시작 + 500; ++i)
            {
                pk::store(KEY, i, woundedUnitArray[i - 부대_부상병_시작]);
            }

            for (int i = 거점_부상병_시작; i < 거점_부상병_시작 + 건물_거점끝; ++i)
            {
                pk::store(KEY, i, woundedBuildingArray[i - 거점_부상병_시작]);
            }

            for (int i = 고유기교_시작; i < 고유기교_시작 + 도시_끝; ++i)
            {
                pk::store(KEY, i, uniqueTechArray[i - 고유기교_시작]);
            }

            for (int i = 고유기교_카운트_시작; i < 고유기교_카운트_시작 + 도시_끝; ++i)
            {
                pk::store(KEY, i, uniqueTechCount[i - 고유기교_카운트_시작]);
            }

            for (int i = 우승횟수_시작; i < 우승횟수_시작 + 신무장_끝; ++i)
            {
                pk::store(KEY, i, competitionCountArray[i - 우승횟수_시작]);
            }

            for (int i = 칭호_시작; i < 칭호_시작 + 3; ++i)
            {
                pk::store(KEY, i, titleArray[i - 칭호_시작]);
            }

            for (int i = 세력별_고유기교타입_시작; i < 세력별_고유기교타입_시작 + 도시_끝; ++i)
            {
                pk::store(KEY, i, ai_uniqueTech_perfer_type[i - 세력별_고유기교타입_시작]);
            }

            for (int i = AI_고유기교시드_시작; i < AI_고유기교시드_시작 + 1000; ++i)
            {
                pk::store(KEY, i, ai_prefer_uniqueTech_data[i - AI_고유기교시드_시작]);
            }

            pk::store(KEY, 설정_지역이점_사용여부, 지역이점_사용여부);
            pk::store(KEY, 설정_이민족_지원_사용여부, 이민족지원_사용여부);
            pk::store(KEY, 설정_이민족_특기전수_사용여부, 이민족_특기전수_사용여부);
            pk::store(KEY, 설정_무술대회_개최관련, 무술대회_개최여부);
            pk::store(KEY, 설정_무술대회_개최달, 대회_개최시기_무술);
            pk::store(KEY, 설정_설전대회_개최관련, 설전대회_개최여부);
            pk::store(KEY, 설정_설전대회_개최달, 대회_개최시기_설전);
            pk::store(KEY, 설정_자세력_대회_사용여부, 자세력_대회_개최여부);
            pk::store(KEY, 설정_고유기교_사용여부, 고유기교_사용여부);
            pk::store(KEY, 설정_능력연구_표시_사용여부, 고유기교_사용여부);
            pk::store(KEY, 설정_이민족외교_표시_사용여부, 고유기교_사용여부);
            pk::store(KEY, 설정_교역_표시_사용여부, 고유기교_사용여부);
            pk::store(KEY, 설정_왕귀_표시_사용여부, 고유기교_사용여부);
            pk::store(KEY, 설정_백출_기력반감, 백출_기력반감);
            pk::store(KEY, 설정_부상병시스템_사용여부, 부상병시스템_사용여부);
            pk::store(KEY, 설정_수정된_등용확률, 수정된_등용확률);
            pk::store(KEY, 설정_수정된_포로확률, 수정된_포로확률);
            pk::store(KEY, 설정_멸망시_공적감소, 멸망시_공적감소);
        }

        void OnGameInit()
        {
            if (백출_기력반감 == 1)
                pk::get_skill(특기_백출).desc = pk::u8encode("부대계략 소모기력 반감");
            else
                pk::get_skill(특기_백출).desc = pk::u8encode("모든 계략의 소모 기력이 \x1b[2x1\x1b[0x이 됨");
        }

        void OnScenarioEnd()
        {
            loadSuccess = false;
        }

        // 새날 적용될 것
        void UpdateDayStart()
        {
            validForceTrigger();
            UpdateBarbarianForce();
            RecoverWoundedTroops();
            UpdateKingOfNamman();
            UpdateTitlePerson();
            CheckReturnOfKing();
            //CheckDuelCompetition();
            //CheckEloquenceCompetition();
        }

        // 새달 적용될 것
        void UpdateMonthStart()
        {
            ExecuteJiZhouLoyalty();
            ExecuteQingZhouPublicOrder();
            ExecuteJingBeiTech();
            UpdateBarbarianRelation();
            CheckDuelCompetition();
            CheckEloquenceCompetition();
            //CheckUniqueTech();
            UpdateHoryo();
        }

        // 새분기 적용될 것
        void UpdateSeasonStart()
        {
            ExecuteBarbarianSupport();
            UpdateTalentPerson();
        }

        // 새해 적용될것
        void UpdateYearStart()
        {
            ResetSingleCompetitionWinner();
        }

        // 턴 시작시 적용될 것
        void UpdateTurnStart(pk::force@ force)
        {
            UpdateRelation(force);
            ExecuteBarbarianSkill(force);
            ExecuteKushanLevelThree(force);
            ExecuteBingZhouEnergy(force);
            UpdateAICompetition(force);
            UpdatePillage(force);
            UpdateKingOfVirtue(force);
            UpdateDevastation(force);
            UpdateUniqueTech(force);
        }

        // 턴 종료시 적용될 것
        void UpdateTurnEnd(pk::force@ force)
        {
            ExecuteJiZhouSalary(force);
            ExecuteQingZhouFacility(force);
            ExecuteXuZhouHp(force);
            ExecuteYuZhou(force);
            UpdateAITradeTimer(force);
            //DevelopementKousekiUpdate(force);
        }

        void UpdatePerFrame()
        {
            if (부상병시스템_사용여부 == 1 && 게임화면_부상병_표시)
                displayWoundedTroops();
            DisplayProgress();
            CheckWaitingUnit();
        }

        void displayWoundedTroops()
        {
            pk::point cursor_pos = pk::get_cursor_hex_pos();
            pk::point center = pk::get_screen_center_hex_pos();
            if (!pk::is_valid_pos(cursor_pos)) return;
            string name = "";
            int troops;

            bool is_none_obejct = true;
            int width = int(pk::get_resolution().width);
            int height = int(pk::get_resolution().height);
            pk::point target_pos = pk::point(0, 0);
            // 커서가 가리키는 좌표 상의 건물
            pk::unit@ unit = pk::get_unit(cursor_pos);

            if (unit != null)
            {
                is_none_obejct = false;
                name = pk::format("\x1b[1x{} \x1b[0x\x1b[31x부대\x1b[0x", pk::u8decode(pk::get_name(pk::get_person(unit.leader))));
                troops = woundedUnitArray[unit.get_id()];
            }

            pk::building@ building = pk::get_building(cursor_pos);

            if (building != null)
            {
                if (building.get_id() <= 건물_무현항)
                {
                    is_none_obejct = false;
                    name = pk::format("\x1b[1x{}\x1b[0x", pk::u8decode(pk::get_name(building)));
                    troops = woundedBuildingArray[building.get_id()];
                }
            }

            if (is_none_obejct)
                return;

            pk::draw_filled_rect(pk::rectangle(pk::point(width / 2 - 130, height - 62), pk::size(260, 20)), 0xaa555555);
            pk::draw_text(pk::u8encode(pk::format("{}, \x1b[2x부상병\x1b[0x : \x1b[31x{}\x1b[0x", name, troops)), pk::point(width / 2 - 100, height - 60), -1, FONT_SMALL, 0x000000);
        }

        void DisplayProgress()
        {
            int force_id = pk::get_current_turn_force_id();
            pk::force@ force = pk::get_force(force_id);
            
            if (null == force)
                return;

            int width = int(pk::get_resolution().width);
            int height = int(pk::get_resolution().height);

            // pk::draw_text(pk::format("\x1b[" + "{}" + "x{}\x1b[0x", 타이머색상 ,timer + 1), pk::point(width / 2 - 60, 62), -1, FONT_BIG, 0x000000);
            if (force.is_player())
            {
                if (능력연구_표시_사용여부 == 1)
                {
                    if (force.researching_ability_timer > 0)
                    {
                        pk::draw_text(pk::u8encode(pk::format("능력연구 : \x1b[2x{}\x1b[0x턴" , force.researching_ability_timer)), pk::point(width / 100, height / 8 + 20), -1, FONT_BIG, 0x000000);
                    }
                    else
                    {
                        pk::draw_text(pk::u8encode ("능력연구 \x1b[29x없음\x1b[0x"), pk::point(width / 100, height / 8 + 20), -1, FONT_BIG, 0x000000);
                    }
                }

                if (이민족외교_표시_사용여부 == 1)
                {
                    bool isExist = false;
                    int 오환 = dataArray[force_id][1] % 4;
                    int 강 = (dataArray[force_id][1] / 4) % 4;
                    int 남만 = (dataArray[force_id][1] / 16) % 4;
                    int 산월 = (dataArray[force_id][1] / 64) % 4;
                    string s = "이민족 외교 : ";
                    if (오환 > 0)
                    {
                        s = s + pk::format("오환 : \x1b[2x{}\x1b[0x턴", 오환);
                        isExist = true;
                    }

                    if (강 > 0)
                    {
                        if (isExist)
                        {
                            s = s + ", ";
                        }

                        s = s + pk::format("강 : \x1b[2x{}\x1b[0x턴", 강);

                        isExist = true;
                    }

                    if (남만 > 0)
                    {
                        if (isExist)
                        {
                            s = s + ", ";
                        }

                        s = s + pk::format("남만 : \x1b[2x{}\x1b[0x턴", 남만);

                        isExist = true;
                    }

                    if (산월 > 0)
                    {
                        if (isExist)
                        {
                            s = s + ", ";
                        }

                        s = s + pk::format("산월 : \x1b[2x{}\x1b[0x턴", 산월);

                        isExist = true;
                    }
                    if (isExist)
                    {
                        pk::draw_text(pk::u8encode(s), pk::point(width / 100, height / 8 + 50), -1, FONT_BIG, 0x000000);
                    }
                    else
                    {
                        pk::draw_text(pk::u8encode("이민족 외교 \x1b[29x없음\x1b[0x"), pk::point(width / 100, height / 8 + 50), -1, FONT_BIG, 0x000000);
                    }
                }

                if (교역_표시_사용여부 == 1)
                {
                    if (GetTradeDay(force) > 0)
                    {
                        pk::draw_text(pk::u8encode(pk::format("교역 : \x1b[2x{}\x1b[0x턴", GetTradeDay(force))), pk::point(width / 100, height / 8 + 80), -1, FONT_BIG, 0x000000);
                    }
                    else
                    {
                        pk::draw_text(pk::u8encode("교역 \x1b[29x없음\x1b[0x"), pk::point(width / 100, height / 8 + 80), -1, FONT_BIG, 0x000000);
                    }
                }

                if (왕귀_표시_사용여부 == 1)
                {
                    if (GetReturnOfKingDate() > 0 && GetReturnOfKingMoo() != null)
                    {
                        pk::draw_text(pk::u8encode(pk::format("왕귀 : \x1b[1x{}\x1b[0x, \x1b[2x{}\x1b[0x턴", pk::u8decode(pk::get_name(GetReturnOfKingMoo())), GetReturnOfKingDate())), pk::point(width / 100, height / 8 + 110), -1, FONT_BIG, 0x000000);
                    }
                }
            }
        }

        // 부대 생성시 호출되는 함수 (부상병이 초기화 되지 않았을 경우 초기화)
        void UpdateUnitCreate(pk::unit@ unit, int type)
        {
            if (type == 0)
            {
                int id = unit.get_id();
                woundedUnitArray[id] = 0;
            }
        }

        // 부대 괴멸 시 
        void UpdateUnitRemove(pk::unit@ unit, int type)
        {
            int forceId = unit.get_force_id();

            // 이민족 세력일 경우 패스
            if (forceId >= 도시_끝)
            {
                return;
            }
            
            // 이민족 요청 부대는 처리 후 소멸
            if (unit.leader >= 적장_시작 && unit.leader < 적장_끝)
            {
                pk::person@ barbarian = pk::get_person(unit.leader);
                pk::set_district(pk::get_person(unit.leader), -1);
                barbarian.mibun = 신분_없음;
                return;
            }

            int woundedTroops = woundedUnitArray[unit.get_id()];
            pk::building@ service = pk::get_building(pk::get_service(unit));

            // 부대 괴멸
            if (type == 0)
            {
                // 부상병의 1/4는 도시로 귀환
                pk::building@ service = pk::get_building(pk::get_service(unit));
                if (service != null && pk::is_general_type(service))
                {
                    woundedBuildingArray[service.get_id()] = woundedBuildingArray[service.get_id()] + ((woundedTroops * 부상병_귀환율) / 100);
                }
                // 1/4는 해당 부대를 제거한 인접한 부대에 흡수 ==> 209 부대의 공격데미지 에서 계산한다

                woundedUnitArray[unit.get_id()] = 0;
            }
            // 부대 진입. 정확한 진입 거점을 확인하기 위해서 다음 프레임으로 미룬다.
            else if(type == 1)
            {
                is_waiting = true;
                waiting_leader_id = unit.leader;
                waiting_unit_id = unit.get_id();
            }
        }

        void UpdateUnitExp(pk::unit@ unit, int type)
        {
            int force_id = unit.get_force_id();

            // 무술 대회특전
            if (type == 6 || type == 7 || type == 9 || type == 10 || type == 12 || type == 13 || type == 15 || type == 16 || type == 18 || type == 19 ||
                type == 21 || type == 22 || type == 24 || type == 25 || type == 27 || type == 28 || type == 30 || type == 31 || type == 33 || type == 34 ||
                type == 36 || type == 37 || type == 39 || type == 40 || type == 42 || type == 43 || type == 45 || type == 46 || type == 48 || type == 49 ||
                type == 51 || type == 52)
            {
                ExecuteDuelPrivillage(unit, false);
            }

            // 설전 대회특전
            if (type == 54 || type == 55 || type == 57 || type == 58 || type == 60 || type == 61 || type == 63 || type == 64 || type == 66 || type == 67 ||
                type == 69 || type == 70 || type == 72 || type == 73 || type == 75 || type == 76 || type == 78 || type == 79)
            {
                ExecuteEloquencePrivillage(unit, false);
            }

            // 고유기교
            if (HasUniqueTech(force_id, 고유기교_서량철기))
            {
                int atk = unit.attr.stat[부대능력_공격];
                int bonus = 0;
                
                // 전법 돌격 성공
                if (type == 33 || type == 34)
                {
                    bonus = pk::rand(30) + 50;
                }
                // 전법 돌파 성공
                else if (type == 36 || type == 37)
                {
                    bonus = pk::rand(30) + 20;
                }
                // 전법 돌진 성공
                else if (type == 39 || type == 40)
                {
                    bonus = pk::rand(30);
                }
                else
                {
                    return;
                }

                array<pk::point> arr = pk::range(unit.get_pos(), 1, 1);
                bool is_damage = false;
                for (int i = 0; i < arr.length; ++i)
                {
                    int damage = 0;
                    pk::unit@ dst = pk::get_unit(arr[i]);

                    if (dst == null || !pk::is_enemy(unit, dst))
                    {
                        continue;
                    }
                    
                    int dst_def = dst.attr.stat[부대능력_방어];
                    damage = pk::max(0, (atk - dst_def) * 서량철기_능력차_배율) + bonus;
                    
                    if(damage <= 0)
                        continue;

                    if (damage > 서량철기_최대피해)
                        damage = 서량철기_최대피해;

                    if (HasUnitUniqueTechMoo(unit, 고유기교_서량철기))
                        damage *= 2;

                    if (dst.troops <= damage)
                    {
                        pk::kill(dst, unit, true);
                    }
                    else
                    {
                        pk::add_troops(dst, -damage, true);
                    }

                    pk::point pos = dst.get_pos();

                    if (pk::is_in_screen(unit.get_pos()))
                    {
                        if (!is_damage)
                        {
                            // 대사
                            if (unit.member[0] == 무장_마초 || unit.member[1] == 무장_마초 || unit.member[2] == 무장_마초)
                            {
                                pk::say(pk::u8encode("내가 서량의 금마초다!"), pk::get_person(무장_마초), unit);
                            }
                            else
                            {
                                if (pk::rand_bool(50))
                                {
                                    pk::say(pk::u8encode("서량철기의 맛을 봐라...!"), pk::get_person(unit.leader), unit);
                                }
                                else
                                {
                                    pk::say(pk::u8encode("하하하, 모조리 짓밟아주마!"), pk::get_person(unit.leader), unit);
                                }
                            }

                            if (pk::rand_bool(50) && dst.is_alive())
                            {
                                pk::say(pk::u8encode("크윽... 대단한 파괴력이다.."), pk::get_person(dst.leader), dst);
                            }
                            else
                            {
                                pk::say(pk::u8encode("무시못할 위력이군..."), pk::get_person(dst.leader), dst);
                            }
                            is_damage = true;
                        }
                    }
                }
            }

            if (HasUniqueTech(force_id, 고유기교_백마의종))
            {
                if (unit.weapon == 병기_군마)
                {
                    int energy = 0;
                    bool is_damage = false;
                    // 일반공격 혹은 전법실패시
                    if (type == 35 || type == 38 || type == 41 || type == 0 || type == 1)
                    {
                        pk::add_energy(unit, 백마의종_일반공격_기력증가, true);
                    }
                    // 전법 돌격 성공
                    else if (type == 33 || type == 34)
                    {
                        energy = 백마의종_기력감소_돌진 + 백마의종_기력감소_추가 * 2;
                    }
                    // 전법 돌파 성공
                    else if (type == 36 || type == 37)
                    {
                        energy = 백마의종_기력감소_돌진 + 백마의종_기력감소_추가 * 1;
                    }
                    // 전법 돌진 성공
                    else if (type == 39 || type == 40)
                    {
                        energy = 백마의종_기력감소_돌진;
                    }

                    if (energy > 0)
                    {
                        array<pk::point> arr = pk::range(unit.get_pos(), 1, 1);

                        for (int i = 0; i < arr.length; ++i)
                        {
                            pk::unit@ dst = pk::get_unit(arr[i]);

                            if (dst == null || !pk::is_enemy(unit, dst))
                            {
                                continue;
                            }

                            pk::add_energy(dst, -energy, true);

                            pk::point pos = dst.get_pos();
                            
                            if (pk::is_in_screen(unit.get_pos()))
                            {
                                if (!is_damage)
                                {
                                    // 대사
                                    if (pk::rand_bool(50))
                                    {
                                        pk::say(pk::u8encode("이것이 백마의종이다..!"), pk::get_person(unit.leader), unit);
                                    }
                                    else
                                    {
                                        pk::say(pk::u8encode("하하하, 마구 날뛰어라!"), pk::get_person(unit.leader), unit);
                                    }

                                    if (pk::rand_bool(50) && dst.is_alive())
                                    {
                                        pk::say(pk::u8encode("으으... 상당한 위력이군.."), pk::get_person(dst.leader), dst);
                                    }
                                    else
                                    {
                                        pk::say(pk::u8encode("쳇, 병사들의 사기가..."), pk::get_person(dst.leader), dst);
                                    }
                                    is_damage = true;
                                }
                            }
                        }
                    }
                }
            }

            if (HasUniqueTech(force_id, 고유기교_질풍))
            {
                if (unit.weapon != 병기_노)
                {
                    return;
                }

                if (type == 24 || type == 25 || type == 27 || type == 28 || type == 30 || type == 31)
                {
                    int 최대사거리 = 2;

                    if (pk::get_force(force_id).tech[기교_강노])
                        최대사거리 = 3;

                    array<pk::point> arr = pk::range(unit.get_pos(), 2, 최대사거리);

                    pk::list<pk::unit@> target_list;

                    for (int i = 0; i < arr.length; ++i)
                    {
                        pk::unit@ target = pk::get_unit(arr[i]);

                        if (target == null || !pk::is_enemy(unit, target))
                        {
                            continue;
                        }

                        target_list.add(target);
                    }

                    if (target_list.count > 0)
                    {
                        target_list.shuffle();

                        if (pk::is_in_screen(unit.get_pos()))
                        {
                            if (pk::rand_bool(50))
                            {
                                pk::say(pk::u8encode("하하하하. 이것이 화살의 폭풍이다."), pk::get_person(unit.leader), unit);
                            }
                            else
                            {
                                pk::say(pk::u8encode("질풍같이 몰아쳐라!"), pk::get_person(unit.leader), unit);
                            }
                        }

                        pk::attack(unit, target_list[0]);
                    }
                }
            }

            if (HasUniqueTech(force_id, 고유기교_허유엄살))
            {
                if (type == 60 || type == 61 || type == 63 || type == 64 || type == 72 || type == 73)
                {
                    int source_int = unit.attr.stat[부대능력_지력];

                    array<pk::point> arr = pk::range(unit.get_pos(), 1, 2);

                    pk::list<pk::unit@> unit_list;

                    for (int i = 0; i < arr.length; ++i)
                    {
                        pk::unit@ dst = pk::get_unit(arr[i]);

                        if (dst == null || !pk::is_enemy(unit, dst))
                        {
                            continue;
                        }

                        unit_list.add(dst);
                    }

                    if (unit_list.count > 0)
                    {
                        unit_list.shuffle();

                        int damage = 0;
                        int base_damage = 0;
                        if (unit.troops < 1000)
                            return;
                        else if (unit.troops <= 5000)
                        {
                            base_damage = 250;
                        }
                        else
                        {
                            base_damage = unit.troops / 20;
                        }

                        int cof; // 계수

                        int dst_int = unit_list[0].attr.stat[부대능력_지력];
                        cof = (source_int - dst_int) * 허유엄살_지력차_배율;

                        if (cof > 200)
                            cof = 200;

                        damage = pk::max(0, base_damage * cof / 100);

                        if (damage <= 허유엄살_최소피해)
                            damage = 허유엄살_최소피해;
                        if (damage > 허유엄살_최대피해)
                            damage = 허유엄살_최대피해;

                        if (HasUnitUniqueTechMoo(unit, 고유기교_허유엄살))
                            damage *= 2;

                        if (unit_list[0].troops <= damage)
                        {
                            pk::kill(unit_list[0], unit, true);
                        }
                        else
                        {
                            pk::add_troops(unit_list[0], -damage, true);
                        }

                        pk::point pos = unit_list[0].get_pos();

                        if (pk::is_in_screen(unit.get_pos()))
                        {
                            if (unit.member[0] == 무장_가후 || unit.member[1] == 무장_가후 || unit.member[2] == 무장_가후)
                            {
                                pk::say(pk::u8encode("하하하. 이 가문화의 책략을 우습게 보지 말게"), pk::get_person(무장_가후), unit);
                            }
                            else
                            {
                                if (pk::rand_bool(50))
                                {
                                    pk::say(pk::u8encode("주저하지 말고 모든 수단을 쓴다!"), pk::get_person(unit.leader), unit);
                                }
                                else
                                {
                                    pk::say(pk::u8encode("적의 실책을 놓치지 마라!"), pk::get_person(unit.leader), unit);
                                }
                            }

                            if (pk::rand_bool(50) && unit_list[0].is_alive())
                            {
                                pk::say(pk::u8encode("이런 부끄러운 실수를.."), pk::get_person(unit_list[0].leader), unit_list[0]);
                            }
                            else
                            {
                                pk::say(pk::u8encode("으으... 대체 무슨일이.."), pk::get_person(unit_list[0].leader), unit_list[0]);
                            }
                        }
                    }
                }
            }
        }

        // 부대 행동 완료 시 적용될 것
        void UpdateUnitTurnEnd(pk::unit@ unit)
        {
            ExecuteParthianLevelThree(unit);
            ExecuteDuelPrivillage(unit, true);
            ExecuteEloquencePrivillage(unit, true);
            ExecuteSingleCompetitionPrivilage(unit);
            CalculateWoundedTroops();
            ResetTargetList();
        }

        void Test()
        {
            auto forces = pk::get_force_list();

            for (int i = 0; i < forces.count; ++i)
            {
                pk::force@ force = forces[i];

                if (true == IsValidForce(force) && true == force.is_player())
                {
                    AddRelationValue(force, 우호_오환, 1);
                    AddRelationValue(force, 우호_강, 1);
                    AddRelationValue(force, 우호_남만, 2);
                    AddRelationValue(force, 우호_오환, 1);
                    AddRelationValue(force, 우호_산월, 2);
                    AddRelationValue(force, 우호_대진국, 3);
                    AddRelationValue(force, 우호_안식국, 3);
                    AddRelationValue(force, 우호_천축국, 3);
                    AddRelationValue(force, 우호_귀상국, 2);
                    AddRelationValue(force, 우호_선비, 1);
                }
            }
        }

        // ======================================================  지역 이점 ============================================================
        
        // AI의 자체 교역 쿨타임을 업데이트 하는 함수. AI 턴종시 실행
        void UpdateAITradeTimer(pk::force@ force)
        {
            if (false == IsValidForce(force))
            {
                return;
            }

            if (false == force.is_player())
            {
                // AI의 이민족 교역 
                UpdateAIRapprochmentTerm(force);

                if (0 >= GetAIRapprochmentTerm(force))
                {
                    int targetId = AIRapprochement(force);
                    if (-1 != targetId)
                    {
                        ExecuteRapprochment(force, targetId);
                        // AI의 이민족 쿨타임
                        SetAIRapprochmentTerm(force, (AI_화친_레벨당_페널티 + 3) + AI_화친_레벨당_페널티 * GetRelationLevel(force, targetId));
                    }
                }

                ExecuteAISupport(force);

                // AI의 외국 교역
                int targetId = AITrade(force);
                if (-1 != targetId)
                {
                    ExecuteTrade(force, targetId);
                }
            }
        }

        // 안식국 2단계 효과
        void ExecuteParthianLevelThree(pk::unit@ unit)
        {
            if (false == pk::is_alive(unit) || 부대상태_통상 != unit.status)
            {
                return;
            }

            if (병기_군마 != pk::get_weapon_id(unit))
            {
                return;
            }

            pk::force@ force = pk::get_force(unit.get_force_id());

            if (true == IsValidForce(force))
            {
                if (GetRelationLevel(force, 우호_안식국) >= 2 && true == force.tech[기교_기사])
                {
                    int value = 안식_2단계_추가사격확률;

                    if (false == IsEnableZhou(force, 경조))
                    {
                        value = value / 2;
                    }

                    if (true == pk::rand_bool(value))
                    {
                        array<pk::point> arr = pk::range(unit.get_pos(), 2, 2);
                        int count = 0;
                        array<pk::unit@> targets(6);

                        for (int i = 0; i < arr.length; ++i)
                        {
                            pk::unit@ target = pk::get_unit(arr[i]);

                            if (target == null || !pk::is_enemy(unit, target))
                            {
                                continue;
                            }

                            @targets[count] = target;
                            count++;
                        }

                        if (count != 0)
                        {
                            pk::attack(unit, targets[pk::rand(count)]);
                            pk::say(pk::u8encode("하하하. 이것이 안식사법이다!"), pk::get_person(unit.leader), unit);
                        }
                    }
                }
            }
        }
        
        // 이민족 2단계 특기전수 보너스
        void ExecuteBarbarianSkill(pk::force@ force)
        {
            if (이민족_특기전수_사용여부 == 0)
                return;

            pk::person@ kunshu = pk::get_person(force.kunshu);

            //if (!force.is_player())
            //{
            //    return;
            //}

            int day = pk::get_day();

            if (1 != day )
            {
                return;
            }

            int month = pk::get_month();

            if (false == IsValidForce(force))
            {
                return;
            }

            pk::list<pk::person@> officers = pk::get_person_list(force, pk::mibun_flags(신분_군주, 신분_도독, 신분_태수, 신분_일반));
            
            if (officers.count == 0)
            {
                return;
            }


            int level = 0;
            int rand = -1;

            level = GetRelationLevel(force, 우호_오환);
            int barbarianSkillId = -1;
            string skillName = "";
            if (level >= 2 && month == 1)
            {
                pk::list<pk::person@> temp;
                
                for (int i = 0; i < officers.count; ++i)
                {
                    if (false == IsValidPerson(officers[i]))
                    {
                        continue;
                    }

                    if (-1 == officers[i].skill)
                    {
                        if (officers[i].get_id() < 적장_시작)
                        {
                            temp.add(officers[i]);
                        }
                    }
                }

                array<pk::person@> arr = pk::list_to_array(temp);
                array<pk::person@> result = RandPersonArray(arr, 5);

                pk::person@ barbarian = pk::get_person(무장_오환장수);

                rand = pk::rand(100);
                if (rand <= 14)
                {
                    // 백마
                    barbarianSkillId = 특기_백마;
                    skillName = "백마";
                }
                else if (rand <= 24)
                {
                    // 급습
                    barbarianSkillId = 특기_급습;
                    skillName = "급습";
                }
                else if (rand <= 28)
                {
                    // 번식
                    barbarianSkillId = 특기_번식;
                    skillName = "번식";
                }
                else if (rand <= 68)
                {
                    // 친오
                    barbarianSkillId = 특기_친오;
                    skillName = "친오";
                }
                else if (rand <= 73)
                {
                    // 맹장
                    barbarianSkillId = 특기_맹장;
                    skillName = "맹장";
                }
                else if (rand <= 98)
                {
                    // 앙양
                    barbarianSkillId = 특기_앙양;
                    skillName = "앙양";
                }
                else
                {
                    // 기장
                    barbarianSkillId = 특기_기장;
                    skillName = "기장";
                }
                
                if (result.length > 0)
                {
                    if (true == force.is_player())
                    {
                        // 전수무장 선택
                        SelectPersonAddSkill(result, kunshu, barbarian, "오환", barbarianSkillId, skillName);
                    }
                    else
                    {
                        // 컴터 로직
                        if (barbarianSkillId != 특기_친오)
                        {
                            result[0].skill = barbarianSkillId;
                            string s = pk::format("\x1b[2x{}군\x1b[0x의 \x1b[1x{}\x1b[0x, \x1b[2x{}\x1b[0x에게서 특기 \x1b[1x{}\x1b[0x 사사", pk::u8decode(pk::get_name(force)), pk::u8decode(pk::get_name(result[0])), "오환", skillName);
                            pk::history_log(result[0].get_pos(), force.color, pk::u8encode(s));
                        }
                    }
                }
            }

            level = GetRelationLevel(force, 우호_강);

            if (level >= 2 && month == 10)
            {
                pk::list<pk::person@> temp;

                for (int i = 0; i < officers.count; ++i)
                {
                    if (false == IsValidPerson(officers[i]))
                    {
                        continue;
                    }

                    if (-1 == officers[i].skill)
                    {
                        temp.add(officers[i]);
                    }
                }

                array<pk::person@> arr = pk::list_to_array(temp);
                array<pk::person@> result = RandPersonArray(arr, 5);

                pk::person@ barbarian = pk::get_person(무장_강장수);

                rand = pk::rand(100);

                if (rand <= 14)
                {
                    // 행군
                    barbarianSkillId = 특기_행군;
                    skillName = "행군";
                }
                else if (rand <= 24)
                {
                    // 급습
                    barbarianSkillId = 특기_급습;
                    skillName = "급습";
                }
                else if (rand <= 28)
                {
                    // 번식
                    barbarianSkillId = 특기_번식;
                    skillName = "번식";
                }
                else if (rand <= 68)
                {
                    // 친강
                    barbarianSkillId = 특기_친강;
                    skillName = "친강";
                }
                else if (rand <= 73)
                {
                    // 맹장
                    barbarianSkillId = 특기_맹장;
                    skillName = "맹장";
                }
                else if (rand <= 98)
                {
                    // 앙양
                    barbarianSkillId = 특기_앙양;
                    skillName = "앙양";
                }
                else
                {
                    // 도주
                    barbarianSkillId = 특기_도주;
                    skillName = "도주";
                }

                if (result.length > 0)
                {
                    if (true == force.is_player())
                    {
                        // 전수무장 선택
                        SelectPersonAddSkill(result, kunshu, barbarian, "강", barbarianSkillId, skillName);
                    }
                    else
                    {
                        // 컴터 로직
                        if (barbarianSkillId != 특기_친강)
                        {
                            result[0].skill = barbarianSkillId;
                            string s = pk::format("\x1b[2x{}군\x1b[0x의 \x1b[1x{}\x1b[0x, \x1b[2x{}\x1b[0x에게서 특기 \x1b[1x{}\x1b[0x 사사", pk::u8decode(pk::get_name(force)), pk::u8decode(pk::get_name(result[0])), "강", skillName);
                            pk::history_log(result[0].get_pos(), force.color, pk::u8encode(s));
                        }
                    }
                }
            }

            level = GetRelationLevel(force, 우호_남만);

            if (level >= 2 && month == 4)
            {
                pk::list<pk::person@> temp;

                for (int i = 0; i < officers.count; ++i)
                {
                    if (false == IsValidPerson(officers[i]))
                    {
                        continue;
                    }

                    if (-1 == officers[i].skill)
                    {
                        temp.add(officers[i]);
                    }
                }

                array<pk::person@> arr = pk::list_to_array(temp);
                array<pk::person@> result = RandPersonArray(arr, 5);

                pk::person@ barbarian = pk::get_person(무장_남만장수);

                rand = pk::rand(100);

                if (rand <= 14)
                {
                    // 난전
                    barbarianSkillId = 특기_난전;
                    skillName = "난전";
                }
                else if (rand <= 24)
                {
                    // 등갑
                    barbarianSkillId = 특기_등갑;
                    skillName = "등갑";
                }
                else if (rand <= 34)
                {
                    // 답파
                    barbarianSkillId = 특기_답파;
                    skillName = "답파";
                }
                else if (rand <= 74)
                {
                    // 친만
                    barbarianSkillId = 특기_친만;
                    skillName = "친만";
                }
                else if (rand <= 78)
                {
                    // 맹장
                    barbarianSkillId = 특기_맹장;
                    skillName = "맹장";
                }
                else if (rand <= 98)
                {
                    // 앙양
                    barbarianSkillId = 특기_앙양;
                    skillName = "앙양";
                }
                else
                {
                    // 극장
                    barbarianSkillId = 특기_극장;
                    skillName = "극장";
                }

                if (result.length > 0)
                {
                    if (true == force.is_player())
                    {
                        // 전수무장 선택
                        SelectPersonAddSkill(result, kunshu, barbarian, "남만", barbarianSkillId, skillName);
                    }
                    else
                    {
                        // 컴터 로직
                        if (barbarianSkillId != 특기_친만)
                        {
                            result[0].skill = barbarianSkillId;
                            string s = pk::format("\x1b[2x{}군\x1b[0x의 \x1b[1x{}\x1b[0x, \x1b[2x{}\x1b[0x에게서 특기 \x1b[1x{}\x1b[0x 사사", pk::u8decode(pk::get_name(force)), pk::u8decode(pk::get_name(result[0])), "남만", skillName);
                            pk::history_log(result[0].get_pos(), force.color, pk::u8encode(s));
                        }
                    }
                }
            }

            level = GetRelationLevel(force, 우호_산월);

            if (level >= 2 && month == 7)
            {
                pk::list<pk::person@> temp;

                for (int i = 0; i < officers.count; ++i)
                {
                    if (false == IsValidPerson(officers[i]))
                    {
                        continue;
                    }

                    if (-1 == officers[i].skill)
                    {
                        temp.add(officers[i]);
                    }
                }

                array<pk::person@> arr = pk::list_to_array(temp);
                array<pk::person@> result = RandPersonArray(arr, 5);

                pk::person@ barbarian = pk::get_person(무장_산월장수);

                rand = pk::rand(100);

                if (rand <= 14)
                {
                    // 소탕
                    barbarianSkillId = 특기_소탕;
                    skillName = "소탕";
                }
                else if (rand <= 24)
                {
                    // 강탈
                    barbarianSkillId = 특기_강탈;
                    skillName = "강탈";
                }
                else if (rand <= 34)
                {
                    // 노발
                    barbarianSkillId = 특기_노발;
                    skillName = "노발";
                }
                else if (rand <= 74)
                {
                    // 친월
                    barbarianSkillId = 특기_친월;
                    skillName = "친월";
                }
                else if (rand <= 78)
                {
                    // 맹장
                    barbarianSkillId = 특기_맹장;
                    skillName = "맹장";
                }
                else if (rand <= 98)
                {
                    // 앙양
                    barbarianSkillId = 특기_앙양;
                    skillName = "앙양";
                }
                else
                {
                    // 포박
                    barbarianSkillId = 특기_포박;
                    skillName = "포박";
                }

                if (result.length > 0)
                {
                    if (true == force.is_player())
                    {
                        // 전수무장 선택
                        SelectPersonAddSkill(result, kunshu, barbarian, "산월", barbarianSkillId, skillName);
                    }
                    else
                    {
                        // 컴터 로직
                        if (barbarianSkillId != 특기_친월)
                        {
                            result[0].skill = barbarianSkillId;
                            string s = pk::format("\x1b[2x{}군\x1b[0x의 \x1b[1x{}\x1b[0x, \x1b[2x{}\x1b[0x에게서 특기 \x1b[1x{}\x1b[0x 사사", pk::u8decode(pk::get_name(force)), pk::u8decode(pk::get_name(result[0])), "산월", skillName);
                            pk::history_log(result[0].get_pos(), force.color, pk::u8encode(s));
                        }
                    }
                }
            }
        }

        void SelectPersonAddSkill(array<pk::person@> result, pk::person@ kunshu, pk::person@ barbarian, string forceName, int barbarianSkillId, string skillName)
        {
            pk::force@ force = pk::get_force(kunshu.get_force_id());
            pk::play_se(17);
            pk::message_box(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x에서 사자가 도착했습니다.", forceName)));
            pk::message_box(pk::u8encode(pk::format("\x1b[1x{}\x1b[0x공 잘 지내셨소? 오늘은 우리 대왕의 명을 받아 찾아뵙게 되었소이다.", pk::u8decode(pk::get_name(kunshu)))), barbarian);
            pk::message_box(pk::u8encode("오오.. 어쩐일로 오셨는가?"), kunshu);
            pk::message_box(pk::u8encode(pk::format("우리 대왕께서는 맹우를 위해서 우리 \x1b[2x{}\x1b[0x의 강력한 기술을 전해준다고 하셨소.", forceName)), barbarian);
            pk::message_box(pk::u8encode(pk::format("우리가 각별히 아끼는 특기인 \x1b[1x{}\x1b[0x(을)를 그대들에게 전수해주겠다고 하셨는데 어떻소?", skillName)), barbarian);

            array<string> menuArray(result.length + 1);
            for (int i = 0; i < result.length; ++i)
            {
                menuArray[i] = pk::u8encode(pk::format("\x1b[2x{}\x1b[0x에게 전수", pk::u8decode(pk::get_name(result[i]))));
            }
            menuArray[result.length] = pk::u8encode("거절한다");
            int choose = pk::choose(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x 특기를 전수받을 무장을 선택해주십시오.\n", skillName)), menuArray);

            if (choose < result.length)
            {
                result[choose].skill = barbarianSkillId;
                // 승낙
                pk::message_box(pk::u8encode("하하하. 큰 은혜를 입었군. 정말 감사하다고 전해주시오."), kunshu);
                pk::play_se(10);
                pk::message_box(pk::u8encode(pk::format("\x1b[1x{}\x1b[0x에게 특기 \x1b[1x{}\x1b[0x(을)를 전수했습니다.", pk::u8decode(pk::get_name(result[choose])), skillName)));
                string s = pk::format("\x1b[2x{}군\x1b[0x의 \x1b[1x{}\x1b[0x, \x1b[2x{}\x1b[0x에게서 특기 \x1b[1x{}\x1b[0x 사사", pk::u8decode(pk::get_name(force)), pk::u8decode(pk::get_name(result[choose])), forceName, skillName);
                pk::history_log(result[choose].get_pos(), force.color, pk::u8encode(s));
            }
            else
            {
                // 거절
                pk::play_se(7);
                pk::message_box(pk::u8encode("배려는 감사하지만 거절해야겠소."), kunshu);
                pk::message_box(pk::u8encode("으음... 유감이오. 그럼 이만.."), barbarian);
            }
        }

        // 이민족 물자 제공
        void ExecuteBarbarianSupport()
        {
            auto forceList = pk::get_force_list();
            array<pk::force@> arr = pk::list_to_array(forceList);
            int level = 0;

            for (int i = 0; i < arr.length; ++i)
            {
                if (false == IsValidForce(arr[i]))
                {
                    continue;
                }

                level = GetRelationLevel(arr[i], 우호_오환);

                if (level >= 2)
                {
                    for (int j = 0; j < 유주_도시.length; ++j)
                    {
                        pk::city@ city = pk::get_city(유주_도시[j]);

                        if (city.get_force_id() == arr[i].get_force_id())
                        {
                            pk::add_troops(city, 5000, true);
                            pk::add_weapon_amount(city, 병기_군마 , 5000, true);
                            break;
                        }
                    }
                }
                else if (level > 0)
                {
                    for (int j = 0; j < 유주_도시.length; ++j)
                    {
                        pk::city@ city = pk::get_city(유주_도시[j]);

                        if (city.get_force_id() == arr[i].get_force_id())
                        {
                            pk::add_troops(city, 3000, true);
                            pk::add_weapon_amount(city, 병기_군마, 3000, true);
                            break;
                        }
                    }
                }

                level = GetRelationLevel(arr[i], 우호_강);

                if (level >= 2)
                {
                    for (int j = 0; j < 량주_도시.length; ++j)
                    {
                        pk::city@ city = pk::get_city(량주_도시[j]);

                        if (city.get_force_id() == arr[i].get_force_id())
                        {
                            pk::add_troops(city, 5000, true);
                            pk::add_weapon_amount(city, 병기_군마, 5000, true);
                            break;
                        }
                    }
                }
                else if (level > 0)
                {
                    for (int j = 0; j < 량주_도시.length; ++j)
                    {
                        pk::city@ city = pk::get_city(량주_도시[j]);

                        if (city.get_force_id() == arr[i].get_force_id())
                        {
                            pk::add_troops(city, 3000, true);
                            pk::add_weapon_amount(city, 병기_군마, 3000, true);
                            break;
                        }
                    }
                }

                level = GetRelationLevel(arr[i], 우호_남만);

                if (level >= 2)
                {
                    for (int j = 0; j < 남중_도시.length; ++j)
                    {
                        pk::city@ city = pk::get_city(남중_도시[j]);

                        if (city.get_force_id() == arr[i].get_force_id())
                        {
                            pk::add_troops(city, 5000, true);
                            pk::add_weapon_amount(city, 병기_극, 2500, true);
                            pk::add_weapon_amount(city, 병기_창, 2500, true);
                            break;
                        }
                    }
                }
                else if (level > 0)
                {
                    for (int j = 0; j < 남중_도시.length; ++j)
                    {
                        pk::city@ city = pk::get_city(남중_도시[j]);

                        if (city.get_force_id() == arr[i].get_force_id())
                        {
                            pk::add_troops(city, 3000, true);
                            pk::add_weapon_amount(city, 병기_극, 1500, true);
                            pk::add_weapon_amount(city, 병기_창, 1500, true);
                            break;
                        }
                    }
                }

                level = GetRelationLevel(arr[i], 우호_산월);

                if (level >= 2)
                {
                    for (int j = 0; j < 양주_도시.length; ++j)
                    {
                        pk::city@ city = pk::get_city(양주_도시[j]);

                        if (city.get_force_id() == arr[i].get_force_id())
                        {
                            pk::add_troops(city, 3000, true);
                            pk::add_weapon_amount(city, 병기_극, 3000, true);
                            if (true == arr[i].tech[기교_투석개발])
                            {
                                pk::add_weapon_amount(city, 병기_투함, 1, true);
                            }
                            else
                            {
                                pk::add_weapon_amount(city, 병기_누선, 1, true);
                            }
                            break;
                        }
                    }
                }
                else if (level > 0)
                {
                    for (int j = 0; j < 양주_도시.length; ++j)
                    {
                        pk::city@ city = pk::get_city(양주_도시[j]);

                        if (city.get_force_id() == arr[i].get_force_id())
                        {
                            pk::add_troops(city, 3000, true);
                            pk::add_weapon_amount(city, 병기_극, 3000, true);
                            break;
                        }
                    }
                }
            }
        }

        // 귀상국 3단계 이점. 부대 상태이상 회복 및 행동가능
        void ExecuteKushanLevelThree(pk::force@ force)
        {
            if (3 > GetRelationLevel(force, 우호_귀상국))
            {
                return;
            }

            int value = 귀상_3단계_진정확률;
            if (false == IsEnableZhou(force, 익주))
            {
                value = value / 2;
            }

            auto unitList = pk::get_unit_list(force);
            array<pk::unit@> arr = pk::list_to_array(unitList);

            for (int i = 0; i < arr.length; ++i)
            {
                if (false == pk::is_alive(arr[i]))
                {
                    continue;
                }

                if (부대상태_통상 != arr[i].status )
                {
                    if (true == pk::rand_bool(value))
                    {
                        arr[i].status = 부대상태_통상;

                        if (pk::rand(2) == 0)
                        {
                            pk::say(pk::u8encode("침착하게 대열을 갖추어라!"), pk::get_person(arr[i].leader), arr[i]);
                        }
                        else
                        {
                            pk::say(pk::u8encode("병사들의 동요가 빠르게 가라앉는군. 이것이 아미타바인가.."), pk::get_person(arr[i].leader), arr[i]);
                        }
                    }
                }

                if (true == arr[i].action_done && arr[i].status == 부대상태_통상)
                {
                    pk::set_action_done(arr[i], false);
                }
            }
        }

        // 병주 지역이점. 부대 기력상승
        void ExecuteBingZhouEnergy(pk::force@ force)
        {
            if (false == IsEnableZhou(force, 병주))
            {
                return;
            }

            int forceId = force.get_force_id();
            auto unitList = pk::get_unit_list(force);
            array<pk::unit@> arr = pk::list_to_array(unitList);
            

            for (int i = 0; i < arr.length; ++i)
            {
                if (arr[i].type == 0)
                {
                    bool isEnemyGround = false;

                    pk::city@ city = pk::get_city(pk::get_city_id(arr[i].get_pos()));

                    if (city == null)
                    {
                        isEnemyGround = true;
                    }
                    else
                    {
                        int cityId = city.get_force_id();
                        if (cityId != forceId && true == pk::is_enemy(force, city))
                        {
                            isEnemyGround = true;
                        }
                    }

                    if (true == isEnemyGround)
                    {
                        pk::add_energy(arr[i], 병주_지역이점_기력상승, true);
                    }
                }
            }
        }
        
        void ExecuteBingZhouMove(pk::force@ force, int& mov)
        {
            if (false == IsEnableZhou(force, 병주))
            {
                return;
            }

            mov += 병주_지역이점_이동증가;
        }

        // 기주 지역이점. 충성도 증가
        void ExecuteJiZhouLoyalty()
        {
            auto forces = pk::get_force_list();

            for (int i = 0; i < forces.count; ++i)
            {
                pk::force@ force = forces[i];

                if (true == IsValidForce(force))
                {
                    if (false == IsEnableZhou(force, 기주))
                    {
                        continue;
                    }

                    auto list = pk::get_person_list(force, pk::mibun_flags(신분_도독, 신분_태수, 신분_일반));

                    if (0 == list.count)
                    {
                        continue;
                    }

                    array<pk::person@> officers = pk::list_to_array(list);

                    for (int i = 0; i < officers.length; ++i)
                    {
                        if (true == IsValidPerson(officers[i]))
                        {
                            if (int(officers[i].loyalty) < 기주_지역이점_최대누적충성)
                            {
                                pk::add_loyalty(officers[i], 기주_지역이점_충성상승);
                            }
                        }
                    }
                }
            }
        }

        // 기주 지역이점.  봉록 절약
        void ExecuteJiZhouSalary(pk::force@ force)
        {
            if (false == IsEnableZhou(force, 기주))
            {
                return;
            }
            
            auto cities = pk::get_city_list(force);
            
            for (int i = 0; i < cities.count; ++i)
            {
                pk::building@ city = pk::get_building(cities[i].get_pos());
                auto list = pk::get_person_list(city, pk::mibun_flags(신분_도독, 신분_태수, 신분_일반));
                
                if (0 == list.count)
                {
                    continue;
                }

                array<pk::person@> officers = pk::list_to_array(list);
                int savingGold = 0;
            
                for (int j = 0; j < officers.length; ++j)
                {
                    pk::person@ p = officers[j];
            
                    if (true == IsValidPerson(p))
                    {
                        // 무장의 기본급여
                        int pay = 5;
            
                        // 관직이 있는 경우 관직의 급여 추가
                        if (p.rank != -1)
                        {
                            pk::rank@ rank = pk::get_rank(p.rank);
                            pay += rank.pay;
                        }
            
                        // 급여의 40%를 도시에 더 해준다.
                        savingGold += (pay * 기주_지역이점_녹봉할인) / 100;
                    }
                }
            
                pk::add_gold(cities[i], savingGold, false);
            }
        }
        
        // 청주 지역이점. 내정시설 내구도 상승
        void ExecuteQingZhouFacility(pk::force@ force)
        {
            if (false == IsEnableZhou(force, 청주))
            {
                return;
            }

            auto cities = pk::get_city_list(force);
            
            for (int i = 0; i < cities.count; ++i)
            {
                pk::city@ city = cities[i];
            
                for (int j = 0; j < city.max_devs; ++j)
                {
                    pk::building@ building = city.dev[j].building;
            
                    if (true == IsValidBuilding(building))
                    {
                        int max_hp = pk::get_facility(building.facility).hp;

                        int value = (max_hp * 청주_지역이점_시설상승) / 100;

                        if (!building.completed)
                        {
                            if (building.hp + value >= max_hp)
                            {
                                value = max_hp - building.hp - 1;
                            }
                        }
                        else
                        {
                            if (building.hp + value >= max_hp)
                            {
                                value = max_hp - building.hp;
                            }
                        }

                        pk::add_hp(building, value, true);
                    }
                }
            }

        }
        // 청주 지역이점. 치안 창승
        void ExecuteQingZhouPublicOrder()
        {
            auto forces = pk::get_force_list();

            for (int i = 0; i < forces.count; ++i)
            {
                pk::force@ force = forces[i];

                if (true == IsValidForce(force))
                {
                    if (false == IsEnableZhou(force, 청주))
                    {
                        continue;
                    }

                    auto cities = pk::get_city_list(force);
                    
                    for (int j = 0; j < cities.count; ++j)
                    {
                        pk::add_public_order(cities[j], 청주_지역이점_치안상승, true);
                    }
                }
            }
        }

        // 연주 지역이점. 창,극,노 생산량 증가
        void ExecuteYanZhou(pk::force@ force, int& value)
        {
            if (true == IsEnableZhou(force, 연주))
            {
                value = (value * (100 + 연주_지역이점_생산증가)) / 100;
            }
        }

        // 회남 지역이점, 계략 소모 기력 감소
        void ExecuteHuaiNan(pk::force@ force, int& energe)
        {
            if (true == IsEnableZhou(force, 회남))
            {
                energe = (energe * (100 - 회남_지역이점_기력경감)) / 100;
            }
        }

        // 서주 지역이점. 거점 공격력 증가
        void ExecuteXuZhouDamage(pk::force@ force, pk::damage_info& info)
        {
            if (true == IsEnableZhou(force, 서주))
            {
                info.troops_damage = (info.troops_damage * (100 + 서주_지역이점_거점공격)) / 100;
            }
        }

        // 서주 지역이점. 거점 hp 회복
        void ExecuteXuZhouHp(pk::force@ force)
        {
            if (false == IsEnableZhou(force, 서주))
            {
                return;
            }

            if (true == IsValidForce(force))
            {
                int forceId = force.get_force_id();

                auto cities = pk::get_city_list(force);

                // 도시 체력회복
                for (int i = 0; i < cities.count; ++i)
                {
                    int maxHp = cities[i].get_max_hp();
                    int value = (maxHp * 서주_지역이점_내구회복) / 100;

                    pk::add_hp(cities[i], value, true);
                }

                for (int i = 건물_관문시작; i < 건물_항구끝; ++i)
                {
                    pk::building@ building = pk::get_building(i);

                    if (true == IsValidBuilding(building) && forceId == building.get_force_id())
                    {
                        int maxHp = pk::get_max_hp(building);
                        int value = (maxHp * 서주_지역이점_내구회복) / 200;

                        pk::add_hp(building, value, true);
                    }
                }
            }
        }

        // 예주 지역이점. 이동, 소환, 귀환의 행동일수 경감
        void ExecuteYuZhou(pk::force@ force)
        {
            if (false == IsEnableZhou(force, 예주))
            {
                return;
            }

            // 세력의 무장 배열
            array<pk::person@> mooArray = pk::list_to_array(pk::get_person_list(force, pk::mibun_flags(신분_군주, 신분_도독, 신분_태수, 신분_일반)));

            for (int i = 0; i < mooArray.length; ++i)
            {
                if (mooArray[i].order == 무장임무_이동 || mooArray[i].order == 무장임무_소환)
                {
                    if (mooArray[i].absence_timer <= ((예주_지역이점_이동소환경감) / 10 + 1))
                    {
                        mooArray[i].location = mooArray[i].target[0];
                    }
                }

                if (mooArray[i].order == 무장임무_귀환)
                {
                    if (mooArray[i].absence_timer <= ((예주_지역이점_귀환경감) / 10 + 1))
                    {
                        mooArray[i].location = mooArray[i].service;
                    }
                }
            }
        }

        // 형북 지역이점. 재야무장, 포로무장 등용확률 증가
        void ExecuteJingBeiMoo(pk::force@ force, int& n)
        {
            if (false == IsEnableZhou(force, 형북))
            {
                return;
            }

            // 등용확률이 0%가 아니면 20% 상승
            if (n > 0)
            {
                n = n + 형북_지역이점_등용상승;
            }
        }

        // 형북 지역이점. 매달 기교 상승
        void ExecuteJingBeiTech()
        {
            auto forces = pk::get_force_list();

            for (int i = 0; i < forces.count; ++i)
            {
                pk::force@ force = forces[i];

                if (true == IsValidForce(force))
                {
                    if (false == IsEnableZhou(force, 형북))
                    {
                        continue;
                    }

                    pk::point pos = pk::get_city(도시_양양).get_pos();
                    pk::add_tp(force, 형북_지역이점_기교획득 * 2, pos);
                }
            }
        }

        // 교역을 업데이트 하는 함수
        void UpdateRelation(pk::force@ force)
        {
            // 이민족 교류 업데이트
            UpdateRapprochmentDay(force);

            // 세력이 교역중인이면 날짜 업데이트
            if (true == IsTrading(force))
            {
                UpdateTradeDay(force);
            }
            else
            {
                return;
            }

            // 교역일수가 모두 소진되었을 경우 우호도 상승
            if (0 == GetTradeDay(force))
            {
                AddRelationValue(force, GetTradeForce(force), 1);
                ResetTrade(force);
            }
        }
        
        // 이민족의 우호도 하락 업데이트. 매달 업데이트
        void UpdateBarbarianRelation()
        {
            auto forces = pk::get_force_list();
            array<pk::force@> forceArray = pk::list_to_array(forces);

            for (int i = 0; i < forceArray.length; ++i)
            {
                pk::force@ force = forceArray[i];
                int forceId = force.get_force_id();

                if (false == IsValidForce(force))
                {
                    return;
                }

                // 오환과 우호도가 존재할 시
                if (0 < GetRelationLevel(force, 우호_오환))
                {
                    // 지역이점 유효 체크
                    if (false == IsEnableZhou(force, 유주))
                    {
                        AddRelationValue(force, 우호_오환, -1);
                    }
                    else
                    {
                        // 유주 도시의 치안 체크 70 밑이면 하락
                        for (int j = 0; j < 유주_도시.length; ++j)
                        {
                            if (forceId == 유주_도시[j])
                            {
                                pk::city@ city = pk::get_city(유주_도시[j]);
                                if (city.public_order < 70)
                                {
                                    AddRelationValue(force, 우호_오환, -1);
                                    break;
                                }
                            }
                        }
                    }
                }

                // 강과 우호도가 존재할 시
                if (0 < GetRelationLevel(force, 우호_강))
                {
                    // 지역이점 유효 체크
                    if (false == IsEnableZhou(force, 량주))
                    {
                        AddRelationValue(force, 우호_강, -1);
                    }
                    else
                    {
                        // 량주 도시의 치안 체크 70 밑이면 하락
                        for (int j = 0; j < 량주_도시.length; ++j)
                        {
                            if (forceId == 량주_도시[j])
                            {
                                pk::city@ city = pk::get_city(량주_도시[j]);
                                if (city.public_order < 70)
                                {
                                    AddRelationValue(force, 우호_강, -1);
                                    break;
                                }
                            }
                        }
                    }
                }

                // 남만과 우호도가 존재할 시
                if (0 < GetRelationLevel(force, 우호_남만))
                {
                    // 지역이점 유효 체크
                    if (false == IsEnableZhou(force, 남중))
                    {
                        AddRelationValue(force, 우호_남만, -1);
                    }
                    else
                    {
                        // 남중 도시의 치안 체크 70 밑이면 하락
                        for (int j = 0; j < 남중_도시.length; ++j)
                        {
                            if (forceId == 남중_도시[j])
                            {
                                pk::city@ city = pk::get_city(남중_도시[j]);
                                if (city.public_order < 70)
                                {
                                    AddRelationValue(force, 우호_남만, -1);
                                    break;
                                }
                            }
                        }
                    }
                }

                // 산월과 우호도가 존재할 시
                if (0 < GetRelationLevel(force, 우호_산월))
                {
                    // 지역이점 유효 체크
                    if (false == IsEnableZhou(force, 양주))
                    {
                        AddRelationValue(force, 우호_산월, -1);
                    }
                    else
                    {
                        // 남중 도시의 치안 체크 70 밑이면 하락
                        for (int j = 0; j < 양주_도시.length; ++j)
                        {
                            if (forceId == 양주_도시[j])
                            {
                                pk::city@ city = pk::get_city(양주_도시[j]);
                                if (city.public_order < 70)
                                {
                                    AddRelationValue(force, 우호_산월, -1);
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }

        // ======================================================== 지역 이점 끝 ===========================================================


        // 각 세력의 db배열 생성하는 함수
        void ArrayInit()
        {
            for (int i = 0; i < 도시_끝; ++i)
            {
                dataArray[i] = { 0, 0, 0 };
            }

            for (int i = 0; i < 4; ++i)
            {
                barbarianDataArray[i] = 0;
            }

            for (int i = 0; i < 2; ++i)
            {
                competitionDataArray[i] = -1;
            }

            for (int i = 0; i < 도시_끝; ++i)
            {
                singleCompetitionDataArray[i] = -1;
            }

            for (int i = 0; i < 500; ++i)
            {
                woundedUnitArray[i] = 0;
            }

            for (int i = 0; i < 건물_항구끝; ++i)
            {
                woundedBuildingArray[i] = 0;
            }

            for (int i = 0; i < 신무장_끝; ++i)
            {
                competitionCountArray[i] = 0;
            }

            for (int i = 0; i < 3; ++i)
            {
                titleArray[i] = -1;
            }

            for (int i = 0; i < 도시_끝; ++i)
            {
                uniqueTechArray[i] = 0;
                uniqueTechCount[i] = 0;
                ai_prefer_uniqueTech_data[i] = 0;
            }

            for (int i = 0; i < 도시_끝; ++i)
            {
                ai_prefer_uniqueTech_data[i] = pk::rand(100);
            }
        }

        void validForceTrigger()
        {
            validForceUpdate(false);
        }

        // 유효한 세력을 배열에 업데이트 하는 함수
        void validForceUpdate(bool isFirst = false)
        {
            if (isFirst)
            {
                for (int i = 0; i < 도시_끝; ++i)
                {
                    pk::force@ force = pk::get_force(i);

                    if (force.is_alive())
                    {
                        if (pk::is_normal_force(force))
                        {
                            forceRegionBuff[i] = 0;
                            //CreateData(i);
                            continue;
                        }
                    }

                    forceRegionBuff[i] = -1;
                }
            }
            else
            {
                for (int i = 0; i < 도시_끝; ++i)
                {
                    pk::force@ force = pk::get_force(i);

                    // 세력이 새로 생겼는지 체크 후 업데이트
                    if (pk::get_force(i).is_alive() && forceRegionBuff[i] == -1)
                    {
                        forceRegionBuff[i] = 0;
                        CreateData(i);
                    }

                    // 세력이 멸망했는지 체크 후 업데이트
                    if (!pk::get_force(i).is_alive() && forceRegionBuff[i] != -1)
                    {
                        forceRegionBuff[i] = -1;
                        DeleteData(i);
                    }
                }
            }
        }

        // 세력과 이민족 우호 체크 후 동맹이 제대로 안되있을 경우 동맹 맺는 함수 (사용안함)
        void InitBarbarianAlly()
        {
            auto forces = pk::get_force_list();
            array<pk::force@> forceArray = pk::list_to_array(forces);

            for (int i = 0; i < forceArray.length; ++i)
            {
                pk::force@ force = forceArray[i];

                if (true == force.is_alive())
                {
                    if (GetRelationLevel(force, 우호_오환) > 0)
                    {
                        if (false == force.ally[세력_오환])
                        {
                            pk::set_ceasefire_timer(force, 세력_오환, 7200);
                            pk::set_ally(force, 세력_오환, true);
                        }
                    }

                    if (GetRelationLevel(force, 우호_강) > 0)
                    {
                        if (false == force.ally[세력_강])
                        {
                            pk::set_ceasefire_timer(force, 세력_강, 7200);
                            pk::set_ally(force, 세력_강, true);
                        }
                    }

                    if (GetRelationLevel(force, 우호_남만) > 0)
                    {
                        if (false == force.ally[세력_남만])
                        {
                            pk::set_ceasefire_timer(force, 세력_남만, 7200);
                            pk::set_ally(force, 세력_남만, true);
                        }
                    }

                    if (GetRelationLevel(force, 우호_산월) > 0)
                    {
                        if (false == force.ally[세력_산월])
                        {
                            pk::set_ceasefire_timer(force, 세력_산월, 7200);
                            pk::set_ally(force, 세력_산월, true);
                        }
                    }
                }
            }
        }

        // 한황실의 대회 우승자 데이터 생성
        void CompetitionDataSetting()
        {
            for (int j = 0; j < 2; ++j)
            {
                if (j == 0)
                {
                    competitionDataArray[j] = 무술대회_초기우승자;
                }
                else if (j == 1)
                {
                    competitionDataArray[j] = 설전대회_초기우승자;
                }
            }
        }

        // 세력별 자체대회 우승자 데이터 관리
        void SingleCompetitionDataSetting()
        {
            for (int j = 0; j < 도시_끝; ++j)
            {
                pk::force@ force = pk::get_force(j);

                if (true == force.is_alive())
                {
                    singleCompetitionDataArray[j] = -1;
                }
            }
        }

        // 각 세력의 dataBase를 구축하는 함수. 지역이점 패치 후 최초에 한번 실행하고 그 다음부터는 새로운 세력이 생겼을때만(거병) 실행될 예정
        void CreateData(int forceId)
        {
            for (int i = 0; i < 3; ++i)
            {
                dataArray[forceId][i] = 0;
                uniqueTechArray[forceId] = 0;
                uniqueTechCount[forceId] = 0;
            }

            if (1 == 자세력_대회_개최여부)
            {
                singleCompetitionDataArray[forceId] = -1;
            }
        }

        // 각 세력의 db를 제거하는 함수. 기존의 세력이 멸망한것을 체크한 후에 실행할 예정
        void DeleteData(int forceId)
        {
            for (int i = 0; i < 3; ++i)
            {
                dataArray[forceId][i] = 0;
                uniqueTechArray[forceId] = 0;
                uniqueTechCount[forceId] = 0;
            }

            if (1 == 자세력_대회_개최여부)
            {
                singleCompetitionDataArray[forceId] = -1;
            }
        }
        
        bool IsEnableZhou(pk::force@ force, int zhouId)
        {
            if (지역이점_사용여부 == 0)
                return false;

            switch (zhouId)
            {
            case 유주:
                return IsYouZhou(force);
            case 병주:
                return IsBingZhou(force);
            case 기주:
                return IsJiZhou(force);
            case 청주:
                return IsQingZhou(force);
            case 서주:
                return IsXuZhou(force);
            case 회남:
                return IsHuaiNan(force);
            case 연주:
                return IsYanZhou(force);
            case 예주:
                return IsYuZhou(force);
            case 사예:
                return IsSiLi(force);
            case 경조:
                return IsJingZhao(force);
            case 량주:
                return IsLiangZhou(force);
            case 양주:
                return IsYangZhou(force);
            case 형북:
                return IsJingBei(force);
            case 형남:
                return IsJingNan(force);
            case 익주:
                return IsYiZhou(force);
            case 남중:
                return IsNanZhong(force);
            }

            return false;
        }

        // 유주지역 체크
        bool IsYouZhou(pk::force@ force)
        {
            return IsRequiredTotalCity(false, force, 유주_도시);
        }

        // 병주지역 체크
        bool IsBingZhou(pk::force@ force)
        {
            return IsRequiredTotalCity(true, force, 병주_도시);
        }

        // 기주지역 체크
        bool IsJiZhou(pk::force@ force)
        {
            return IsRequiredTotalCity(true, force, 기주_도시);
        }

        // 청주지역 체크
        bool IsQingZhou(pk::force@ force)
        {
            return IsRequiredTotalCity(true, force, 청주_도시);
        }

        // 서주지역 체크
        bool IsXuZhou(pk::force@ force)
        {
            return IsRequiredTotalCity(true, force, 서주_도시);
        }

        // 회남지역 체크
        bool IsHuaiNan(pk::force@ force)
        {
            return IsRequiredTotalCity(true, force, 회남_도시);
        }

        // 연주지역 체크
        bool IsYanZhou(pk::force@ force)
        {
            return IsRequiredTotalCity(true, force, 연주_도시);
        }

        // 예주지역 체크
        bool IsYuZhou(pk::force@ force)
        {
            return IsRequiredTotalCity(true, force, 예주_도시);
        }

        // 사예지역 체크
        bool IsSiLi(pk::force@ force)
        {
            return IsRequiredTotalCity(true, force, 사예_도시);
        }

        // 경조지역 체크
        bool IsJingZhao(pk::force@ force)
        {
            return IsRequiredTotalCity(false, force, 경조_도시);
        }

        // 량주지역 체크
        bool IsLiangZhou(pk::force@ force)
        {
            return IsRequiredTotalCity(false, force, 량주_도시);
        }

        // 양주지역 체크
        bool IsYangZhou(pk::force@ force)
        {
            return IsRequiredTotalCity(false, force, 양주_도시);
        }

        // 형북지역 체크
        bool IsJingBei(pk::force@ force)
        {
            return IsRequiredTotalCity(false, force, 형북_도시);
        }

        // 형남지역 체크
        bool IsJingNan(pk::force@ force)
        {
            return IsRequiredTotalCity(false, force, 형남_도시);
        }

        // 익주지역 체크
        bool IsYiZhou(pk::force@ force)
        {
            return IsRequiredTotalCity(false, force, 익주_도시);
        }

        // 남중지역 체크
        bool IsNanZhong(pk::force@ force)
        {
            return IsRequiredTotalCity(true, force, 남중_도시);
        }
        
        bool IsRegionBuffChange(pk::force@ force, int city, bool cityLose)
        {
            int zhouId = GetZhouId(city);
            array<int> zhouCities = GetZhoudCityArray(zhouId);
            int count = zhouCities.length;
            // 도시를 잃었고 해당 주의 지역이점을 가지고 있었을 경우
            if (true == cityLose && true == IsEnableZhou(force, zhouId))
            {
                // 주의 도시가 하나거나 두개인 경우는 무조건 true
                if (zhouCities.length == 1 || zhouCities.length == 2)
                {
                    return true;
                }
                
                // 주의 도시가 3개 이상인 경우
                
                // 뺏긴 도시가 주도인 경우는 무조건 상실
                if (zhouCities[0] == city)
                {
                    return true;
                }
                // 해당 도시가 주도가 아닌경우
                else
                {
                    if (GetCityCountAtZhou(force, zhouId) - 1 <= (count / 2))
                    {
                        return true;
                    }
                }
            }
            // 도시를 얻었지만 해당 주의 지역이점이 없었던 경우 
            if(false == cityLose && false == IsEnableZhou(force, zhouId))
            {
                // 주의 도시가 하나인 경우 무조건 획득
                if (zhouCities.length == 1)
                {
                    return true;
                }
                else
                {
                    // 과반수 체크
                    if (GetCityCountAtZhou(force, zhouId) >= (count / 2))
                    {
                        if (zhouCities.length == 2)
                        {
                            return true;
                        }
                        
                        // 도시가 3개 이상이면서
                        // 주도를 소유했었던 경우
                        if (pk::get_city(zhouCities[0]).get_force_id() == force.get_force_id())
                        {
                            return true;
                        }
                        else //주도가 없었던경우 
                        {
                            // 해당 도시가 주도라면 true
                            if (zhouCities[0] == city)
                            {
                                return true;
                            }
                        }
                    }
                }
            }

            return false;
        }

        // 외국 우호도 체크 
        bool IsRelationship(pk::force@ force, int level, int type)
        {
            if (false == IsValidForce(force))
            {
                return false;
            }

            bool enabled;
            int temp;
            ConvertRelationData(force, type, level, enabled, temp);

            return enabled;
        }

        // 지역이점 체크 함수
        bool IsRequiredTotalCity(bool isRequired, pk::force@ force, array<int> zhouCities)
        {     
            if (false == IsValidForce(force))
            {
                return false;
            }

            int totalCity = zhouCities.length;
            int count;

            if (true == isRequired)
            {
                count = 0;

                // 해당 주의 지배도시마다 카운팅
                for (int i = 0; i < totalCity; ++i)
                {
                    if (pk::get_building(zhouCities[i]).get_force_id() == force.get_id())
                    {
                        count++;
                    }
                }

                // 모든 주의 도시를 지배하면 이점 발동
                if (count >= totalCity)
                {
                    return true;
                }

                return false;
            }
            else
            {
                
                pk::building@ zhouDou = pk::get_building(zhouCities[0]);

                // 세력이 주도를 지배하지 않으면 무효
                if (zhouDou.get_force_id() != force.get_id())
                {
                    return false;
                }

                count = 1;

                // 해당 주의 지배도시마다 카운팅
                for (int i = 1; i < totalCity; ++i)
                {
                    if (pk::get_building(zhouCities[i]).get_force_id() == force.get_id())
                    {
                        count++;
                    }
                }

                // 주도를 포함한 상태로 주의 반을 초과하여 지배하면 이점 발동
                if (count > totalCity / 2)
                {
                    return true;
                }

                return false;
            }
        }

        // 우호관계 데이터 받아오기
        void ConvertRelationData(pk::force@ force, int type, int level, bool& enabled, int& currMaxLevel)
        {
            if (!loadSuccess)
                return;

            enabled = false;
            currMaxLevel = 0;

            int forceId = force.get_force_id();

            int dataIndex = -1;
            int digit = -1;

            switch (type)
            {
            case 우호_대진국:
                dataIndex = 0;
                digit = 0;
                break;

            case 우호_안식국:
                dataIndex = 0;
                digit = 1;
                break;

            case 우호_천축국:
                dataIndex = 0;
                digit = 2;
                break;

            case 우호_귀상국:
                dataIndex = 0;
                digit = 3;
                break;

            case 우호_오환:
                dataIndex = 0;
                digit = 4;
                break;

            //case 우호_선비:
            //    return;

            case 우호_강:
                dataIndex = 0;
                digit = 6;
                break;

            case 우호_남만:
                dataIndex = 1;
                digit = 5;
                break;

            case 우호_산월:
                dataIndex = 1;
                digit = 6;
                break;

            default:
                return;
            }

            //pk::building@ data = pk::get_building(dataArray[forceId][dataIndex]);
            //
            //if (null == data)
            //{
            //    return;
            //}

            int hp = dataArray[forceId][dataIndex];

            if (-1 == hp)
            {
                return;
            }

            currMaxLevel = ConvertHpToValue(hp, digit);

            if (currMaxLevel >= level)
            {
                enabled = true;
            }
        }


        // 우호단계를 변경하는 함수.  value는 1로 통일해서 사용할것. 오류날 가능성이 높음
        void AddRelationValue(pk::force@ force, int type, int value)
        {
            int forceId = force.get_force_id();
            int dataIndex = -1;
            int digit = -1;
            switch (type)
            {
            case 우호_대진국:
                dataIndex = 0;
                digit = 0;
                break;

            case 우호_안식국:
                dataIndex = 0;
                digit = 1;
                break;

            case 우호_천축국:
                dataIndex = 0;
                digit = 2;
                break;

            case 우호_귀상국:
                dataIndex = 0;
                digit = 3;
                break;

            case 우호_오환:
                dataIndex = 0;
                digit = 4;
                break;

            //case 우호_선비:
            //    dataIndex = 0;
            //    digit = 5;
            //    break;

            case 우호_강:
                dataIndex = 0;
                digit = 6;
                break;

            case 우호_남만:
                dataIndex = 1;
                digit = 5;
                break;

            case 우호_산월:
                dataIndex = 1;
                digit = 6;
                break;

            default:
                return;
            }

            //pk::building@ data = pk::get_building(dataPointArray[forceId][dataIndex]);
            int level = ConvertHpToValue(dataArray[forceId][dataIndex], digit);
            if (ConvertHpToValue(dataArray[forceId][dataIndex], digit) >= 3 && value >= 1)
            {
                return;
            }

            if (ConvertHpToValue(dataArray[forceId][dataIndex], digit) <= 0 && value <= -1)
            {
                return;
            }

            switch (type)
            {
            case 우호_대진국:
                RomanUpgradeEvent(force, level);
                break;
            
            case 우호_안식국:
                ParthianUpgradeEvent(force, level);
                break;
            
            case 우호_천축국:
                IndiaUpgradeEvent(force, level);
                break;
            
            case 우호_귀상국:
                KushanUpgradeEvent(force, level);
                break;
            
            case 우호_오환:
                if (value > 0)
                {
                    RapprochmentUpgradeEvent(force, type, level);
                }
                else if (value < 0)
                {
                    RelationDownGradeEvent(force, type, level);
                }
                break;
            case 우호_강:
                if (value > 0)
                {
                    RapprochmentUpgradeEvent(force, type, level);
                }
                else
                {
                    RelationDownGradeEvent(force, type, level);
                }
                break;
            case 우호_남만:
                if (value > 0)
                {
                    RapprochmentUpgradeEvent(force, type, level);
                }
                else
                {
                    RelationDownGradeEvent(force, type, level);
                }
                break;
            case 우호_산월:
                if (value > 0)
                {
                    RapprochmentUpgradeEvent(force, type, level);
                }
                else
                {
                    RelationDownGradeEvent(force, type, level);
                }
                break;
            
            default:
                return;
            }

            int Hp = ConvertValueToHp(value, digit);
            //data.hp = data.hp + Hp;

            dataArray[forceId][dataIndex] += Hp;
        }

        // 해당 세력과의 우호도 받아오기
        int GetRelationLevel(pk::force@ force, int type)
        {
            if (false == IsValidForce(force))
            {
                return -1;
            }

            bool enabled;
            int currLevel = 0;

            ConvertRelationData(force, type, -1, enabled, currLevel);
            return currLevel;
        }

        // 지역이점 현황 불러오기, 대회 우승자 출력
        void PrintRegionBuffInfo()
        {
            pk::list<pk::force@> forces = pk::get_force_list();

            for (int i = 0; i < forces.count; ++i)
            {
                if (true == IsValidForce(forces[i]))
                {
                    pk::force@ force = forces[i];
                    string s;
                    int count = 0;

                    if (forces[i].kokugou != -1)
                    {
                        if (forces[i].is_player())
                        {
                            s = pk::format("\x1b[1x{}\x1b[0x의 지역이점 : ", pk::u8decode(pk::get_kokugou(forces[i].kokugou).get_name()));
                        }
                        else
                        {
                            s = pk::format("{}의 지역이점 : ", pk::u8decode(pk::get_kokugou(forces[i].kokugou).get_name()));
                        }
                    }
                    else
                    {
                        if (forces[i].is_player())
                        {
                            s = pk::format("\x1b[1x{}\x1b[0x군의 지역이점 : ", pk::u8decode(pk::get_name(pk::get_person(forces[i].kunshu))));
                        }
                        else
                        {
                            s = pk::format("{}군의 지역이점 : ", pk::u8decode(pk::get_name(pk::get_person(forces[i].kunshu))));
                        }
                    }

                    if (IsEnableZhou(force, 유주))
                    {
                        s = s + "유주";

                        count += 1;
                    }

                    if (IsEnableZhou(force, 병주))
                    {
                        if (count != 0)
                        {
                            s = s + ", ";
                        }

                        s = s + "병주";

                        count += 1;
                    }

                    if (IsEnableZhou(force, 기주))
                    {
                        if (count != 0)
                        {
                            s = s + ", ";
                        }

                        s = s + "기주";
                        count += 1;
                    }

                    if (IsEnableZhou(force, 청주))
                    {
                        if (count != 0)
                        {
                            s = s + ", ";
                        }

                        s = s + "청주";
                        count += 1;
                    }

                    if (IsEnableZhou(force, 서주))
                    {
                        if (count != 0)
                        {
                            s = s + ", ";
                        }

                        s = s + "서주";
                        count += 1;
                    }

                    if (IsEnableZhou(force, 회남))
                    {
                        if (count != 0)
                        {
                            s = s + ", ";
                        }

                        s = s + "회남";
                        count += 1;
                    }

                    if (IsEnableZhou(force, 연주))
                    {
                        if (count != 0)
                        {
                            s = s + ", ";
                        }

                        s = s + "연주";
                        count += 1;
                    }

                    if (IsEnableZhou(force, 예주))
                    {
                        if (count != 0)
                        {
                            s = s + ", ";
                        }

                        s = s + "예주";
                        count += 1;
                    }

                    if (IsEnableZhou(force, 사예))
                    {
                        if (count != 0)
                        {
                            s = s + ", ";
                        }

                        s = s + "사예";
                        count += 1;
                    }

                    if (IsEnableZhou(force, 경조))
                    {
                        if (count != 0)
                        {
                            s = s + ", ";
                        }

                        s = s + "경조";
                        count += 1;
                    }

                    if (IsEnableZhou(force, 량주))
                    {
                        if (count != 0)
                        {
                            s = s + ", ";
                        }

                        s = s + "량주";
                        count += 1;
                    }

                    if (IsEnableZhou(force, 양주))
                    {
                        if (count != 0)
                        {
                            s = s + ", ";
                        }

                        s = s + "양주";
                        count += 1;
                    }

                    if (IsEnableZhou(force, 형북))
                    {
                        if (count != 0)
                        {
                            s = s + ", ";
                        }

                        s = s + "형북";
                        count += 1;
                    }

                    if (IsEnableZhou(force, 형남))
                    {
                        if (count != 0)
                        {
                            s = s + ", ";
                        }

                        s = s + "형남";

                        count += 1;
                    }

                    if (IsEnableZhou(force, 익주))
                    {
                        if (count != 0)
                        {
                            s = s + ", ";
                        }

                        s = s + "익주";

                        count += 1;
                    }

                    if (IsEnableZhou(force, 남중))
                    {
                        if (count != 0)
                        {
                            s = s + ", ";
                        }

                        s = s + "남중";
                    }

                    pk::history_log(pk::get_person(force.kunshu).get_pos(), forces[i].color, pk::u8encode(s));

                    count = 0;
                    s = "";
                    if (forces[i].kokugou != -1)
                    {
                        if (forces[i].is_player())
                        {
                            s = pk::format("\x1b[1x{}\x1b[0x의 우호도 : ", pk::u8decode(pk::get_kokugou(forces[i].kokugou).get_name()));
                        }
                        else
                        {
                            s = pk::format("{}의 우호도 : ", pk::u8decode(pk::get_kokugou(forces[i].kokugou).get_name()));
                        }
                    }
                    else
                    {
                        if (forces[i].is_player())
                        {
                            s = pk::format("\x1b[1x{}\x1b[0x군의 우호도 : ", pk::u8decode(pk::get_name(pk::get_person(forces[i].kunshu))));
                        }
                        else
                        {
                            s = pk::format("{}군의 우호도 : ", pk::u8decode(pk::get_name(pk::get_person(forces[i].kunshu))));
                        }
                    }

                    if (GetRelationLevel(force, 우호_대진국) > 0)
                    {
                        s = s + pk::format("대진국({})", GetRelationLevel(force, 우호_대진국));

                        count += 1;
                    }

                    if (GetRelationLevel(force, 우호_안식국) > 0)
                    {
                        if (count != 0)
                        {
                            s = s + ", ";
                        }

                        s = s + pk::format("안식국({})", GetRelationLevel(force, 우호_안식국));

                        count += 1;
                    }

                    if (GetRelationLevel(force, 우호_천축국) > 0)
                    {
                        if (count != 0)
                        {
                            s = s + ", ";
                        }

                        s = s + pk::format("천축국({})", GetRelationLevel(force, 우호_천축국));

                        count += 1;
                    }

                    if (GetRelationLevel(force, 우호_귀상국) > 0)
                    {
                        if (count != 0)
                        {
                            s = s + ", ";
                        }

                        s = s + pk::format("귀상국({})", GetRelationLevel(force, 우호_귀상국));

                        count += 1;
                    }

                    if (GetRelationLevel(force, 우호_오환) > 0)
                    {
                        if (count != 0)
                        {
                            s = s + ", ";
                        }

                        s = s + pk::format("오환({})", GetRelationLevel(force, 우호_오환));

                        count += 1;
                    }

                    if (GetRelationLevel(force, 우호_강) > 0)
                    {
                        if (count != 0)
                        {
                            s = s + ", ";
                        }

                        s = s + pk::format("강({})", GetRelationLevel(force, 우호_강));

                        count += 1;
                    }

                    if (GetRelationLevel(force, 우호_남만) > 0)
                    {
                        if (count != 0)
                        {
                            s = s + ", ";
                        }

                        s = s + pk::format("남만({})", GetRelationLevel(force, 우호_남만));

                        count += 1;
                    }

                    if (GetRelationLevel(force, 우호_산월) > 0)
                    {
                        if (count != 0)
                        {
                            s = s + ", ";
                        }

                        s = s + pk::format("산월({})", GetRelationLevel(force, 우호_산월));

                        count += 1;
                    }

                    if (count > 0)
                    {
                        pk::history_log(pk::get_person(force.kunshu).get_pos(), forces[i].color, pk::u8encode(s));
                    }

                    if (GetSingleCompetitionWinnerId(force.get_force_id()) != -1)
                    {
                        pk::person@ p = pk::get_person(GetSingleCompetitionWinnerId(force.get_force_id()));

                        if (p != null && true == p.is_alive() && force.get_force_id() == p.get_force_id())
                        {
                            pk::history_log(p.get_pos(), force.color, pk::u8encode(pk::format("세력대회 우승 : \x1b[2x{}\x1b[0x", pk::u8decode(pk::get_name(p)))));
                        }
                    }

                    if (고유기교_사용여부 == 1)
                    {
                        if (GetUniqueTechData(force.get_force_id()) > 0)
                        {
                            string s = "고유기교 : ";
                            int unique_tech_data = GetUniqueTechData(force.get_force_id());
                            int count = 0;
                            if (unique_tech_data / 1000000 > 0)
                            {
                                s = s + 고유기교_이름[unique_tech_data / 1000000];
                                count++;
                            }
                            if ((unique_tech_data / 10000) % 100 > 0)
                            {
                                if (count > 0)
                                {
                                    s = s + ", ";
                                }
                                s = s + 고유기교_이름[(unique_tech_data / 10000) % 100];
                                count++;
                            }
                            if ((unique_tech_data / 100) % 100 > 0)
                            {
                                if (count > 0)
                                {
                                    s = s + ", ";
                                }
                                s = s + 고유기교_이름[(unique_tech_data / 100) % 100];
                                count++;
                            }
                            if (unique_tech_data % 100 > 0)
                            {
                                if (count > 0)
                                {
                                    s = s + ", ";
                                }
                                s = s + 고유기교_이름[unique_tech_data % 100];
                            }

                            pk::history_log(pk::get_person(force.kunshu).get_pos(), force.color, pk::u8encode(s));
                        }
                    }
                }
            }

            if (!IsEmptyTitle(0))
            {
                pk::person@ p = pk::get_person(titleArray[0]);
                if (p != null && true == p.is_alive())
                {
                    pk::history_log(p.get_pos(), p.get_force_id(), pk::u8encode(pk::format("\x1b[1x천하무쌍\x1b[0x : \x1b[2x{}\x1b[0x", pk::u8decode(pk::get_name(p)))));
                }
            }

            if (!IsEmptyTitle(1))
            {
                pk::person@ p = pk::get_person(titleArray[1]);
                if (p != null && true == p.is_alive())
                {
                    pk::history_log(p.get_pos(), p.get_force_id(), pk::u8encode(pk::format("\x1b[1x천하기재\x1b[0x : \x1b[2x{}\x1b[0x", pk::u8decode(pk::get_name(p)))));
                }
            }

            if (!IsEmptyTitle(2))
            {
                pk::person@ p = pk::get_person(titleArray[2]);
                if (p != null && true == p.is_alive())
                {
                    pk::history_log(p.get_pos(), p.get_force_id(), pk::u8encode(pk::format("\x1b[1x국사무쌍\x1b[0x : \x1b[2x{}\x1b[0x", pk::u8decode(pk::get_name(p)))));
                }
            }

            if (GetCompetitionWinnerId(대회_무술) != -1)
            {
                pk::person@ p = pk::get_person(GetCompetitionWinnerId(대회_무술));
                if (p != null && true == p.is_alive())
                {
                    pk::history_log(p.get_pos(), p.get_force_id(), pk::u8encode(pk::format("한실 무술대회 우승 : \x1b[2x{}\x1b[0x", pk::u8decode(pk::get_name(p)))));
                }
            }

            if (GetCompetitionWinnerId(대회_설전) != -1)
            {
                pk::person@ p = pk::get_person(GetCompetitionWinnerId(대회_설전));
                if (p != null && true == p.is_alive())
                {
                    pk::history_log(p.get_pos(), p.get_force_id(), pk::u8encode(pk::format("한실 설전대회 우승 : \x1b[2x{}\x1b[0x", pk::u8decode(pk::get_name(p)))));
                }
            }
        }

        // 유효한 세력인지 확인
        bool IsValidForce(pk::force@ force)
        {
            if (force == null)
            {
                return false;
            }

            if (true == pk::is_alive(force) && true == pk::is_normal_force(force))
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        // 유효한 도시인지 확인
        bool IsValidCity(pk::city@ city)
        {
            if (true == pk::is_alive(city))
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        // 유효한 건물인지 확인
        bool IsValidBuilding(pk::building@ building)
        {
            if (true == pk::is_alive(building))
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        // 유효한 무장인지 확인
        bool IsValidPerson(pk::person@ person)
        {
            if (true == pk::is_alive(person))
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        
        // 체력을 우호도 값으로 변환
        int ConvertHpToValue(int hp, int digit)
        {
            int divider = 1;

            if (digit > 0)
            {
                for (int i = 0; i < digit; ++i)
                {
                    divider = divider * 4;
                }
            }

            return (hp / divider) % 4;
        }

        // 우호도 값을 체력으로 변환
        int ConvertValueToHp(int value, int digit)
        {
            int multiplier = 1;

            if (digit > 0)
            {
                for (int i = 0; i < digit; i++)
                {
                    multiplier = multiplier * 4;
                }
            }

            return value * multiplier;
        }

        // 세력의 교역실행
        void ExecuteTrade(pk::force@ force, int type)
        {
            int forceId = force.get_force_id();
            //pk::building@ data = pk::get_building(dataPointArray[forceId][2]);
            int value;
            switch (type)
            {
            case 우호_대진국:
                value = 100;
                break;

            case 우호_안식국:
                value = 200;
                break;

            case 우호_천축국:
                value = 300;
                break;

            case 우호_귀상국:
                value = 400;
                break;
            }

            dataArray[forceId][2] = dataArray[forceId][2] + value + 교역_일수;

            // 컴퓨터는 6달의 추가 교역일수를 더한다. 자원을 소모하지 않기 때문에.. 교역일수와 추가 교역일이 99일을 넘어가면 패스
            if (false == force.is_player() && (교역_일수 + AI_교역_페널티) <= 99)
            {
                dataArray[forceId][2] += AI_교역_페널티;
            }
        }

        // 현재 교역중인지 받아오는 함수
        bool IsTrading(pk::force@ force)
        {
            if (false == IsValidForce(force))
            {
                return false;
            }
            int forceId = force.get_force_id();
            
            int day = dataArray[forceId][2] % 100;

            if (day > 0)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        
        // 교역중인 세력을 받아오는 함수
        int GetTradeForce(pk::force@ force)
        {
            int forceId = force.get_force_id();

            return (dataArray[forceId][2] / 100) % 10 - 1;
        }

        // 남은 교역일수를 받아오는 함수
        int GetTradeDay(pk::force@ force)
        {
            int forceId = force.get_force_id();

            return dataArray[forceId][2] % 100;
        }
        
        // 교역 날짜 업데이트
        void UpdateTradeDay(pk::force@ force)
        {
            if (false == IsValidForce(force))
            {
                return;
            }

            int forceId = force.get_force_id();

            dataArray[forceId][2] -= 1;
        }

        // 교역 날짜 초기화
        void ResetTrade(pk::force@ force)
        {
            int forceId = force.get_force_id();

            dataArray[forceId][2] = 0;
        }

        // 이민족 외교 날짜 업데이트
        void UpdateRapprochmentDay(pk::force@ force)
        {
            if (false == IsValidForce(force))
            {
                return;
            }

            int forceId = force.get_force_id();

            if (true == IsRapprochment(force, 우호_오환))
            {
                dataArray[forceId][1] -= 1;

                if (dataArray[forceId][1] % 4 == 0)
                {
                    AddRelationValue(force, 우호_오환, 1);
                }
            }

            if (true == IsRapprochment(force, 우호_강))
            {
                dataArray[forceId][1] -= 4;

                if ((dataArray[forceId][1] / 4) % 4 == 0)
                {
                    AddRelationValue(force, 우호_강, 1);
                }
            }

            if (true == IsRapprochment(force, 우호_남만))
            {
                dataArray[forceId][1] -= 16;

                if ((dataArray[forceId][1] / 16) % 4 == 0)
                {
                    AddRelationValue(force, 우호_남만, 1);
                }
            }

            if (true == IsRapprochment(force, 우호_산월))
            {
                dataArray[forceId][1] -= 64;

                if ((dataArray[forceId][1] / 64) % 4 == 0)
                {
                    AddRelationValue(force, 우호_산월, 1);
                }
            }
        }

        // 이민족 외교 날짜 초기화
        void ResetRapprochment(pk::force@ force, int type)
        {
            if (false == IsValidForce(force))
            {
                return;
            }

            int forceId = force.get_force_id();

            //pk::building@ data = pk::get_building(dataPointArray[forceId][1]);

            switch (type)
            {
            case 우호_오환:
                dataArray[forceId][1] -= dataArray[forceId][1] % 4;
                break;

            case 우호_강:
                dataArray[forceId][1] -= ((dataArray[forceId][1] / 4) % 4) * 4;
                break;

            case 우호_남만:
                dataArray[forceId][1] -= ((dataArray[forceId][1] / 16) % 4) * 16;
                break;

            case 우호_산월:
                dataArray[forceId][1] -= ((dataArray[forceId][1] / 64) % 4) * 64;
                break;
            }
        }

        // 해당 이민족과 외교중인지 받아오는 함수
        bool IsRapprochment(pk::force@ force, int type)
        {
            if (false == IsValidForce(force))
            {
                return false;
            }

            int forceId = force.get_force_id();

            //pk::building@ data = pk::get_building(dataPointArray[forceId][1]);

            switch (type)
            {
            case 우호_오환:
                if (dataArray[forceId][1] % 4 > 0)
                {
                    return true;
                }
                else
                {
                    return false;
                }
            case 우호_강:
                if ((dataArray[forceId][1] / 4) % 4 > 0)
                {
                    return true;
                }
                else
                {
                    return false;
                }
            case 우호_남만:
                if ((dataArray[forceId][1] / 16) % 4 > 0)
                {
                    return true;
                }
                else
                {
                    return false;
                }
            case 우호_산월:
                if ((dataArray[forceId][1] / 64) % 4 > 0)
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }

            return false;
        }

        // 이민족과 외교 실행
        void ExecuteRapprochment(pk::force@ force, int type)
        {
            int forceId = force.get_force_id();
            //pk::building@ data = pk::get_building(dataPointArray[forceId][1]);
            int value;
            switch (type)
            {
            case 우호_오환:
                value = 1;
                break;

            case 우호_강:
                value = 4;
                break;

            case 우호_남만:
                value = 16;
                break;

            case 우호_산월:
                value = 64;
                break;
            }

            dataArray[forceId][1] = dataArray[forceId][1] + value * 화친_일수;
        }
        /*
            교역이 가능한 상태인지 받아오는 함수.
            대진국과 안식국은 동시에 교역이 불가능하고,  천축국과 귀상국도 동시에 교역이 불가능하다.
        */
        int GetPossibleTrade(pk::force@ force, pk::building@ building, int& type)
        {
            int data = 0;
            int tp = force.tp;
            bool isRoman = false;
            bool isParthian = false;
            bool isIndia = false;
            bool isKushan = false;
            bool enabled = false;
            if (0 < GetRelationLevel(force, 우호_대진국))
            {
                isRoman = true;
            }

            if (0 < GetRelationLevel(force, 우호_안식국))
            {
                isParthian = true;
            }

            if (0 < GetRelationLevel(force, 우호_천축국))
            {
                isIndia = true;
            }

            if (0 < GetRelationLevel(force, 우호_귀상국))
            {
                isKushan = true;
            }

            type = -1;
            bool isRegionBuff = false;
            int level = -1;

            uint gold = pk::get_gold(building);
            uint food = pk::get_food(building);
            uint troops = pk::get_troops(building);

            if (true == IsTrading(force))
            {
                type = 교역불가_교역중;
                return -1;
            }

            if (false == isParthian && true == IsEnableZhou(force, 사예))
            {
                isRegionBuff = true;
                level = GetRelationLevel(force, 우호_대진국);

                if (3 <= level)
                {
                    type = 교역불가_최대;
                }
                else
                {
                    if (tp < 교역_기교)
                    {
                        type = 교역불가_기교부족;
                        return -1;
                    }

                    if (gold < 교역_금[level] || food < 교역_군량[level] || troops < 교역_병사[level])
                    {
                        type = 교역불가_물자부족;
                    }
                    else
                    {
                        data += 1;
                        enabled = true;
                    }
                }
            }

            if (false == isRoman &&  true == IsEnableZhou(force, 경조))
            {
                isRegionBuff = true;
                level = GetRelationLevel(force, 우호_안식국);

                if (3 <= level)
                {
                    type = pk::min(type, 교역불가_최대);
                }
                else
                {
                    if (tp < 교역_기교)
                    {
                        type = 교역불가_기교부족;
                        return -1;
                    }

                    if (gold < 교역_금[level] || food < 교역_군량[level] || troops < 교역_병사[level])
                    {
                        type = 교역불가_물자부족;
                    }
                    else
                    {
                        data += 2;
                        enabled = true;
                    }
                }
            }

            if (false == isKushan && true == IsEnableZhou(force, 형남))
            {
                isRegionBuff = true;
                level = GetRelationLevel(force, 우호_천축국);

                if (3 <= level)
                {
                    type = pk::min(type, 교역불가_최대);
                }
                else
                {
                    if (tp < 교역_기교)
                    {
                        type = 교역불가_기교부족;
                        return -1;
                    }

                    if (gold < 교역_금[level] || food < 교역_군량[level] || troops < 교역_병사[level])
                    {
                        type = 교역불가_물자부족;
                    }
                    else
                    {
                        data += 4;
                        enabled = true;
                    }
                }
            }

            if (false == isIndia && true == IsEnableZhou(force, 익주))
            {
                isRegionBuff = true;
                level = GetRelationLevel(force, 우호_귀상국);

                if (3 <= level)
                {
                    type = pk::min(type, 교역불가_최대);
                }
                else
                {
                    if (tp < 교역_기교)
                    {
                        type = 교역불가_기교부족;
                        return -1;
                    }

                    if (gold < 교역_금[level] || food < 교역_군량[level] || troops < 교역_병사[level])
                    {
                        type = 교역불가_물자부족;
                    }
                    else
                    {
                        data += 8;
                        enabled = true;
                    }
                }
            }

            if (false == isRegionBuff)
            {
                type = 교역불가_지역이점없음;
            }

            if (false == enabled)
            {
                return -1;
            }

            return data;
        }
        
        // 컴퓨터 세력의 교역
        int AITrade(pk::force@ force)
        {
            int count = 0;
            bool isRoman = false;
            bool isParthian = false;
            bool isIndia = false;
            bool isKushan = false;
            array<int> arr(4);
            if (0 < GetRelationLevel(force, 우호_대진국))
            {
                isRoman = true;
            }

            if (0 < GetRelationLevel(force, 우호_안식국))
            {
                isParthian = true;
            }

            if (0 < GetRelationLevel(force, 우호_천축국))
            {
                isIndia = true;
            }

            if (0 < GetRelationLevel(force, 우호_귀상국))
            {
                isKushan = true;
            }

            int level = -1;

            if (true == IsTrading(force))
            {
                return -1;
            }

            if (false == isParthian && true == IsEnableZhou(force, 사예))
            {
                level = GetRelationLevel(force, 우호_대진국);

                if (3 <= level)
                {
                 
                }
                else
                {
                    arr[count] = 우호_대진국;
                    count += 1;
                }
            }

            if (false == isRoman && true == IsEnableZhou(force, 경조))
            {
                level = GetRelationLevel(force, 우호_안식국);

                if (3 <= level)
                {

                }
                else
                {
                    arr[count] = 우호_안식국;
                    count += 1;
                }
            }

            if (false == isKushan && true == IsEnableZhou(force, 형남))
            {
                level = GetRelationLevel(force, 우호_천축국);

                if (3 <= level)
                {

                }
                else
                {
                    arr[count] = 우호_천축국;
                    count += 1;
                }
            }

            if (false == isIndia && true == IsEnableZhou(force, 익주))
            {
                level = GetRelationLevel(force, 우호_귀상국);

                if (3 <= level)
                {
                 
                }
                else
                {
                    arr[count] = 우호_귀상국;
                    count += 1;
                }
            }

            if (count == 0)
            {
                return -1;
            }

            return arr[pk::rand(count)];
        }
        /*
            플레이어가 이민족과 외교가 가능한 상태인지 받아오는 함수.
        */
        int GetPossibleRapprochement(pk::force@ force, pk::building@ building, int& type)
        {
            int data = 0;
            int tp = force.tp;

            bool enabled = false;

            type = -1;
            bool isRegionBuff = false;
            int level = -1;

            uint gold = pk::get_gold(building);

            if (true == IsEnableZhou(force, 유주) && false == IsRapprochment(force, 우호_오환))
            {
                isRegionBuff = true;

                level = GetRelationLevel(force, 우호_오환);

                if (3 <= level)
                {
                    type = 교역불가_최대;
                }
                else
                {
                    if (tp < 교역_기교)
                    {
                        type = 교역불가_기교부족;
                        return -1;
                    }

                    if (gold < 교역_금[level])
                    {
                        type = 교역불가_물자부족;
                    }
                    else
                    {
                        data += 1;
                        enabled = true;
                    }
                }
            }

            if (true == IsEnableZhou(force, 량주) && false == IsRapprochment(force, 우호_강))
            {
                isRegionBuff = true;
                level = GetRelationLevel(force, 우호_강);

                if (3 <= level)
                {
                    type = pk::min(type, 교역불가_최대);
                }
                else
                {
                    if (tp < 교역_기교)
                    {
                        type = 교역불가_기교부족;
                        return -1;
                    }

                    if (gold < 교역_금[level])
                    {
                        type = 교역불가_물자부족;
                    }
                    else
                    {
                        data += 2;
                        enabled = true;
                    }
                }
            }

            if (true == IsEnableZhou(force, 남중) && false == IsRapprochment(force, 우호_남만))
            {
                isRegionBuff = true;
                level = GetRelationLevel(force, 우호_남만);

                if (3 <= level)
                {
                    type = pk::min(type, 교역불가_최대);
                }
                else
                {
                    if (tp < 교역_기교)
                    {
                        type = 교역불가_기교부족;
                        return -1;
                    }

                    if (gold < 교역_금[level])
                    {
                        type = 교역불가_물자부족;
                    }
                    else
                    {
                        data += 4;
                        enabled = true;
                    }
                }
            }

            if (true == IsEnableZhou(force, 양주) && false == IsRapprochment(force, 우호_산월))
            {
                isRegionBuff = true;
                level = GetRelationLevel(force, 우호_산월);

                if (3 <= level)
                {
                    type = pk::min(type, 교역불가_최대);
                }
                else
                {
                    if (tp < 교역_기교)
                    {
                        type = 교역불가_기교부족;
                        return -1;
                    }

                    if (gold < 교역_금[level])
                    {
                        type = 교역불가_물자부족;
                    }
                    else
                    {
                        data += 8;
                        enabled = true;
                    }
                }
            }

            if (false == isRegionBuff)
            {
                type = 교역불가_지역이점없음;
            }

            if (false == enabled)
            {
                return -1;
            }

            return data;
        }

        // AI가 이민족과 외교가 가능한지 받아오는 함수
        int AIRapprochement(pk::force@ force)
        {
            int count = 0;
            int level = -1;
            array<int> arr(4);

            if (true == IsEnableZhou(force, 유주) && false == IsRapprochment(force, 우호_오환))
            {
                level = GetRelationLevel(force, 우호_오환);

                if (3 <= level)
                {

                }
                else
                {
                    arr[count] = 우호_오환;
                    count += 1;
                }
            }

            if (true == IsEnableZhou(force, 량주) && false == IsRapprochment(force, 우호_강))
            {
                level = GetRelationLevel(force, 우호_강);

                if (3 <= level)
                {

                }
                else
                {
                    arr[count] = 우호_강;
                    count += 1;
                }
            }

            if (true == IsEnableZhou(force, 남중) && false == IsRapprochment(force, 우호_남만))
            {
                level = GetRelationLevel(force, 우호_남만);

                if (3 <= level)
                {

                }
                else
                {
                    arr[count] = 우호_남만;
                    count += 1;
                }
            }

            if (true == IsEnableZhou(force, 양주) && false == IsRapprochment(force, 우호_산월))
            {
                level = GetRelationLevel(force, 우호_산월);

                if (3 <= level)
                {

                }
                else
                {
                    arr[count] = 우호_산월;
                    count += 1;
                }
            }

            if (count <= 0)
            {
                return -1;
            }

            return arr[pk::rand(count)];
        }

        // 친특기 보유 무장 숫자를 받아오는 함수
        int GetRapprochmentPersonCount(pk::force@ force, int targetForce)
        {
            auto list = pk::get_person_list(force, pk::mibun_flags(신분_군주, 신분_도독, 신분_태수, 신분_일반));
            int skill = -1;

            switch (targetForce)
            {
            case 우호_오환:
                skill = 특기_친오;
                break;

            case 우호_강:
                skill = 특기_친강;
                break;

            case 우호_남만:
                skill = 특기_친만;
                break;

            case 우호_산월:
                skill = 특기_친월;
                break;
            }

            int count = 0;

            for (int i = 0; i < list.count; ++i)
            {
                if (skill == list[i].skill)
                {
                    count++;
                }
            }

            return count;
        }

        // AI의 이민족 외교 딜레이
        int GetAIRapprochmentTerm(pk::force@ force)
        {
            int forceId = force.get_force_id();
            //pk::building@ data = pk::get_building(dataPointArray[forceId][2]);

            int term = dataArray[forceId][2] / 1000;

            return term;
        }

        // AI의 이민족 외교 딜레이를 설정하는 함수
        void SetAIRapprochmentTerm(pk::force@ force, int value)
        {
            int forceId = force.get_force_id();
            //pk::building@ data = pk::get_building(dataPointArray[forceId][2]);

            int term = dataArray[forceId][2] / 1000;

            dataArray[forceId][2] -= term * 1000;

            dataArray[forceId][2] += value * 1000;
        }

        // AI의 이민족 외교 딜레이 업데이트
        void UpdateAIRapprochmentTerm(pk::force@ force)
        {
            int forceId = force.get_force_id();
            //pk::building@ data = pk::get_building(dataPointArray[forceId][2]);

            int term = dataArray[forceId][2] / 1000;

            if (term > 0)
            {
                dataArray[forceId][2] -= 1000;
            }
        }

        // 이민족 특기 전수에 사용할 무장 랜덤섞기
        array<pk::person@> RandPersonArray(array<pk::person@> origin, int count)
        {
            if (origin.length <= count)
            {
                return origin;
            }

            int total = 0;
            array<int> temp(count);
            array<pk::person@> resultArr(count);

            for (int i = 0; i < count; ++i)
            {
                temp[i] = -1;
            }

            while (total < count)
            {
                int rand = pk::rand(origin.length);
                if (true == IsExist(temp, rand))
                {
                    continue;
                }
                @resultArr[total] = origin[rand];
                temp[total] = rand;
                total++;
            }

            return resultArr;
        }

        //  무장 랜덤섞기에 사용되는 함수
        bool IsExist(array<int> sour, int value)
        {
            if (sour.length == 0)
            {
                return false;
            }

            bool isExist = false;

            for (int i = 0; i < sour.length; ++i)
            {
                if (sour[i] == value)
                {
                    isExist = true;
                    break;
                }
            }

            return isExist;
        }
        
        // 도시의 주 Id값 받아오기
        int GetZhouId(int cityId)
        {
            switch (cityId)
            {
            case 도시_양평:
            case 도시_북평:
            case 도시_계:
                return 유주;

            case 도시_진양:
                return 병주;

            case 도시_남피:
            case 도시_업:
                return 기주;

            case 도시_북해:
            case 도시_평원:
                return 청주;

            case 도시_하비:
            case 도시_소패:
                return 서주;

            case 도시_수춘:
            case 도시_여강:
                return 회남;

            case 도시_진류:
            case 도시_복양:
                return 연주;

            case 도시_허창:
            case 도시_여남:
                return 예주;

            case 도시_낙양:
                return 사예;

            case 도시_장안:
            case 도시_상용:
            case 도시_완:
                return 경조;

            case 도시_무위:
            case 도시_천수:
            case 도시_안정:
                return 량주;

            case 도시_건업:
            case 도시_오:
            case 도시_회계:
            case 도시_시상:
                return 양주;

            case 도시_양양:
            case 도시_강릉:
            case 도시_강하:
            case 도시_신야:
                return 형북;

            case 도시_장사:
            case 도시_무릉:
            case 도시_계양:
            case 도시_영릉:
                return 형남;

            case 도시_성도:
            case 도시_한중:
            case 도시_자동:
            case 도시_강주:
            case 도시_영안:
                return 익주;

            case 도시_건녕:
            case 도시_운남:
                return 남중;
            }

            return -1;
        }

        // 주 번호로 도시 배열 찾아오기
        array<int> GetZhoudCityArray(int zhouId)
        {
            switch (zhouId)
            {
            case 유주:
                return 유주_도시;
            case 병주:
                return 병주_도시;
            case 기주:
                return 기주_도시;
            case 청주:
                return 청주_도시;
            case 서주:
                return 서주_도시;
            case 회남:
                return 회남_도시;
            case 연주:
                return 연주_도시;
            case 예주:
                return 예주_도시;
            case 사예:
                return 사예_도시;
            case 경조:
                return 경조_도시;
            case 량주:
                return 량주_도시;
            case 양주:
                return 양주_도시;
            case 형북:
                return 형북_도시;
            case 형남:
                return 형남_도시;
            case 익주:
                return 익주_도시;
            case 남중:
                return 남중_도시;
            }

            return {-1};
        }
        
        // 세력이 보유중인 해당 주의 도시숫자
        int GetCityCountAtZhou(pk::force@ force, int zhouId)
        {
            array<int> zhouCities = GetZhoudCityArray(zhouId);
            int count = 0;
            for (int i = 0; i < zhouCities.length; ++i)
            {
                if(pk::get_city(zhouCities[i]).get_force_id() == force.get_force_id())
                {
                    count++;
                }
            }
            return count;
        }

        // 대진국 2단계 달성 시 정란, 누선 교체 함수
        void ChangeWeaponCatapult(pk::force@ force)
        {
            int forceId = force.get_id();
            // 도시
            auto cities = pk::get_city_list(force);
            
            for (int i = 0; i < cities.count; ++i)
            {
                pk::city@ city = cities[i];

                city.weapon_amount[병기_투석] = city.weapon_amount[병기_정란];
                city.weapon_amount[병기_정란] = 0;
                city.weapon_amount[병기_투함] = city.weapon_amount[병기_누선];
                city.weapon_amount[병기_누선] = 0;
            }

            // 관문 
            for (int g = 0; g < 관문_끝; ++g)
            {
                pk::gate@ gate = pk::get_gate(g);

                if (forceId == gate.get_force_id())
                {
                    gate.weapon_amount[병기_투석] = gate.weapon_amount[병기_정란];
                    gate.weapon_amount[병기_정란] = 0;
                    gate.weapon_amount[병기_투함] = gate.weapon_amount[병기_누선];
                    gate.weapon_amount[병기_누선] = 0;
                }
            }

            // 항구
            for (int p = 0; p < 항구_끝; ++p)
            {
                pk::port@ port = pk::get_port(p);

                if (forceId == port.get_force_id())
                {
                    port.weapon_amount[병기_투석] = port.weapon_amount[병기_정란];
                    port.weapon_amount[병기_정란] = 0;
                    port.weapon_amount[병기_투함] = port.weapon_amount[병기_누선];
                    port.weapon_amount[병기_누선] = 0;
                }
            }

            // 유닛
            auto units = pk::get_unit_list(force);

            array<pk::unit@> unitArray = pk::list_to_array(units);

            for (int u = 0; u < unitArray.length; ++u)
            {
                pk::unit@ unit = unitArray[u];

                if (unit.stock[0].id == 병기_정란)
                {
                    unit.stock[0].id = 병기_투석;
                }

                if (unit.stock[1].id == 병기_누선)
                {
                    unit.stock[1].id = 병기_투함;
                }
            }
        }

        // ==================================================================== Ver 1.1 =========================================================================================================

        // 개발 중 공적획득 (적용 안함)
        void DevelopementKousekiUpdate(pk::force@ force)
        {
            if (true == IsValidForce(force))
            {
                auto officers = pk::get_person_list(force, pk::mibun_flags(신분_도독, 신분_태수, 신분_일반));

                array<pk::person@> officerArray = pk::list_to_array(officers);

                int value = 0;
                for (int i = 0; i < officerArray.length; ++i)
                {
                    if (officerArray[i].order == 무장임무_개발)
                    {
                        int politic = officerArray[i].stat[무장능력_정치];
                        value = (politic * politic) / 100;
                        if (value < 1)
                        {
                            value = 2;
                        }

                        pk::add_kouseki(officerArray[i], value / 2 );
                    }
                }
            }
        }

        void SetBarbarianForceData(int clientForceId, int targetCityId, int type, int day)
        {
            int index = -1;

            if (우호_오환 == type)
            {
                index = 0;
            }
            else if (우호_강 == type)
            {
                index = 1;
            }
            else if (우호_남만 == type)
            {
                index = 2;
            }
            else if (우호_산월 == type)
            {
                index = 3;
            }

            //pk::point point = barbarianDataArray[index];
            //pk::building@ data = pk::get_building(point);
            barbarianDataArray[index] = day + 10000 * clientForceId + targetCityId * 100;
        }

        void UpdateBarbarianForce()
        {
            for (int i = 0; i < 4; ++i)
            {
                //pk::point point = barbarianDataArray[i];
                //pk::building@ data = pk::get_building(point);
                int barbarianType = -1;

                if (0 == i)
                {
                    barbarianType = 우호_오환;
                }
                else if (1 == i)
                {
                    barbarianType = 우호_강;
                }
                else if (2 == i)
                {
                    barbarianType = 우호_남만;
                }
                else if (3 == i)
                {
                    barbarianType = 우호_산월;
                }

                // 기한이 남았을 경우 차감
                if (barbarianDataArray[i] % 100 > 0)
                {
                    barbarianDataArray[i] -= 1;
                    
                    // 기한이 모두 소진되었을 경우 군세 삭제
                    if (barbarianDataArray[i] % 100 == 0)
                    {
                        barbarianDataArray[i] = 0;

                        ResetBarbarianUnits(barbarianType, 이민족_철군_기한);
                    }
                    // 기한이 모두 소진 안되었을 경우 버그 부대 수정
                    else
                    {
                        //RenewNonForceBarabarianUnits(i);
                    }
                }
            }
        }

        bool IsActiveForce(int type)
        {
            if (type == 우호_오환)
            {
                //pk::point point = barbarianDataArray[0];
                //pk::building@ data = pk::get_building(point);

                if (barbarianDataArray[0] <= 0)
                {
                    return false;
                }
                else
                {
                    return true;
                }
            }

            if (type == 우호_강)
            {
                //pk::point point = barbarianDataArray[1];
                //pk::building@ data = pk::get_building(point);

                if (barbarianDataArray[1] <= 0)
                {
                    return false;
                }
                else
                {
                    return true;
                }
            }

            if (type == 우호_남만)
            {
                //pk::point point = barbarianDataArray[2];
                //pk::building@ data = pk::get_building(point);

                if (barbarianDataArray[2] <= 0)
                {
                    return false;
                }
                else
                {
                    return true;
                }
            }

            if (type == 우호_산월)
            {
                //pk::point point = barbarianDataArray[3];
                //pk::building@ data = pk::get_building(point);

                if (barbarianDataArray[3] <= 0)
                {
                    return false;
                }
                else
                {
                    return true;
                }
            }

            return false;
        }

        void SummonBarbarianForce(pk::force@ force, pk::city@ city, int barbarianOrder, int type, int count, int troops)
        {
            pk::force@ barbarianForce;
            switch (type)
            {
            case 우호_오환:
                @barbarianForce = pk::get_force(세력_오환);
                break;

            case 우호_강:
                @barbarianForce = pk::get_force(세력_강);
                break;

            case 우호_남만:
                @barbarianForce = pk::get_force(세력_남만);
                break;

            case 우호_산월:
                @barbarianForce = pk::get_force(세력_산월);
                break;
            }

            array<pk::point> posArray = pk::range(city.get_pos(), 4, 6);
            int length = 0;

            for (int i = 0; i < posArray.length; ++i)
            {
                pk::point pos = posArray[i];
                
                if (true == IsValidSummonPos(posArray[i]))
                {
                    length = length + 1;
                }
            }

            if (length == 0)
            {
                return;
            }

            array<pk::point> validPointArray(length);
            int start = 0;

            for (int i = 0; i < posArray.length; ++i)
            {
                if (true == IsValidSummonPos(posArray[i]))
                {
                    validPointArray[start] = posArray[i];
                    start = start + 1;
                }
            }
            
            array<pk::point> destPointArray = GetRandomValidPointArray(validPointArray, count);

            for (int i = 0; i < destPointArray.length; ++i)
            {
                CreateBarbarianUnit(force, type, pk::city_to_building(city), barbarianOrder, destPointArray[i], troops, i);
            }

            pk::history_log(city.get_pos(), barbarianForce.color, pk::u8encode(pk::format("\x1b[1x{}\x1b[0x 부근에 \x1b[2x{}군\x1b[0x 출현", pk::u8decode(pk::get_name(city)), 교역대상_이름[type])));
        }

        array<pk::point> GetRandomValidPointArray(array<pk::point> source, int count)
        {
            int c = source.length;

            if (c <= count)
            {
                return source;
            }
            else
            {
                array<int> indexArray(count);
                // -1로 초기화
                for (int i = 0; i < indexArray.length; ++i)
                {
                    indexArray[i] = -1;
                }

                array<pk::point> destArray(count);
                int n = 0;

                while (true)
                {
                    int r = pk::rand(source.length);

                    // 중복 체크 후 중복이 아니면 포인트 배정
                    if (false == IsDuplicated(indexArray, r))
                    {
                        indexArray[n] = r;
                        destArray[n] = source[r];
                        n = n + 1;
                    }

                    // 모든 배열을 채울 경우 반복문 중단
                    if (n >= count)
                    {
                        break;
                    }
                }

                return destArray;
            }
        }

        // 지역배열 중복 체크
        bool IsDuplicated(array<int> indexArray, int source)
        {
            for (int i = 0; i < indexArray.length; ++i)
            {
                if(indexArray[i] == source)
                {
                    return true;
                }
            }

            return false;
        }

        void CreateBarbarianUnit(pk::force@ force, int type, pk::building@ building, int barbarianOrder, pk::point pos, int troops, int index)
        {
            //int barbarianId;
            int mooArrayIndex = -1;
            int groundWeapon;
            int waterWeapon;
            if (우호_오환 == type)
            {
                //barbarianId = 무장_오환장수;
                mooArrayIndex = 0;
                groundWeapon = 병기_군마;
                waterWeapon = 병기_주가;
            }
            else if (우호_강 == type)
            {
                //barbarianId = 무장_강장수;
                mooArrayIndex = 1;
                groundWeapon = 병기_군마;
                waterWeapon = 병기_주가;
            }
            else if (우호_남만 == type)
            {
                //barbarianId = 무장_남만장수;
                mooArrayIndex = 2;
                if (pk::rand(100) > 49)
                {
                    groundWeapon = 병기_창;
                }
                else
                {
                    groundWeapon = 병기_극;
                }
                waterWeapon = 병기_투함;
            }
            else if (우호_산월 == type)
            {
                //barbarianId = 무장_산월장수;
                mooArrayIndex = 3;
                groundWeapon = 병기_극;
                waterWeapon = 병기_투함;
            }
            auto district = pk::get_district_list(force);
            pk::person@ bandit_person = GetValidBarbarianMoo(type, index);

            if (bandit_person == null)
            {
                return;
            }

            pk::set_district(bandit_person, district[0], building, 0);
            pk::add_loyalty(bandit_person, 255);
            //pk::set_district(bandit_person, force.get_force_id());
            //pk::set_force(pk::get_person(0), force, pk::get_person(1), 0);
            pk::unit@ bandit_unit = pk::create_unit(building, bandit_person, null, null, troops, groundWeapon, waterWeapon, 0, (troops * 9) / 10, pos);
            bandit_unit.energy = 100;
            pk::set_order(bandit_unit, barbarianOrder, building.get_pos());
        }

        bool IsValidSummonPos(pk::point pos)
        {
            if (false == pk::is_valid_pos(pos))
            {
                return false;
            }

            pk::hex@ hex = pk::get_hex(pos);

            if (true == hex.has_building)
            {
                return false;
            }

            if (true == hex.has_unit)
            {
                return false;
            }

            int terrain_id = hex.terrain;

            if (false == pk::is_valid_terrain_id(terrain_id))
            {
                return false;
            }

            if (false == pk::is_enabled_terrain(terrain_id))
            {
                return false;
            }

            if (true == pk::is_water_terrain(terrain_id))
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// 이민족 원군요청 가능 데이터. (-3 : 금 부족, -2 : 요청 가능한 도시 없음, -1 : 기교부족, 0 : 요청 가능한 세력 없음, 오환 가능 +1, 강 가능 +2, 남만 가능 +4, 산월 가능 +8)
        /// </summary>
        /// <param name="force"></param>
        /// <returns></returns>
        int GetSupportData(pk::force@ force)
        {
            int value = 0;
            bool isValidCity = true;
            pk::list<pk::city@> cityList;
            pk::list<pk::city@> validCityList;

            if (3 <= GetRelationLevel(force, 우호_오환))
            {
                if (false == IsActiveForce(우호_오환))
                {
                    if (force.tp < 이민족_원군요청_기교 && true == force.is_player())
                    {
                        return -1;
                    }
                    else
                    {
                        cityList.clear();
                        validCityList.clear();

                        for (int i = 0; i < 오환_영향력.length; ++i)
                        {
                            auto cityArr = GetZhoudCityArray(오환_영향력[i]);

                            for (int j = 0; j < cityArr.length; ++j)
                            {
                                cityList.add(pk::get_city(cityArr[j]));
                            }
                        }

                        validCityList = GetValidSupportCity(force, pk::list_to_array(cityList));
                    }

                    if (validCityList.count >= 1)
                    {
                        value += 1;
                    }
                    else
                    {
                        isValidCity = false;
                    }
                }
            }

            if (3 <= GetRelationLevel(force, 우호_강))
            {
                if (false == IsActiveForce(우호_강))
                {
                    if (force.tp < 이민족_원군요청_기교 && true == force.is_player())
                    {
                        return -1;
                    }
                    else
                    {
                        cityList.clear();
                        validCityList.clear();

                        for (int i = 0; i < 강_영향력.length; ++i)
                        {
                            auto cityArr = GetZhoudCityArray(강_영향력[i]);

                            for (int j = 0; j < cityArr.length; ++j)
                            {
                                cityList.add(pk::get_city(cityArr[j]));
                            }
                        }

                        validCityList = GetValidSupportCity(force, pk::list_to_array(cityList));
                    }

                    if (validCityList.count  >= 1)
                    {
                        value += 2;
                    }
                    else
                    {
                        isValidCity = false;
                    }
                }
            }
            
            if (3 <= GetRelationLevel(force, 우호_남만))
            {
                if (false == IsActiveForce(우호_남만))
                {
                    if (force.tp < 이민족_원군요청_기교 && true == force.is_player())
                    {
                        return -1;
                    }
                    else
                    {
                        cityList.clear();
                        validCityList.clear();

                        for (int i = 0; i < 남만_영향력.length; ++i)
                        {
                            auto cityArr = GetZhoudCityArray(남만_영향력[i]);

                            for (int j = 0; j < cityArr.length; ++j)
                            {
                                cityList.add(pk::get_city(cityArr[j]));
                            }
                        }

                        validCityList = GetValidSupportCity(force, pk::list_to_array(cityList));
                    }

                    if (validCityList.count >= 1)
                    {
                        value += 4;
                    }
                    else
                    {
                        isValidCity = false;
                    }
                }
            }

            if (3 <= GetRelationLevel(force, 우호_산월))
            {
                if (false == IsActiveForce(우호_산월))
                {
                    if (force.tp < 이민족_원군요청_기교 && true == force.is_player())
                    {
                        return -1;
                    }
                    else
                    {
                        cityList.clear();
                        validCityList.clear();

                        for (int i = 0; i < 산월_영향력.length; ++i)
                        {
                            auto cityArr = GetZhoudCityArray(산월_영향력[i]);

                            for (int j = 0; j < cityArr.length; ++j)
                            {
                                cityList.add(pk::get_city(cityArr[j]));
                            }
                        }

                        validCityList = GetValidSupportCity(force, pk::list_to_array(cityList));
                    }

                    if (validCityList.count >= 1)
                    {
                        value += 8;
                    }
                    else
                    {
                        isValidCity = false;
                    }
                }
            }

            if (0 == value && false == isValidCity)
            {
                return -2;
            }

            return value;
        }
        
        // 사용 안함
        void RenewNonForceBarabarianUnits(int forceType)
        {
            string name = "";

            if (우호_오환 == forceType)
            {
                name = pk::get_name(pk::get_person(무장_오환장수));
            }
            else if (우호_강 == forceType)
            {
                name = pk::get_name(pk::get_person(무장_강장수));
            }
            else if (우호_남만 == forceType)
            {
                name = pk::get_name(pk::get_person(무장_남만장수));
            }
            else if (우호_산월 == forceType)
            {
                name = pk::get_name(pk::get_person(무장_산월장수));
            }

            pk::list<pk::unit@> list = pk::get_unit_list();
            array<pk::unit@> unitArray = pk::list_to_array(list);

            if (unitArray.length > 0)
            {
                for (int i = 0; i < unitArray.length; ++i)
                {
                    if (true == unitArray[i].is_alive() && null != unitArray[i])
                    {
                        pk::unit@ unit = unitArray[i];
                        
                        if (unit.leader >= 적장_시작 && unit.leader < 적장_끝)
                        {
                            // 적장의 이름이 이민족 무장 이름과 같은경우 체크
                            pk::person@ barbarian = pk::get_person(unit.leader);
                            string barbarianName = pk::get_name(barbarian);
                            
                            if (barbarianName == name)
                            {
                                int force_id = barbarianDataArray[forceType] / 10000;
                                pk::force@ force = pk::get_force(force_id);
                                auto district = pk::get_district_list(force);
                                pk::city@ city = pk::get_city((barbarianDataArray[forceType] % 10000) / 100);

                                if (barbarian.get_force_id() == -1)
                                {
                                    pk::set_district(barbarian, pk::get_district_id(force,0));
                                }

                                pk::set_order(unit, 부대임무_정복, city.get_pos());
                            }
                        }
                    }
                }
            }
        }

        void ResetBarbarianUnits(int forceType, int removeType)
        {
            int forceId;
            string name = "";
            forceId = 교역대상_아이디[forceType];
            pk::force@ barbarianForce = pk::get_force(forceId);

            string s = "";

            if (removeType == 이민족_철군_동맹)
            {
                s = "철군 명령이 떨어졌다. 이만 돌아가야겠군";
            }
            else if (removeType == 이민족_철군_기한)
            {
                s = "약속한 기한이 지났으니 우리는 물러나도록 하겠소.";
                if (우호_오환 == forceType)
                {
                    name = pk::get_name(pk::get_person(무장_오환장수));
                }
                else if (우호_강 == forceType)
                {
                    name = pk::get_name(pk::get_person(무장_강장수));
                }
                else if (우호_남만 == forceType)
                {
                    name = pk::get_name(pk::get_person(무장_남만장수));
                }
                else if (우호_산월 == forceType)
                {
                    name = pk::get_name(pk::get_person(무장_산월장수));
                }
            }
            else if (removeType == 이민족_철군_진상)
            {
                s = "흥. 성의를 봐서 한번 봐주도록 할까.";
            }
            
            pk::list<pk::unit@> list = pk::get_unit_list();
            array<pk::unit@> unitArray = pk::list_to_array(list);

            if (unitArray.length > 0)
            {
                bool isDone = false;
                pk::point logPos;

                for (int i = 0; i < unitArray.length; ++i)
                {
                    if (true == unitArray[i].is_alive() && null != unitArray[i])
                    {
                        pk::unit@ unit = unitArray[i];
                        if (unit.leader >= 적장_시작 && unit.leader < 적장_끝)
                        {
                            // 적장의 이름이 이민족 무장 이름과 같은경우 체크
                            string barbarianName = pk::get_name(pk::get_person(unit.leader));
                            if (barbarianName == name)
                            {
                                if (false == isDone)
                                {
                                    logPos = unit.get_pos();
                                    pk::say(pk::u8encode(s), pk::get_person(unit.leader), unit);
                                    isDone = true;
                                }
                                pk::kill(unit);
                            }
                        }
                    }
                }

                if (true == isDone)
                {
                    // 철군 기한이 지났을때 이민족 부대가 남아있을 경우 메시지 출력
                    if (removeType == 이민족_철군_기한)
                    {
                        pk::message_box(pk::u8encode(pk::format("\x1b[2x{}군\x1b[0x이 철수했습니다.", 교역대상_이름[forceType])));
                    }

                    pk::history_log(logPos, barbarianForce.color, pk::u8encode(pk::format("\x1b[2x{}군\x1b[0x 퇴각", 교역대상_이름[forceType])));
                }
            }

            // 이민족과의 동맹으로 인한 철군인 경우에만 본거지 철거 실시
            if (이민족_철군_동맹 == removeType)
            {
                // 이 콜백은 도시 별로 호출되기 때문에 맵 상에 건물이 많을 수록 리스트로 접근하면 속도가 느려지므로 배열로 변환.
                array<pk::building@> arr = pk::list_to_array(pk::get_building_list());
            
                for (int j = 0; j < arr.length; j++)
                {
                    pk::building@ building = arr[j];
                    
                    if (building.facility == 시설_본거지1 || building.facility == 시설_본거지2)
                    {
                        if (building.get_force_id() == forceId && true == building.is_alive())
                        {
                            pk::kill(building);
                        }
                    }
                }
            }
        }

        pk::list<pk::city@> GetValidSupportCity(pk::force@ force, array<pk::city@> cityArray)
        {
            pk::list<pk::city@> forceCityList;
            pk::list<pk::city@> validCityList;

            for (int i = 0; i < cityArray.length; ++i)
            {
                pk::city@ city = cityArray[i];
        
                if (city.get_force_id() == force.get_force_id())
                {
                    forceCityList.add(city);
                    //validCityList.add(city);
                }
            }

            for (int i = 0; i < cityArray.length; ++i)
            {
                pk::city@ city = cityArray[i];

                // 자세력 소유 도시가 아닌 도시만 가능
                if (city.get_force_id() != force.get_force_id())
                {
                    // 동맹중인 세력에 공격요청 불가
                    if (true == pk::is_enemy(force, city))
                    {
                        for (int j = 0; j < forceCityList.count; ++j)
                        {
                            if (true == pk::has_neighbor(city, forceCityList[j].get_id()))
                            {
                                validCityList.add(city);
                                break;
                            }
                        }
                    }
                }
            }

            return validCityList;
        }

        bool IsValidBandit()
        {
            for (int person_id = 적장_시작; person_id < 적장_끝; person_id++)
            {
                pk::person@ person = pk::get_person(person_id);
                if (person.mibun == 신분_없음) return true;
                if (person.mibun == 신분_사망) return true;
            }

            return false;
        }

        pk::list<pk::city@> GetValidSupportCityList(pk::force@ force, int type)
        {
            pk::list<pk::city@> cityList;
            pk::list<pk::city@> validCityList;
            
            if (type == 우호_오환)
            {
                for (int i = 0; i < 오환_영향력.length; ++i)
                {
                    auto cityArr = GetZhoudCityArray(오환_영향력[i]);

                    for (int j = 0; j < cityArr.length; ++j)
                    {
                        cityList.add(pk::get_city(cityArr[j]));
                    }
                }

                validCityList = GetValidSupportCity(force, pk::list_to_array(cityList));
            }

            if (type == 우호_강)
            {
                for (int i = 0; i < 강_영향력.length; ++i)
                {
                    auto cityArr = GetZhoudCityArray(강_영향력[i]);

                    for (int j = 0; j < cityArr.length; ++j)
                    {
                        cityList.add(pk::get_city(cityArr[j]));
                    }
                }

                validCityList = GetValidSupportCity(force, pk::list_to_array(cityList));
            }

            if (type == 우호_남만)
            {
                for (int i = 0; i < 남만_영향력.length; ++i)
                {
                    auto cityArr = GetZhoudCityArray(남만_영향력[i]);

                    for (int j = 0; j < cityArr.length; ++j)
                    {
                        cityList.add(pk::get_city(cityArr[j]));
                    }
                }

                validCityList = GetValidSupportCity(force, pk::list_to_array(cityList));
            }

            if (type == 우호_산월)
            {
                for (int i = 0; i < 산월_영향력.length; ++i)
                {
                    auto cityArr = GetZhoudCityArray(산월_영향력[i]);

                    for (int j = 0; j < cityArr.length; ++j)
                    {
                        cityList.add(pk::get_city(cityArr[j]));
                    }
                }

                validCityList = GetValidSupportCity(force, pk::list_to_array(cityList));
            }

            return validCityList;
        }

        void ExecuteAISupport(pk::force@ force)
        {
            if (이민족지원_사용여부 == 0)
                return;

            int year = pk::get_elapsed_years();
            int percentage = AI_이민족지원_기본확률;
            pk::person@ barbarianMoo;

            // 1년 이내에는 AI가 지원요청 하지 않음
            if (year < 1)
            {
                return;
            }
            else if (year < 3)
            {
                percentage += AI_이민족지원_추가확률;
            }
            else if (year < 5)
            {
                percentage += AI_이민족지원_추가확률;
            }
            else if (year < 7)
            {
                percentage += AI_이민족지원_추가확률;
            }
            else if (year < 9)
            {
                percentage += AI_이민족지원_추가확률;
            }

            pk::list<pk::city@> validCityList;
            int data = GetSupportData(force);
            int count = 0;

            if (data <= 0)
            {
                return;
            }

            if (data % 2 == 1)
            {
                count = count + 1;
            }
            // 강
            if ((data / 2) % 2 == 1)
            {
                count = count + 1;
            }
            // 남만
            if ((data / 4) % 2 == 1)
            {
                count = count + 1;
            }
            // 산월
            if ((data / 8) % 2 == 1)
            {
                count = count + 1;
            }

            if (count <= 0)
            {
                return;
            }

            array<int> barbarianArray(count);
            count = 0;

            if (data % 2 == 1)
            {
                barbarianArray[count] = 우호_오환;
                count = count + 1;
            }
            // 강
            if ((data / 2) % 2 == 1)
            {
                barbarianArray[count] = 우호_강;
                count = count + 1;
            }
            // 남만
            if ((data / 4) % 2 == 1)
            {
                barbarianArray[count] = 우호_남만;
                count = count + 1;
            }
            // 산월
            if ((data / 8) % 2 == 1)
            {
                barbarianArray[count] = 우호_산월;
                count = count + 1;
            }

            int r = pk::rand(count);
            int targetForceId = barbarianArray[r];
            validCityList = GetValidSupportCityList(force, targetForceId);
            if (validCityList.count <= 0)
            {
                return;
            }
            validCityList.shuffle();
            pk::city@ city = validCityList[0];
            bool isPlayer = false;
            // 목표 도시가 유저 도시일 경우 유저 도시 숫자의 1.5배보다 도시 수가 적을경우 확률 두배
            if (true == pk::get_force(city.get_force_id()).is_player())
            {
                int playerCityCount = pk::get_city_list(pk::get_force(city.get_force_id())).count;
                int aiCityCount = pk::get_city_list(force).count;

                if (playerCityCount * 3 > aiCityCount * 2)
                {
                    percentage = percentage * 2;
                }

                isPlayer = true;
            }

            if (true == pk::rand_bool(percentage))
            {
                if (targetForceId == 우호_오환)
                {
                    @barbarianMoo = pk::get_person(무장_오환두목);
                }
                else if (targetForceId == 우호_강)
                {
                    @barbarianMoo = pk::get_person(무장_강두목);
                }
                else if (targetForceId == 우호_남만)
                {
                    @barbarianMoo = pk::get_person(무장_남만두목);
                }
                else if (targetForceId == 우호_산월)
                {
                    @barbarianMoo = pk::get_person(무장_산월두목);
                }

                // 유저 도시에 등장할 경우 메시지 출력
                if (true == isPlayer)
                {
                    MoveScreen(city.get_pos());

                    if (true == pk::rand_bool(50))
                    {
                        pk::message_box(pk::u8encode(pk::format("출진의 북을 울려라. \x1b[1x{}\x1b[0x에 쥐새끼 한마리도 남기지 마라!", pk::u8decode(pk::get_name(city)))), barbarianMoo);
                    }
                    else
                    {
                        pk::message_box(pk::u8encode("개인적인 원한은 없네만 당신네들이 너무 거슬려서 말이지. 흐흐흐..."), barbarianMoo);
                    }
                }
                SetBarbarianForceData(force.get_force_id(), city.get_id(), targetForceId, 이민족_지속기간);
                SummonBarbarianForce(force, city, 부대임무_정복, targetForceId, GetBarbarianSupportUnitCount(), GetBarbarianSupportUnitTroops());
            }

            validCityList.clear();
        }

        pk::point _movePos;
        void MoveScreen(pk::point pos)
        {
            _movePos = pos;
            pk::scene(pk::scene_t(move_screen_scene));
        }

        void move_screen_scene()
        {
            pk::move_screen(_movePos);
        }

        int GetBarbarianSupportUnitCount()
        {
            int year = pk::get_elapsed_years();
    
            if (year <= 0)
            {
                return 2;
            }
            else if (year <= 2)
            {
                return 3;
            }
            else if (year <= 4)
            {
                return 4;
            }
            else if (year <= 6)
            {
                return 5;
            }
            else if (year <= 8)
            {
                return 6;
            }
            
            return 7;
        }

        int GetBarbarianSupportUnitTroops()
        {
            int year = pk::get_elapsed_years();

            if (year <= 1)
            {
                return 3000;
            }
            else if (year <= 3)
            {
                return 4000;
            }
            else if (year <= 5)
            {
                return 5000;
            }
            else if (year <= 7)
            {
                return 6000;
            }
            else if (year <= 9)
            {
                return 7000;
            }

            return 8000;
        }

        void InitBarbarianMooArray()
        {
            for (int i = 0; i < 4; ++i)
            {
                for (int j = 0; j < 10; ++j)
                {
                    pk::person@ bandit_person;

                    if (i == 0)
                    {
                        @bandit_person = pk::create_bandit(pk::get_person(무장_오환장수));
                    }
                    else if (i == 1)
                    {
                        @bandit_person = pk::create_bandit(pk::get_person(무장_강장수));
                    }
                    else if (i == 2)
                    {
                        @bandit_person = pk::create_bandit(pk::get_person(무장_남만장수));
                    }
                    else if (i == 3)
                    {
                        @bandit_person = pk::create_bandit(pk::get_person(무장_산월장수));
                    }
                    bandit_person.mibun = 신분_없음;
                    @barbarianMooArray[i][j] = bandit_person;
                }
            }
        }

        pk::person@ GetValidBarbarianMoo(int type, int index)
        {
            int arrayIndex = -1;

            if (우호_오환 == type)
            {
                arrayIndex = 0;
            }
            else if (우호_강 == type)
            {
                arrayIndex = 1;
            }
            else if (우호_남만 == type)
            {
                arrayIndex = 2;
            }
            else if (우호_산월 == type)
            {
                arrayIndex = 3;
            }

            pk::person@ moo = barbarianMooArray[arrayIndex][index];

            if (moo.mibun == 신분_없음 || moo.mibun == 신분_사망)
            {
                moo.mibun == 신분_일반;
                return moo;
            }

            return null;
        }

        void CheckDuelCompetition()
        {
            // 월체크
            if (pk::get_month() != 대회_개최시기_무술)
            {
                return;
            }

            // 년도체크
            int year = pk::get_year();

            if (0 == 무술대회_개최여부)
            {
                return;
            }
            if (1 == 무술대회_개최여부 && year % 2 == 0)
            {
                return;
            }
            else if (2 == 무술대회_개최여부 && year % 2 == 1)
            {
                return;
            }
            else if (3 == 무술대회_개최여부)
            {
              
            }

            ExecuteCompetition(대회_무술);
        }

        void CheckEloquenceCompetition()
        {
            // 월체크
            if (pk::get_month() != 대회_개최시기_설전)
            {
                return;
            }

            // 년도체크
            int year = pk::get_year();

            if (0 == 설전대회_개최여부)
            {
                return;
            }
            if (1 == 설전대회_개최여부 && year % 2 == 0)
            {
                return;
            }
            else if (2 == 설전대회_개최여부 && year % 2 == 1)
            {
                return;
            }
            else if (3 == 설전대회_개최여부)
            {
              
            }

            ExecuteCompetition(대회_설전);
        }

        void ExecuteCompetition(int type)
        {
            //초기화
            bool isProtecting = false;
            @hostForce = null;
            validAICompetitionList.clear();
            validPlayerCompetitonList.clear();              
            competitonParticipantList.clear();
            validForceCount = 0;
            SetCompetitionWinner(-1, type);

            pk::person@ Emperor = pk::get_person(pk::get_scenario().emperor);
            
            // 황제가 죽었거나 없을 경우 패스
            if (null == Emperor)
            {
                return;
            }
            else if (Emperor.mibun == 신분_사망)
            {
                return;
            }

            for (int i = 0; i < 도시_끝; ++i)
            {
                pk::force@ force = pk::get_force(i);

                if (true == force.is_alive())
                {
                    // 황제 보유국 유무 체크
                    if (true == pk::is_protecting_the_emperor(force))
                    {
                        // 황제는 보호받는 중임
                        isProtecting = true;

                        // 황제 보유국의 참가여부 체크
                        if (true == IsExistQualification(force, type, 대회_8강이상))
                        {
                            @hostForce = force;
                            validForceCount++;
                        }

                        continue;
                    }
                    else
                    {
                        // 황제 옹립 안하면서 국호 있으면 패스
                        if (force.kokugou != -1)
                        {
                            continue;
                        }
                    }

                    // 자격요건 검사
                    if (false == IsExistQualification(force, type, 대회_8강이상))
                    {
                        continue;
                    }

                    validForceCount++;

                    if (true == force.is_player())
                    {
                        validPlayerCompetitonList.add(force);
                    }
                    else
                    {
                        validAICompetitionList.add(force);
                    }
                }
            }

            // 황제를 보호중인 세력이 없을경우 패스
            if (false == isProtecting)
            {
                return;
            }
            
            // 자격요건을 충족하는 세력이 20개 이상이면 16강부터 시작
            if (validForceCount >= 20)
            {
                validForceCount = 16;
            }
            // 8 ~ 19 사이면 8강 시작
            else if (validForceCount >= 8)
            {
                validForceCount = 8;
            }
            // 7세력 이하인 경우
            else
            {
                if (true == 대회_4세력개최여부)
                {
                    InspectFourCountryCompetition(type);
                    // 4세력 이상이면 4세력 대회 개최
                    if (validForceCount >= 4)
                    {
                        validForceCount = 4; 
                    }
                    // 그 이하면 패스
                    else
                    {
                        return;
                    }
                }
                // 4세력 개최여부가 불가면 패스
                else
                {
                    return;
                }
            }

            if (대회_무술 == type)
            {
                pk::scene(pk::scene_t(DuelCompetitonScene));
            }

            else if (대회_설전 == type)
            {
                pk::scene(pk::scene_t(EloquenceCompetitionScene));
            }
        }

        void InspectFourCountryCompetition(int type)
        {
            //bool isProtecting = false;
            @hostForce = null;
            validAICompetitionList.clear();
            validPlayerCompetitonList.clear();
            competitonParticipantList.clear();
            validForceCount = 0;
            //SetCompetitionWinner(-1, type);

            pk::person@ Emperor = pk::get_person(pk::get_scenario().emperor);

            // 황제가 죽었거나 없을 경우 패스
            if (null == Emperor)
            {
                return;
            }
            else if (Emperor.mibun == 신분_사망)
            {
                return;
            }

            for (int i = 0; i < 도시_끝; ++i)
            {
                pk::force@ force = pk::get_force(i);

                if (true == force.is_alive())
                {
                    // 황제 보유국 유무 체크
                    if (true == pk::is_protecting_the_emperor(force))
                    {
                        // 황제는 보호받는 중임
                        //isProtecting = true;

                        // 황제 보유국의 참가여부 체크
                        if (true == IsExistQualification(force, type, 대회_4강))
                        {
                            @hostForce = force;
                            validForceCount++;
                        }

                        continue;
                    }
                    else
                    {
                        // 황제 옹립 안하면서 국호 있으면 패스
                        if (force.kokugou != -1)
                        {
                            continue;
                        }
                    }

                    // 자격요건 검사
                    if (false == IsExistQualification(force, type, 대회_4강))
                    {
                        continue;
                    }

                    validForceCount++;

                    if (true == force.is_player())
                    {
                        validPlayerCompetitonList.add(force);
                    }
                    else
                    {
                        validAICompetitionList.add(force);
                    }
                }
            }
        }

        // 무술대회 씬
        void DuelCompetitonScene()
        {
            pk::person@ Emperor = pk::get_person(pk::get_scenario().emperor);
            array<pk::force@> forceArray = GetParticipatingForceArray(대회_무술);

            string ment0 = pk::format("\x1b[2x무술대회\x1b[0x를 개최하도록 하겠소. 참가하는 세력은 \x1b[2x{}\x1b[0x,", pk::u8decode(pk::get_name(forceArray[0])));
            pk::person@ winner = null;
            pk::person@ runnerUp = null;

            pk::message_box(pk::u8encode("황제로부터 \x1b[2x무술대회\x1b[0x를 개최한다는 칙서가 내려왔습니다."));
            pk::move_screen(Emperor.get_pos());
            
            pk::fade(0);
            pk::sleep();
            pk::background(1);
            pk::fade(255);

            if (4 == validForceCount)
            {
                ment0 = ment0 + pk::format(" \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x의 세력이오.", pk::u8decode(pk::get_name(forceArray[1])), pk::u8decode(pk::get_name(forceArray[2])), pk::u8decode(pk::get_name(forceArray[3])));
                pk::message_box(pk::u8encode(ment0), Emperor);
            }
            else if (8 == validForceCount)
            {
                string ment1 = pk::format("\x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x", pk::u8decode(pk::get_name(forceArray[1])), pk::u8decode(pk::get_name(forceArray[2])), pk::u8decode(pk::get_name(forceArray[3])), pk::u8decode(pk::get_name(forceArray[4])), pk::u8decode(pk::get_name(forceArray[5])), pk::u8decode(pk::get_name(forceArray[6])), pk::u8decode(pk::get_name(forceArray[7])));
                pk::message_box(pk::u8encode(ment0), Emperor);
                ment1 = ment1 + "의 세력이오";
                pk::message_box(pk::u8encode(ment1), Emperor);
            }
            else if(16 == validForceCount)
            {
                string ment1 = pk::format("\x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x", pk::u8decode(pk::get_name(forceArray[1])), pk::u8decode(pk::get_name(forceArray[2])), pk::u8decode(pk::get_name(forceArray[3])), pk::u8decode(pk::get_name(forceArray[4])), pk::u8decode(pk::get_name(forceArray[5])), pk::u8decode(pk::get_name(forceArray[6])), pk::u8decode(pk::get_name(forceArray[7])));
                pk::message_box(pk::u8encode(ment0), Emperor);
                pk::message_box(pk::u8encode(ment1), Emperor);
                ment1 = pk::format("그리고 \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x의 세력이오", pk::u8decode(pk::get_name(forceArray[8])), pk::u8decode(pk::get_name(forceArray[9])), pk::u8decode(pk::get_name(forceArray[10])), pk::u8decode(pk::get_name(forceArray[11])), pk::u8decode(pk::get_name(forceArray[12])), pk::u8decode(pk::get_name(forceArray[13])), pk::u8decode(pk::get_name(forceArray[14])), pk::u8decode(pk::get_name(forceArray[15])));
                pk::message_box(pk::u8encode(ment1), Emperor);
            }
            
            int requireCount = 1;

            if (4 == validForceCount)
            {
                requireCount = 2;
            }

            // 참가무장 선발
            for (int i = 0; i < forceArray.length; ++i)
            {
                auto list = GetCompetitionPersonList(forceArray[i], 대회_무술, false);
                auto validList = GetSortedCompetitionPersonList(list, 무장능력_무력);
                if (false == forceArray[i].is_player())
                {
                    for (int i = 0; i < requireCount; ++i)
                    {
                        competitonParticipantList.add(validList[i]);
                    }
                }
                else
                {
                    pk::message_box(pk::u8encode("무술대회에 참가할 무장을 선택해주십시오."));
                    pk::list<pk::person@> person_sel = pk::person_selector(pk::u8encode("무장 선택"), pk::u8encode("무술대회에 참가할 무장을 선택합니다.)"), validList, requireCount, requireCount);
                    if (person_sel.count <= 0)
                    {
                        pk::message_box(pk::u8encode("무장을 선택을 취소했습니다. 자동으로 무장이 선택됩니다."));

                        for (int i = 0; i < requireCount; ++i)
                        {
                            competitonParticipantList.add(validList[i]);
                        }
                    }
                    else
                    {
                        for (int i = 0; i < requireCount; ++i)
                        {
                            competitonParticipantList.add(person_sel[i]);
                        }
                    }
                }
            }

            pk::fade(0);
            pk::sleep();
            pk::background(57);
            pk::fade(255);

            array<pk::person@> backUpArray = pk::list_to_array(competitonParticipantList);
            RunDuelCompetition(competitonParticipantList, winner, runnerUp, false);
            string title = "";
            if (winner.sex == 성별_남)
            {
                title = "\x1b[1x호걸\x1b[0x";
            }
            else if (winner.sex == 성별_여)
            {
                title = "\x1b[1x여걸\x1b[0x";
            }
            AddCompetitionCount(winner, 대회_무술);

            pk::fade(0);
            pk::sleep();
            pk::background(19);
            pk::fade(255);
            pk::play_se(10);
            pk::message_box(pk::u8encode(pk::format("우승자는 \x1b[2x{}\x1b[0x인가. 그대야말로 진정한 {}이로다. 우승을 축하하오.", pk::u8decode(pk::get_name(winner)), title)), Emperor);
            pk::message_box(pk::u8encode("이건 내가 그대에게 내리는 포상이오."), Emperor);
            pk::message_box(pk::u8encode("영광이옵니다."), winner);
            pk::building@ winnerBuilding = pk::get_building(winner.service);
            pk::add_gold(winnerBuilding, 우승_기교, true);
            pk::add_kouseki(winner, 우승_공적);
            pk::message_box(pk::u8encode(pk::format("\x1b[2x상금\x1b[0x \x1b[1x{}\x1b[0x을 받고 그 명성으로 \n\x1b[2x공적\x1b[0x이 \x1b[1x{}\x1b[0x만큼 올랐습니다", 우승_기교, 우승_공적)));
            pk::message_box(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x에게도 포상을 내리겠소.", pk::u8decode(pk::get_name(runnerUp)))), Emperor);
            pk::message_box(pk::u8encode("영광이옵니다."), runnerUp);
            pk::building@ runnerUpBuilding = pk::get_building(runnerUp.service);
            pk::add_gold(runnerUpBuilding, 준우승_기교, true);
            pk::add_kouseki(runnerUp, 준우승_공적);
            pk::message_box(pk::u8encode(pk::format("\x1b[2x상금\x1b[0x \x1b[1x{}\x1b[0x을 받고 그 명성으로 \n\x1b[2x공적\x1b[0x이 \x1b[1x{}\x1b[0x만큼 올랐습니다", 준우승_기교, 준우승_공적)));
            
            if (!HasTitle(winner))
            {
                if (GetCompetitionWinnerId(대회_설전) == winner.get_id() && IsEmptyTitle(2))
                {
                    // 국사무쌍
                    pk::play_se(10);
                    pk::message_box(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x. 그대의 용맹과 지모는 온 나라에 비견할 자가 없소. 그대야말로 진정한 {}이오.", pk::u8decode(pk::get_name(winner)), 칭호_이름[2])), Emperor);
                    pk::message_box(pk::u8encode("분에 넘치는 영광이옵니다."), winner);
                    pk::message_box(pk::u8encode(pk::format("무예와 지혜를 모두 뽐낸 \x1b[2x{}\x1b[0x에게 칭호 {}이 부여됩니다.", pk::u8decode(pk::get_name(winner)), 칭호_이름[2])));
                    pk::history_log(winner.get_pos(), pk::get_force(winner.get_force_id()).color, pk::u8encode(pk::format("\x1b[2x{}\x1b[0x, \x1b[1x국사무쌍\x1b[0x", pk::u8decode(pk::get_name(winner)))));
                    SetTitle(winner, 2);
                }

                if (GetCompetitionCount(winner, 대회_무술) >= 3)
                {
                    pk::person@ prev;
                    bool is_achieve = false;
                    // 천하무쌍
                    if (IsEmptyTitle(0))
                    {
                        is_achieve = true;
                    }
                    else
                    {
                        @prev = pk::get_person(titleArray[0]);

                        if (prev.mibun == 신분_포로)
                        {
                            pk::message_box(pk::u8encode(pk::format("이전의 {}이 포로 상태이므로 도전이 발생하지 않습니다.", 칭호_이름[0])));
                            is_achieve = true;
                        }
                        else
                        {
                            // 도전 결투
                            pk::message_box(pk::u8encode(pk::format("{} \x1b[2x{}\x1b[0x에게 \x1b[2x{}\x1b[0x(이)가 도전합니다.", 칭호_이름[0], pk::u8decode(pk::get_name(prev)), pk::u8decode(pk::get_name(winner)))));

                            bool c1 = false;                            // 무장1 조종여부
                            bool c2 = false;                            // 무장2 조종여부
                            bool skip = false;

                            if (true == winner.is_player() && true == prev.is_player())
                            {
                                skip = true;
                            }

                            if (false == skip)
                            {
                                if (true == prev.is_player())
                                {
                                    c1 = pk::yes_no(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x의 경기를 직접 조종하시겠습니까?", pk::u8decode(pk::get_name(prev)))));
                                }

                                if (true == winner.is_player())
                                {
                                    c2 = pk::yes_no(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x의 경기를 직접 조종하시겠습니까?", pk::u8decode(pk::get_name(winner)))));
                                }
                            }

                            pk::int_bool win = pk::duel(null, null, prev, null, null, winner, null, null, c1, c2, 0, true);

                            if (win.first != 0)
                            {
                                is_achieve = true;
                            }
                        }
                    }
                    
                    if (is_achieve)
                    {
                        pk::play_se(10);
                        pk::message_box(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x. 그대의 무예가 천하를 뒤흔들고 있다. 그대야말로 진정한 {}이오.", pk::u8decode(pk::get_name(winner)), 칭호_이름[0])), Emperor);
                        pk::message_box(pk::u8encode("분에 넘치는 영광이옵니다."), winner);
                        pk::message_box(pk::u8encode(pk::format("무술대회에서 뛰어난 기록을 세운 \x1b[2x{}\x1b[0x에게 칭호 {}이 부여됩니다.", pk::u8decode(pk::get_name(winner)), 칭호_이름[0])));
                        pk::history_log(winner.get_pos(), pk::get_force(winner.get_force_id()).color, pk::u8encode(pk::format("\x1b[2x{}\x1b[0x, \x1b[1x천하무쌍\x1b[0x", pk::u8decode(pk::get_name(winner)))));
                        SetTitle(winner, 0);
                    }
                    else
                    {
                        pk::play_se(10);
                        pk::message_box(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x의 실력은 여전하군. 그대가 진정한 {}이오.", pk::u8decode(pk::get_name(prev)), 칭호_이름[0])), Emperor);
                        pk::message_box(pk::u8encode("영광이옵니다."), prev);
                        pk::message_box(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x(이)가 칭호 {}를 유지합니다.", pk::u8decode(pk::get_name(prev)), 칭호_이름[0])));
                    }
                }
            }

            pk::message_box(pk::u8encode("이것으로 대회를 폐하겠소."), Emperor);
            pk::play_se(6);
            pk::message_box(pk::u8encode("대회에 참가한 모든 무장의 통솔과 무력 경험치가 상승했습니다."));
            for (int i = 0; i < backUpArray.length; ++i)
            {
                pk::person@ p = backUpArray[i];
                p.stat_exp[무장능력_통솔] = p.stat_exp[무장능력_통솔] + 헌제_대회_경험치;
                p.stat_exp[무장능력_무력] = p.stat_exp[무장능력_무력] + 헌제_대회_경험치;
            }
            SetCompetitionWinner(winner.get_id(), 대회_무술);
            pk::history_log(winner.get_pos(), pk::get_force(winner.get_force_id()).color, pk::u8encode(pk::format("\x1b[2x{}\x1b[0x, \x1b[1x무술대회\x1b[0x 우승", pk::u8decode(pk::get_name(winner)))));
            // 퇴장 
            pk::fade(0);
            pk::sleep();
            pk::background(-1);
            pk::fade(255);
        }

        void RunDuelCompetition(pk::list<pk::person@> personList, pk::person@ &winner, pk::person@ &runnerUp, bool isSingleCompetition)
        {
            // 4세력 2무장일 경우 순번을 섞어준다
            if (4 == validForceCount)
            {
                pk::person@ temp = personList[7];
                @personList[7] = personList[1];
                @personList[1] = temp;

                @temp = personList[5];
                @personList[5] = personList[3];
                @personList[3] = temp;

                @temp = personList[7];
                @personList[7] = personList[5];
                @personList[5] = temp;
            }

            pk::person@ moo = pk::get_person(무장_병사);
            int remain = personList.count;
            int round = 1;

            while (remain > 2)
            {
                pk::list<pk::person@> list;
                int n = 1;

                for (int i = 0; i < personList.count; ++i)
                {
                    pk::person@ p1 = personList[i];
                    pk::person@ p2 = personList[i + 1];
                    pk::message_box(pk::u8encode(pk::format("{}회전 {}경기에 참가할 무장은 \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x님 입니다.", round, n, pk::u8decode(pk::get_name(p1)), pk::u8decode(pk::get_name(p2)))), moo);
                    bool c1 = false;                            // 무장1 조종여부
                    bool c2 = false;                            // 무장2 조종여부
                    bool skip = false;

                    if (true == isSingleCompetition)
                    {
                        skip = true;
                    }
                    else if (true == personList[i].is_player() && true == personList[i + 1].is_player())
                    {
                        skip = true;
                    }

                    if (false == skip)
                    {
                        if (true == personList[i].is_player())
                        {
                            c1 = pk::yes_no(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x의 경기를 직접 조종하시겠습니까?", pk::u8decode(pk::get_name(personList[i])))));
                        }

                        if (true == personList[i + 1].is_player())
                        {
                            c2 = pk::yes_no(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x의 경기를 직접 조종하시겠습니까?", pk::u8decode(pk::get_name(personList[i + 1])))));
                        }
                    }
                                                                                        // 1 조종, 2 조종, 관전선택여부
                    pk::int_bool win = pk::duel(null, null, p1, null, null, p2, null, null, c1, c2, 0, true);
                    list.add(personList[i + win.first]);
                    pk::play_se(6);
                    pk::message_box(pk::u8encode(pk::format("{}경기 승자는 \x1b[2x{}\x1b[0x입니다.", n, pk::u8decode(pk::get_name(personList[i + win.first])))));

                    i = i + 1;
                    n = n + 1;
                }

                personList.clear();
                personList = list;
                remain = personList.count;
                round++;
            }

            pk::message_box(pk::u8encode(pk::format("결승은 \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x님의 경기입니다.", pk::u8decode(pk::get_name(personList[0])), pk::u8decode(pk::get_name(personList[1])))), moo);
            
            bool c1 = false;                            // 무장1 조종여부
            bool c2 = false;                            // 무장2 조종여부
            bool skip = false;

            if (true == isSingleCompetition)
            {
                skip = true;
            }
            else if (true == personList[0].is_player() && true == personList[1].is_player())
            {
                skip = true;
            }

            if (false == skip)
            {
                if (true == personList[0].is_player())
                {
                    c1 = pk::yes_no(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x의 경기를 직접 조종하시겠습니까?", pk::u8decode(pk::get_name(personList[0])))));
                }

                if (true == personList[1].is_player())
                {
                    c2 = pk::yes_no(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x의 경기를 직접 조종하시겠습니까?", pk::u8decode(pk::get_name(personList[1])))));
                }
            }
                                                                                                        // 1 조종, 2 조종,   관전여부
            pk::int_bool win = pk::duel(null, null, personList[0], null, null, personList[1], null, null, c1, c2, 0, true);

            @winner = personList[win.first];
            @runnerUp = personList[(win.first + 1) % 2];
        }


        // 설전대회 씬
        void EloquenceCompetitionScene()
        {
            pk::person@ Emperor = pk::get_person(pk::get_scenario().emperor);
            array<pk::force@> forceArray = GetParticipatingForceArray(대회_설전);

            string ment0 = pk::format("\x1b[2x설전대회\x1b[0x를 개최하도록 하겠소. 참가하는 세력은 \x1b[2x{}\x1b[0x,", pk::u8decode(pk::get_name(forceArray[0])));
            pk::person@ winner = null;
            pk::person@ runnerUp = null;

            pk::message_box(pk::u8encode("황제로부터 \x1b[2x설전대회\x1b[0x를 개최한다는 칙서가 내려왔습니다."));
            pk::move_screen(Emperor.get_pos());

            pk::fade(0);
            pk::sleep();
            pk::background(1);
            pk::fade(255);

            if (4 == validForceCount)
            {
                ment0 = ment0 + pk::format(" \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x의 세력이오", pk::u8decode(pk::get_name(forceArray[1])), pk::u8decode(pk::get_name(forceArray[2])), pk::u8decode(pk::get_name(forceArray[3])));
                pk::message_box(pk::u8encode(ment0), Emperor);
            }
            else if (8 == validForceCount)
            {
                string ment1 = pk::format("\x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x", pk::u8decode(pk::get_name(forceArray[1])), pk::u8decode(pk::get_name(forceArray[2])), pk::u8decode(pk::get_name(forceArray[3])), pk::u8decode(pk::get_name(forceArray[4])), pk::u8decode(pk::get_name(forceArray[5])), pk::u8decode(pk::get_name(forceArray[6])), pk::u8decode(pk::get_name(forceArray[7])));
                pk::message_box(pk::u8encode(ment0), Emperor);
                ment1 = ment1 + "의 세력이오";
                pk::message_box(pk::u8encode(ment1), Emperor);
            }
            else if (16 == validForceCount)
            {
                string ment1 = pk::format("\x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x", pk::u8decode(pk::get_name(forceArray[1])), pk::u8decode(pk::get_name(forceArray[2])), pk::u8decode(pk::get_name(forceArray[3])), pk::u8decode(pk::get_name(forceArray[4])), pk::u8decode(pk::get_name(forceArray[5])), pk::u8decode(pk::get_name(forceArray[6])), pk::u8decode(pk::get_name(forceArray[7])));
                pk::message_box(pk::u8encode(ment0), Emperor);
                pk::message_box(pk::u8encode(ment1), Emperor);
                ment1 = pk::format("그리고 \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x의 세력이오", pk::u8decode(pk::get_name(forceArray[8])), pk::u8decode(pk::get_name(forceArray[9])), pk::u8decode(pk::get_name(forceArray[10])), pk::u8decode(pk::get_name(forceArray[11])), pk::u8decode(pk::get_name(forceArray[12])), pk::u8decode(pk::get_name(forceArray[13])), pk::u8decode(pk::get_name(forceArray[14])), pk::u8decode(pk::get_name(forceArray[15])));
                pk::message_box(pk::u8encode(ment1), Emperor);
            }

            int requireCount = 1;

            if (4 == validForceCount)
            {
                requireCount = 2;
            }

            // 참가무장 선발
            for (int i = 0; i < forceArray.length; ++i)
            {
                auto list = GetCompetitionPersonList(forceArray[i], 대회_설전, false);
                auto validList = GetSortedCompetitionPersonList(list, 무장능력_지력);

                if (false == forceArray[i].is_player())
                {
                    for (int i = 0; i < requireCount; ++i)
                    {
                        competitonParticipantList.add(validList[i]);
                    }
                }
                else
                {
                    pk::message_box(pk::u8encode("설전대회에 참가할 무장을 선택해주십시오."));
                    pk::list<pk::person@> person_sel = pk::person_selector(pk::u8encode("무장 선택"), pk::u8encode("설전대회에 참가할 무장을 선택합니다.)"), validList, requireCount, requireCount);
                    if (person_sel.count <= 0)
                    {
                        pk::message_box(pk::u8encode("무장을 선택을 취소했습니다. 자동으로 무장이 선택됩니다."));
                        
                        for (int i = 0; i < requireCount; ++i)
                        {
                            competitonParticipantList.add(validList[i]);
                        }
                    }
                    else
                    {
                        for (int i = 0; i < requireCount; ++i)
                        {
                            competitonParticipantList.add(person_sel[i]);
                        }
                    }
                }
            }

            pk::fade(0);
            pk::sleep();
            pk::background(37);
            pk::fade(255);

            array<pk::person@> backUpArray = pk::list_to_array(competitonParticipantList);
            RunEloquenceCompetition(competitonParticipantList, winner, runnerUp, false);

            string title = "";
            if (winner.sex == 성별_남)
            {
                title = "\x1b[1x재사\x1b[0x";
            }
            else if (winner.sex == 성별_여)
            {
                title = "\x1b[1x재원\x1b[0x이";
            }
            AddCompetitionCount(winner, 대회_설전);
            pk::fade(0);
            pk::sleep();
            pk::background(19);
            pk::fade(255);
            pk::play_se(10);
            pk::message_box(pk::u8encode(pk::format("우승자는 \x1b[2x{}\x1b[0x인가. 그대야말로 당대의 {}로다. 우승을 축하하오.", pk::u8decode(pk::get_name(winner)), title)), Emperor);
            pk::message_box(pk::u8encode("이건 내가 그대에게 내리는 포상이오."), Emperor);
            pk::message_box(pk::u8encode("영광이옵니다."), winner);
            pk::add_tp(pk::get_force(winner.get_force_id()), 우승_기교 * 2, Emperor.get_pos());
            pk::add_kouseki(winner, 우승_공적);
            pk::message_box(pk::u8encode(pk::format("\x1b[2x기교\x1b[0x \x1b[1x{}\x1b[0x을 받고 그 명성으로 \n\x1b[2x공적\x1b[0x이 \x1b[1x{}\x1b[0x만큼 올랐습니다.", 우승_기교, 우승_공적)));
            pk::message_box(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x에게도 포상을 내리겠소.", pk::u8decode(pk::get_name(runnerUp)))), Emperor);
            pk::message_box(pk::u8encode("영광이옵니다."), runnerUp);
            pk::add_tp(pk::get_force(runnerUp.get_force_id()), 준우승_기교 * 2, Emperor.get_pos());
            pk::add_kouseki(runnerUp, 준우승_공적);
            pk::message_box(pk::u8encode(pk::format("\x1b[2x기교\x1b[0x \x1b[1x{}\x1b[0x을 받고 그 명성으로 \n\x1b[2x공적\x1b[0x이 \x1b[1x{}\x1b[0x만큼 올랐습니다.", 준우승_기교, 준우승_공적)));
            if (!HasTitle(winner))
            {
                if (GetCompetitionWinnerId(대회_무술) == winner.get_id() && IsEmptyTitle(2))
                {
                    // 국사무쌍
                    pk::play_se(10);
                    pk::message_box(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x. 그대의 용맹과 지모는 온 나라에 비견할 자가 없소. 그대야말로 진정한 {}이오.", pk::u8decode(pk::get_name(winner)), 칭호_이름[2])), Emperor);
                    pk::message_box(pk::u8encode("분에 넘치는 영광이옵니다."), winner);
                    pk::message_box(pk::u8encode(pk::format("무예와 지혜를 모두 뽐낸 \x1b[2x{}\x1b[0x에게 칭호 {}이 부여됩니다.", pk::u8decode(pk::get_name(winner)), 칭호_이름[2])));
                    pk::history_log(winner.get_pos(), pk::get_force(winner.get_force_id()).color, pk::u8encode(pk::format("\x1b[2x{}\x1b[0x, \x1b[1x국사무쌍\x1b[0x", pk::u8decode(pk::get_name(winner)))));
                    SetTitle(winner, 2);
                }

                if (GetCompetitionCount(winner, 대회_설전) >= 3)
                {
                    pk::person@ prev;
                    bool is_achieve = false;
                    // 천하기재
                    if (IsEmptyTitle(1))
                    {
                        is_achieve = true;
                    }
                    else
                    {
                        @prev = pk::get_person(titleArray[1]);

                        if (prev.mibun == 신분_포로)
                        {
                            pk::message_box(pk::u8encode(pk::format("이전의 {}가 포로 상태이므로 도전이 발생하지 않습니다.", 칭호_이름[1])));
                            is_achieve = true;
                        }
                        else
                        {
                            // 도전 결투
                            pk::message_box(pk::u8encode(pk::format("{} \x1b[2x{}\x1b[0x에게 \x1b[2x{}\x1b[0x(이)가 도전합니다.", 칭호_이름[1], pk::u8decode(pk::get_name(prev)), pk::u8decode(pk::get_name(winner)))));

                            bool c1 = false;                            // 무장1 조종여부
                            bool c2 = false;                            // 무장2 조종여부
                            bool skip = false;

                            if (true == winner.is_player() && true == prev.is_player())
                            {
                                skip = true;
                            }

                            if (false == skip)
                            {
                                if (true == prev.is_player())
                                {
                                    c1 = pk::yes_no(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x의 설전을 직접 조종하시겠습니까?", pk::u8decode(pk::get_name(prev)))));
                                }

                                if (true == winner.is_player())
                                {
                                    c2 = pk::yes_no(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x의 설전을 직접 조종하시겠습니까?", pk::u8decode(pk::get_name(winner)))));
                                }
                            }

                            pk::int_int_bool win = pk::debate(prev, winner, c1, c2, false, true);

                            if (win.first != 0)
                            {
                                is_achieve = true;
                            }
                        }
                    }

                    if (is_achieve)
                    {
                        pk::play_se(10);
                        pk::message_box(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x. 그대의 이름을 온 천하가 알고있네. 그대야말로 진정한 {}로군.", pk::u8decode(pk::get_name(winner)), 칭호_이름[1])), Emperor);
                        pk::message_box(pk::u8encode("분에 넘치는 영광이옵니다."), winner);
                        pk::message_box(pk::u8encode(pk::format("설전대회에서 뛰어난 기록을 세운 \x1b[2x{}\x1b[0x에게 칭호 {}이 부여됩니다.", pk::u8decode(pk::get_name(winner)), 칭호_이름[1])));
                        pk::history_log(winner.get_pos(), pk::get_force(winner.get_force_id()).color, pk::u8encode(pk::format("\x1b[2x{}\x1b[0x, \x1b[1x천하기재\x1b[0x", pk::u8decode(pk::get_name(winner)))));
                        SetTitle(winner, 1);
                    }
                    else
                    {
                        pk::play_se(10);
                        pk::message_box(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x의 지모는 여전하군. 그대가 진정한 {}로다.", pk::u8decode(pk::get_name(prev)), 칭호_이름[1])), Emperor);
                        pk::message_box(pk::u8encode("영광이옵니다."), prev);
                        pk::message_box(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x(이)가 칭호 {}를 유지합니다.", pk::u8decode(pk::get_name(prev)), 칭호_이름[1])));
                    }
                }
            }
            pk::message_box(pk::u8encode("이것으로 대회를 폐하겠소."), Emperor);
            pk::play_se(6);
            pk::message_box(pk::u8encode("대회에 참가한 모든 무장의 지력과 정치 경험치가 상승했습니다."));
            for (int i = 0; i < backUpArray.length; ++i)
            {
                pk::person@ p = backUpArray[i];
                p.stat_exp[무장능력_지력] = p.stat_exp[무장능력_지력] + 헌제_대회_경험치;
                p.stat_exp[무장능력_정치] = p.stat_exp[무장능력_정치] + 헌제_대회_경험치;
            }
            SetCompetitionWinner(winner.get_id(), 대회_설전);
            pk::history_log(winner.get_pos(), pk::get_force(winner.get_force_id()).color, pk::u8encode(pk::format("\x1b[2x{}\x1b[0x, \x1b[1x설전대회\x1b[0x 우승", pk::u8decode(pk::get_name(winner)))));

            // 퇴장 
            pk::fade(0);
            pk::sleep();
            pk::background(-1);
            pk::fade(255);
        }

        void RunEloquenceCompetition(pk::list<pk::person@> personList, pk::person@& winner, pk::person@& runnerUp, bool isSingleCompetition)
        {
            // 4세력 2무장일 경우 순번을 섞어준다
            if (4 == validForceCount)
            {
                pk::person@ temp = personList[7];
                @personList[7] = personList[1];
                @personList[1] = temp;

                @temp = personList[5];
                @personList[5] = personList[3];
                @personList[3] = temp;

                @temp = personList[7];
                @personList[7] = personList[5];
                @personList[5] = temp;
            }

            pk::person@ moo = pk::get_person(무장_문관);
            int remain = personList.count;
            int round = 1;

            while (remain > 2)
            {
                pk::list<pk::person@> list;
                int n = 1;

                for (int i = 0; i < personList.count; ++i)
                {
                    pk::person@ p1 = personList[i];
                    pk::person@ p2 = personList[i + 1];
                    pk::message_box(pk::u8encode(pk::format("{}회전 {}경기에 참가할 무장은 \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x님 입니다.", round, n, pk::u8decode(pk::get_name(p1)), pk::u8decode(pk::get_name(p2)))), moo);
                    bool c1 = false;                            // 무장1 조종여부
                    bool c2 = false;                            // 무장2 조종여부
                    bool skip = false;

                    if (true == isSingleCompetition)
                    {
                        skip = true;
                    }
                    else if (true == personList[i].is_player() && true == personList[i + 1].is_player())
                    {
                        skip = true;
                    }

                    if (false == skip)
                    {
                        if (true == personList[i].is_player())
                        {
                            c1 = pk::yes_no(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x의 설전을 직접 조종하시겠습니까?", pk::u8decode(pk::get_name(personList[i])))));
                        }

                        if (true == personList[i + 1].is_player())
                        {
                            c2 = pk::yes_no(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x의 설전을 직접 조종하시겠습니까?", pk::u8decode(pk::get_name(personList[i + 1])))));
                        }
                    }
                                                       // 1 조종, 2 조종, 관전선택여부
                    pk::int_int_bool win = pk::debate(p1, p2, c1, c2, false, true);
                    list.add(personList[i + win.first]);
                    pk::play_se(6);
                    pk::message_box(pk::u8encode(pk::format("{}경기 승자는 \x1b[2x{}\x1b[0x입니다.", n, pk::u8decode(pk::get_name(personList[i + win.first])))));

                    i = i + 1;
                    n = n + 1;
                }

                personList.clear();
                personList = list;
                remain = personList.count;
                round++;
            }

            pk::message_box(pk::u8encode(pk::format("결승은 \x1b[2x{}\x1b[0x, \x1b[2x{}\x1b[0x님의 경기입니다.", pk::u8decode(pk::get_name(personList[0])), pk::u8decode(pk::get_name(personList[1])))), moo);

            bool c1 = false;                            // 무장1 조종여부
            bool c2 = false;                            // 무장2 조종여부

            bool skip = false;

            if (true == isSingleCompetition)
            {
                skip = true;
            }
            else if (true == personList[0].is_player() && true == personList[1].is_player())
            {
                skip = true;
            }

            if (false == skip)
            {
                if (true == personList[0].is_player())
                {
                    c1 = pk::yes_no(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x의 설전을 직접 조종하시겠습니까?", pk::u8decode(pk::get_name(personList[0])))));
                }

                if (true == personList[1].is_player())
                {
                    c2 = pk::yes_no(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x의 설전을 직접 조종하시겠습니까?", pk::u8decode(pk::get_name(personList[1])))));
                }
            }
                                                                      // 1 조종, 2 조종,   관전여부
            pk::int_int_bool win = pk::debate(personList[0], personList[1], c1, c2, false, true);

            @winner = personList[win.first];
            @runnerUp = personList[(win.first + 1) % 2];
        }



        // 추첨한 참가국 받아오기
        array<pk::force@> GetParticipatingForceArray(int type)
        {
            array<pk::force@> forceArray(validForceCount);

            int count = 0;

            // 개최국(황제 보호세력)이 참가 요건에 해당되면 개최국 자격으로 참가
            if (hostForce != null)
            {
                @forceArray[0] = hostForce;
                count = 1;
            }

            pk::list<pk::force@> validList;

            for (int i = 0; i < validPlayerCompetitonList.count; ++i)
            {
                pk::force@ force = validPlayerCompetitonList[i];
                validList.add(force);
            }

            int validListCount = validList.count;

            // 플레이어 세력이 무조건 참가하게되는 경우
            if (대회_무술 == type && true == 플레이어_무술대회_참여여부)
            {
                validAICompetitionList.shuffle();

                for (int i = 0; i < (validForceCount - count) - validListCount; ++i)
                {
                    pk::force@ force = validAICompetitionList[i];
                    validList.add(force);
                }
            }
            else if (대회_설전 == type && true == 플레이어_설전대회_참여여부)
            {
                validAICompetitionList.shuffle();

                for (int i = 0; i < (validForceCount - count) - validListCount; ++i)
                {
                    pk::force@ force = validAICompetitionList[i];
                    validList.add(force);
                }
            }
            // 그렇지 않은 경우
            else
            {
                for (int i = 0; i < validAICompetitionList.count; ++i)
                {
                    pk::force@ force = validAICompetitionList[i];
                    validList.add(force);
                }
            }

            validList.shuffle();

            for (int i = 0; i < validForceCount - count; ++i)
            {
                @forceArray[i + count] = validList[i];
            }

            return forceArray;
        }

        // 참가자격
        bool IsExistQualification(pk::force@ force, int competitionType, int participateType)
        {
            pk::list<pk::person@> personList;
            if (participateType <= 대회_4강)
            {
                personList = pk::get_person_list(force, pk::mibun_flags(신분_군주, 신분_도독, 신분_태수, 신분_일반));
            }
            else
            {
                personList = pk::get_person_list(force, pk::mibun_flags(신분_도독, 신분_태수, 신분_일반));
            }
            int count = 0;

            for (int i = 0; i < personList.count; ++i)
            {
                pk::person@ person = personList[i];

                if (대회_무술 == competitionType)
                {
                    if (true == person.is_alive())
                    {
                        if (person.stat[무장능력_무력] >= 대회_무력제한)
                        {
                            // 황제가 여는 8세력 이상 대회면 바로 반환
                            if (대회_8강이상 == participateType)
                            {
                                return true;
                            }
                            else
                            {
                                count++;
                            }
                        }
                    }
                }
                else if (대회_설전 == competitionType)
                {
                    if (true == person.is_alive())
                    {
                        if (person.stat[무장능력_지력] >= 대회_지력제한)
                        {
                            // 황제가 여는 8세력 이상 대회면 바로 반환
                            if (대회_8강이상 == participateType)
                            {
                                return true;
                            }
                            else
                            {
                                count++;
                            }
                        }
                    }
                }
            }

            if (대회_4강 == participateType)
            {
                if (count >= 2)
                {
                    return true;
                }
            }

            if (대회_자세력 == participateType)
            {
                if (count >= 8)
                {
                    return true;
                }
            }

            return false;
        }
        
        pk::list<pk::person@> GetCompetitionPersonList(pk::force@ force, int competitionType, bool isSingleCompetition)
        {
            pk::list<pk::person@> list;
            
            if (false == isSingleCompetition)
            {
                list = pk::get_person_list(force, pk::mibun_flags(신분_군주, 신분_도독, 신분_태수, 신분_일반));
            }
            else
            {
                list = pk::get_person_list(force, pk::mibun_flags(신분_도독, 신분_태수, 신분_일반));
            }

            pk::list<pk::person@> validList;

            for (int i = 0; i < list.count; ++i)
            {
                if (대회_무술 == competitionType)
                {
                    if (list[i].stat[무장능력_무력] >= 대회_무력제한)
                    {
                        validList.add(list[i]);
                    }
                }
                else if (대회_설전 == competitionType)
                {
                    if (list[i].stat[무장능력_지력] >= 대회_지력제한)
                    {
                        validList.add(list[i]);
                    }
                }
            }

            return validList;
        }

        // 삽입정렬. AI의 참가무장 선별 및 무장선택 화면에 무장 정렬에 사용됨
        pk::list<pk::person@> GetSortedCompetitionPersonList(pk::list<pk::person@> personList, int ability)
        {
            if (personList.count > 1)
            {
                for (int i = 1; i < personList.count; ++i)
                {
                    for (int j = i; j > 0; j--)
                    {
                        if (GetCompetitionValue(personList[j], ability) > GetCompetitionValue(personList[j - 1], ability))
                        {
                            pk::person@ temp = personList[j];
                            @personList[j] = personList[j - 1];
                            @personList[j - 1] = temp;
                        }
                        else
                        {
                            break;
                        }
                    }
                }
            }

            return personList;
        }

        int GetCompetitionValue(pk::person@ person, int ability)
        {
            int id = person.get_id();
            int value = 0;
       
            if (무장능력_무력 == ability)
            {
                value = person.stat[ability];

                if (id == 무장_여포 || id == 무장_관우 || id == 무장_장비 || id == 무장_조운 || id == 무장_마초 || id == 무장_허저)
                {
                    value = value + GetAddedForce(id);
                }
                // 황충의 부가무력은 시나리오 사실 여부, 나이에 따라 달라짐
                else if (id == 무장_황충)
                {
                    if (true == pk::get_scenario().virtual)
                    {
                        value = value + 5;
                    }
                    else
                    {
                        int age = pk::get_age(person);

                        if (age < 60)
                        {
                            value = value + 1;
                        }
                        else if (age < 65)
                        {
                            value = value + 2;
                        }
                        else if (age < 70)
                        {
                            value = value + 3;
                        }
                        else if (age < 80)
                        {
                            value = value + 4;
                        }
                        else if (age < 90)
                        {
                            value = value + 5;
                        }
                        else
                        {
                            value = value + 10;
                        }
                    }
                }

                value = value + GetAddedItemValue(id);
            }
            else if (무장능력_지력 == ability)
            {
                value = person.stat[ability];

                // 성격 체크
                int character = person.character;

                if (성격_대담 == character)
                {
                    value = value + 설전_대담;
                }
                else if (성격_소심 == character)
                {
                    value = value + 설전_소심;
                }
                else if (성격_저돌 == character)
                {
                    value = value + 설전_저돌;
                }
                else if (성격_냉정 == character)
                {
                    value = value + 설전_냉정;
                }

                if (true == IsBook(id))
                {
                    value = value + 설전_궤변 + 설전_대갈 + 설전_진정 + 설전_무시 + 설전_흥분;
                }
                else
                {
                    // 궤변 체크
                    if (true == person.wajutsu_kiben)
                    {
                        value = value + 설전_궤변;
                    }
                    // 대갈 체크
                    if (true == person.wajutsu_daikatsu)
                    {
                        value = value + 설전_대갈;
                    }
                    // 진정 체크
                    if (true == person.wajutsu_chinsei)
                    {
                        value = value + 설전_진정;
                    }
                    // 무시 체크
                    if (true == person.wajutsu_mushi)
                    {
                        value = value + 설전_무시;
                    }
                    // 흥분 체크
                    if (true == person.wajutsu_gyakujou)
                    {
                        value = value + 설전_흥분;
                    }
                }
            }
            else
            {
                return -1;
            }

            return value;
        }

        // 부가무력 받아오기
        int GetAddedForce(int moo)
        {
            for (int i = 0; i < 부가무력_무장.length; ++i)
            {
                if (부가무력_무장[i] == moo)
                {
                    return 부가무력_수치[i];
                }
            }

            return 0;
        }

        // 무기 점수 받아오기
        int GetAddedItemValue(int moo)
        {
            int longWeapon = 0;
            int swordWeapon = 0;
            int bowWeapon = 0;
            int secretWeapon = 0;

            for (int i = 0; i < 보물_끝; ++i)
            {
                pk::item@ item = pk::get_item(i);
                
                if (item.owner == moo)
                {
                    switch (item.type)
                    {
                    case 보물종류_검 :
                        swordWeapon = 검_점수;
                        break;

                    case 보물종류_긴무기:
                        longWeapon = 긴무기_점수;
                        break;

                    case 보물종류_암기:
                        secretWeapon = 암기_점수;
                        break;

                    case 보물종류_활:
                        bowWeapon = 활_점수;
                        break;
                    }
                }
            }

            return longWeapon + swordWeapon + bowWeapon + secretWeapon;
        }

        // 서적 보유 유무 받아오기
        bool IsBook(int moo)
        {
            for (int i = 0; i < 보물_끝; ++i)
            {
                pk::item@ item = pk::get_item(i);

                if (item.owner == moo)
                {
                    if (item.type == 보물종류_서책)
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        void SetCompetitionWinner(int moo, int type)
        {
            //pk::point point = competitionDataArray[type];
            //pk::building@ data = pk::get_building(point);

            competitionDataArray[type] = moo;
        }

        int GetCompetitionWinnerId(int type)
        {
            //pk::point point = competitionDataArray[type];
            //pk::building@ data = pk::get_building(point);

            int id = competitionDataArray[type];

            pk::person@ p = pk::get_person(id);

            if (null == p || false == p.is_alive())
            {
                return -1;
            }
            else
            {
                return id;
            }
        } 

        void SetSingleCompetitionWinner(int forceId, int moo)
        {
            //pk::point point = singleCompetitionDataArray[forceId];
            //pk::building@ data = pk::get_building(point);

            if (moo == -1)
            {
                singleCompetitionDataArray[forceId] = moo;
            }
            else
            {
                singleCompetitionDataArray[forceId] = moo + 10000;
            }
        }

        int GetSingleCompetitionWinnerId(int forceId)
        {
            //pk::point point = singleCompetitionDataArray[forceId];
            //pk::building@ data = pk::get_building(point);

            int id = singleCompetitionDataArray[forceId];
            
            if (id >= 10000 && id < 20000)
            {
                return  id - 10000;
            }
            else
            {
                return -1;
            }
        }

        bool IsHoldCompetition(int forceId)
        {
            //pk::point point = singleCompetitionDataArray[forceId];
            //pk::building@ data = pk::get_building(point);

            int id = singleCompetitionDataArray[forceId];

            if (id >= 10000 && id < 20000)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        void ResetSingleCompetitionWinner()
        {
            auto forceArray = pk::list_to_array(pk::get_force_list());

            for (int i = 0; i < forceArray.length; ++i)
            {
                pk::force@ force = forceArray[i];

                if (true == IsValidForce(force))
                {
                    SetSingleCompetitionWinner(i, -1);
                }
            }
        }

        // 천하무쌍, 무술 특전
        void ExecuteDuelPrivillage(pk::unit@ unit, bool isTitle)
        {
            if (false == 우승자_특전여부)
            {
                return;
            }

            // 상태이상인 경우 패스
            if (부대상태_통상 != unit.status)
            {
                return;
            }
            int winner;

            if(isTitle)
                winner = titleArray[0];
            else
            {
                winner = GetCompetitionWinnerId(대회_무술);
                if (winner == titleArray[0])
                    return;
            }

            if (-1 == winner)
            {
                return;
            }
            
            // 대회 우승자가 부대에 없으면 패스
            if (unit.member[0] != winner && unit.member[1] != winner && unit.member[2] != winner)
            {
                return;
            }

            pk::add_energy(unit, 무술대회특전_기력회복값, true);

            bool success = false;

            array<pk::point> arr = pk::range(unit.get_pos(), 1, 무술대회특전_최대사거리);

            int actor = winner;

            int src_int = unit.attr.stat[부대능력_무력];

            pk::list<pk::unit@> unitList;

            for (int i = 0; i < arr.length; ++i)
            {
                pk::unit@ dst = pk::get_unit(arr[i]);

                if (dst == null || !pk::is_enemy(unit, dst))
                {
                    continue;
                }
                else
                {
                    if (dst.status == 부대상태_통상)
                    {
                        unitList.add(dst);
                    }
                }
            }

            if (unitList.count == 0)
            {
                return;
            }

            unitList.shuffle();

            if (true == pk::rand_bool(대회특전_계략실행확률))
            {
                pk::unit@ dst = unitList[0];
                int dst_int = dst.attr.stat[부대능력_무력];

                int b = data_3b2314(pk::get_person(dst.leader).character);
                int c = dst.attr.stat[부대능력_방어] / 20;

                int d = src_int * 3 / 10 - dst_int / 5;
                d += b;
                d += c;

                int e = d + 70;

                int f = 100;
                f -= dst_int * 9 / 10;
                f *= src_int * src_int * 100;
                f /= dst_int * dst_int + src_int * src_int;
                f /= 45;
                f -= (100 - src_int) / 10;

                f += b;
                f += c;
                if (src_int < dst_int) f -= (dst_int - src_int) / 3;
                if (f < 1) f = 1;

                int n = pk::max(1, pk::min(99, e, f));

                // 계략성공
                if (true == pk::rand_bool(n))
                {
                    // 시전부대 대사
                    PrintPrivilageMessage(unit, actor, isTitle);
                    // 대상 부대 상태이상
                    pk::set_status(dst, null, 부대상태_위보, 1, true);
                }
            }
        }

        /** 성격에 따른 허보 상수(무력) */
        int data_3b2314(int character)
        {
            switch (character)
            {
            case 성격_소심: return 3;
            case 성격_냉정: return 1;
            case 성격_대담: return 0;
            case 성격_저돌: return -2;
            }
            return 0;
        }

        void PrintPrivilageMessage(pk::unit@ unit, int actorId, bool isTitle)
        {
            pk::person@ moo = pk:: get_person(actorId);

            int r = pk::rand(2);

            if (r == 0)
            {
                if(isTitle)
                    pk::say(pk::u8encode("내가 바로 천하무쌍이다!"), moo, unit);
                else
                    pk::say(pk::u8encode("단숨에 쓸어버려라!"), moo, unit);
            }
            else
            {
                if (actorId == 무장_장료)
                {
                    pk::say(pk::u8encode("장료가 왔다!"), moo, unit);
                }
                else if (actorId == 무장_감녕)
                {
                    pk::say(pk::u8encode("하하하! 화려하게 날뛰어 볼까!"), moo, unit);
                }
                else if (actorId == 무장_관우)
                {
                    pk::say(pk::u8encode("너희는 나를 막을 수 없으리라!"), moo, unit);
                }
                else
                {
                    pk::say(pk::u8encode("나와 맞설자 누구냐!"), moo, unit);
                }
            }
        }

        void PrintVictimMessage(pk::unit@ unit, pk::person@ moo, bool gap)
        {
            if (gap == true)
            {
                switch (pk::rand(3))
                {
                case 0: pk::say(pk::u8encode("크윽..."), moo, unit);
                    break;

                case 1: pk::say(pk::u8encode("이럴수가..."), moo, unit);
                    break;

                case 2: pk::say(pk::u8encode("어떻게든 해야한다..."), moo, unit);
                    break;
                }
            }
            else
            {
                switch (pk::rand(3))
                {
                case 0: pk::say(pk::u8encode("다들 정신차려라!"), moo, unit);
                    break;

                case 1: pk::say(pk::u8encode("당황하지마라!"), moo, unit);
                    break;

                case 2: pk::say(pk::u8encode("두고보자..."), moo, unit);
                    break;
                }
            }
        }

        // 천하기재, 설전 특전
        void ExecuteEloquencePrivillage(pk::unit@ unit, bool isTitle)
        {
            if (false == 우승자_특전여부)
            {
                return;
            }

            // 상태이상인 경우 패스
            if (부대상태_통상 != unit.status)
            {
                return;
            }

            int winner;

            if(isTitle)
                winner = titleArray[1];
            else
            {
                winner = GetCompetitionWinnerId(대회_설전);
                if (winner == titleArray[1])
                {
                    return;
                }
            }
            if (-1 == winner)
            {
                return;
            }

            // 대회 우승자가 부대에 없으면 패스
            if (unit.member[0] != winner && unit.member[1] != winner && unit.member[2] != winner)
            {
                return;
            }

            pk::add_energy(unit, 설전대회특전_기력회복값, true);

            bool success = false;

            array<pk::point> arr = pk::range(unit.get_pos(), 1, 설전대회특전_최대사거리);

            int actor = winner;

            int src_int = unit.attr.stat[부대능력_지력];

            pk::list<pk::unit@> unitList;

            for (int i = 0; i < arr.length; ++i)
            {
                pk::unit@ dst = pk::get_unit(arr[i]);

                if (dst == null || !pk::is_enemy(unit, dst))
                {
                    continue;
                }
                else
                {
                    if (dst.status == 부대상태_통상)
                    {
                        unitList.add(dst);
                    }
                }
            }

            if (unitList.count == 0)
            {
                return;
            }
            
            unitList.shuffle();

            if (true == pk::rand_bool(대회특전_계략실행확률))
            {
                pk::unit@ dst = unitList[0];
                int dst_int = dst.attr.stat[부대능력_지력];

                int b = data_849b14(pk::get_person(dst.leader).character);
                int c = dst.attr.stat[부대능력_방어] / 20;

                int d = src_int * 3 / 10 - dst_int / 5;
                d += b;
                d += c;

                int e = d + 70;

                int f = 100;
                f -= dst_int * 9 / 10;
                f *= src_int * src_int * 100;
                f /= dst_int * dst_int + src_int * src_int;
                f /= 45;
                f -= (100 - src_int) / 10;

                f += b;
                f += c;
                if (src_int < dst_int) f -= (dst_int - src_int) / 3;
                if (f < 1) f = 1;

                int n = pk::max(1, pk::min(99, e, f));

                // 계략성공
                if (true == pk::rand_bool(n))
                {
                    // 시전부대 대사
                    pk::say(pk::u8encode("잠시 내 말좀 들어보시오."), pk::get_person(actor), unit);
                    // 대상 부대 상태이상
                    pk::set_status(dst, null, 부대상태_혼란, 1, true);
                }
            }
        }

        /** 성격에 따른 교란 상수 */
        int data_849b14(int character)
        {
            switch (character)
            {
            case 성격_소심: return -2;
            case 성격_냉정: return 0;
            case 성격_대담: return 1;
            case 성격_저돌: return 3;
            }
            return 0;
        }

        void ExecuteSingleCompetitionPrivilage(pk::unit@ unit)
        {
            int forceId = unit.get_force_id();
            
            pk::force@ force = pk::get_force(forceId);

            if(false == IsValidForce(force))
            {
                return;
            }

            int moo = GetSingleCompetitionWinnerId(forceId);

            if (-1 == moo)
            {
                return;
            }

            if (unit.member[0] != moo && unit.member[1] != moo && unit.member[2] != moo)
            {
                return;
            }

            pk::add_energy(unit, 자체대회특전_기력회복 ,true);
        }

        // 자세력 내 대회 계최가 가능한지 확인하는 데이터  // -1 : 황건, 012 : 개최가능,  3 : 한황실 대회 개최가능, 4 : 작위부족 , 5 : 이미 대회를 개최함,  6 : 기교 부족, 7 : 금 부족, 8 : 장수부족
        int GetPossibleHoldSingleCompetition(pk::force@ force, pk::building@ building)
        {
            // 황건은 개최불가
            if (국호_황건 == force.kokugou)
            {
                return -1;
            }

            int tp = force.tp;
            uint gold;
            if (true == force.is_player())
            {
                gold = pk::get_gold(building);
            }

            if (force.title >= 작위_대사마)
            {
                return 4;
            }
 

            // 대회 개최 유무
            if (true == IsHoldCompetition(force.get_force_id()))
            {
                return 5;
            }

            // 세력 기교 검사
            if (tp < 대회_개최기교 && true == force.is_player())
            {
                return 6;
            }

            // 도시의 금 검사
            if (gold < 대회_개최비용 && true == force.is_player())
            {
                return 7;
            }

            // 장수 자격요건 검사
            bool duelCheck = IsExistQualification(force, 대회_무술, 대회_자세력);
            bool EloquencyCheck = IsExistQualification(force, 대회_설전, 대회_자세력);

            // 모두 개최가능
            if (true == duelCheck && true == EloquencyCheck)
            {
                return 0;
            }
            // 무술대회만 가능
            else if (true == duelCheck && false == EloquencyCheck)
            {
                return 1;
            }
            // 설전대회만 가능
            else if (false == duelCheck && true == EloquencyCheck)
            {
                return 2;
            }
            // 장수 자격부족
            else
            {
                return 8;
            }
        }

        void UpdateAICompetition(pk::force@ force)
        {
            if (자세력_대회_개최여부 == 0)
            {
                return;
            }

            if (true == force.is_player() || false == IsValidForce(force))
            {
                return;
            }
                
            int data = GetPossibleHoldSingleCompetition(force, null);

            if (data == -1 || data > 2)
            {
                return;
            }

            if (0 == data )
            {
                if (true == pk::rand_bool(50))
                {
                    // AI 무술대회
                    ExecuteAICompetition(force, 대회_무술);
                }
                else
                {
                    // AI 설전대회
                    ExecuteAICompetition(force, 대회_설전);
                }
            }
            else if (1 == data)
            {
                // AI 무술대회
                ExecuteAICompetition(force, 대회_무술);
            }
            else if (2 == data)
            {
                // AI 설전대회
                ExecuteAICompetition(force, 대회_설전);
            }
        }

        void ExecuteAICompetition(pk::force@ force, int competitiontype)
        {
            string competitionName;
            auto tempList = GetCompetitionPersonList(force, competitiontype, true);
            int ability;
            
            if (대회_무술 == competitiontype)
            {
                ability = 무장능력_무력;
                competitionName = "무술대회";
            }
            else if (대회_설전 == competitiontype)
            {
                ability = 무장능력_지력;
                competitionName = "설전대회";
            }

            auto validList = GetSortedCompetitionPersonList(tempList, ability);
            pk::list<pk::person@> personList;
            
            for (int i = 0; i < 8; ++i)
            {
                personList.add(validList[i]);
            }

            array<pk::person@> backUpArray = pk::list_to_array(personList);

            int remain = personList.count;
            int round = 1;

            while (remain > 2)
            {
                pk::list<pk::person@> list;
                int n = 1;

                for (int i = 0; i < personList.count; ++i)
                {
                    pk::person@ p1 = personList[i];
                    pk::person@ p2 = personList[i + 1];
                    int first;
                    if (대회_무술 == competitionType)
                    {
                        first = pk::duel(null, null, p1, null, null, p2, null, null, false, false, 0, false).first;
                    }
                    else if (대회_설전 == competitionType)
                    {
                        first = pk::debate(p1, p2, false, false, false, false).first;
                    }
                    list.add(personList[i + first]);

                    i = i + 1;
                    n = n + 1;
                }

                personList.clear();
                personList = list;
                remain = personList.count;
                round++;
            }

            int first;

            if (대회_무술 == competitionType)
            {
                first = pk::duel(null, null, personList[0], null, null, personList[1], null, null, false, false, 0, false).first;
            }
            else if (대회_설전 == competitionType)
            {
                first = pk::debate(personList[0], personList[1], false, false, false, false).first;
            }

            pk::person@ winner = personList[first];
            pk::person@ runnerUp = personList[(first + 1) % 2];

            string forceName;

            if (force.kokugou == -1)
            {
                forceName = pk::u8decode(pk::get_name(pk::get_person(force.kunshu)));
            }
            else
            {
                forceName = pk::u8decode(pk::get_kokugou(force.kokugou).get_name());
            }
            
            if (대회_무술 == competitionType)
            {
                for (int i = 0; i < backUpArray.length; ++i)
                {
                    pk::person@ p = backUpArray[i];
                    p.stat_exp[무장능력_통솔] = p.stat_exp[무장능력_통솔] + 자체_대회_경험치;
                    p.stat_exp[무장능력_무력] = p.stat_exp[무장능력_무력] + 자체_대회_경험치;
                }
            }
            else if (대회_설전 == competitionType)
            {
                for (int i = 0; i < backUpArray.length; ++i)
                {
                    pk::person@ p = backUpArray[i];
                    p.stat_exp[무장능력_지력] = p.stat_exp[무장능력_지력] + 자체_대회_경험치;
                    p.stat_exp[무장능력_정치] = p.stat_exp[무장능력_정치] + 자체_대회_경험치;
                }
            }

            SetSingleCompetitionWinner(force.get_force_id(), winner.get_id());
            pk::message_box(pk::u8encode(pk::format("\x1b[2x{}군\x1b[0x에서 열린 \x1b[1x{}\x1b[0x의 우승자는 \x1b[2x{}\x1b[0x입니다.", forceName, competitionName, pk::u8decode(pk::get_name(winner)))));
            pk::history_log(winner.get_pos(), force.color, pk::u8encode(pk::format("\x1b[1x{}군\x1b[0x의 \x1b[2x{}\x1b[0x, 세력 내 \x1b[1x{}\x1b[0x 우승", forceName, pk::u8decode(pk::get_name(winner)), competitionName)));
        }

        // ================================================= Ver 1.2 =====================================================================

        void RecoverWoundedTroops()
        {
            if (부상병시스템_사용여부 == 0)
                return;

            for (int i = 0; i < 건물_거점끝; ++i)
            {
                pk::building@ building = pk::get_building(i);
                int woundedTroops; 
                int value = 0;

                if (woundedBuildingArray[i] > 0)
                {
                    woundedTroops = woundedBuildingArray[i];
                    value += 거점_부상병_기본_회복량;

                    if (i < 도시_끝)
                    {
                        pk::city@ city = pk::get_city(i);
                        int count = pk::get_completed_facility_count(city);
                        value += count * 도시_시설당_부상병_회복량;

                        if (HasUniqueTech(building.get_force_id(), 고유기교_왕좌지재))
                        {
                            value = value * (100 + 왕좌지재_거점_부상병_추가_회복률) / 100;
                        }
                    }

                    if (value >= woundedTroops)
                    {
                        value = woundedTroops;
                    }

                    woundedBuildingArray[i] = woundedBuildingArray[i] - value;
                    pk::add_troops(building, value, true);
                }
            }
            
            array<pk::force@> force_array = pk::list_to_array(pk::get_force_list());

            for (int i = 0; i < force_array.length; ++i)
            {
                if (force_array[i].get_force_id() >= 도시_끝)
                    continue;

                pk::force@ force = force_array[i];
                int force_id = force.get_force_id();

                if (HasUniqueTech(force_id, 고유기교_대기대덕))
                {
                    bool is_say = false;
                    array<pk::unit@> unit_array = pk::list_to_array(pk::get_unit_list(force));

                    for (int j = 0; j < unit_array.length; ++j)
                    {
                        int unit_id = unit_array[j].get_id();
                        int value = 0;

                        if (woundedUnitArray[unit_id] > 0)
                        {
                            value = (woundedUnitArray[unit_id] * 대기대덕_부대_부상병_회복률) / 100;

                            value = pk::min(value, 대기대덕_부대_부상병_최대_회복);
                            value = pk::max(value, 대기대덕_부대_부상병_최소_회복);

                            if (value > woundedUnitArray[unit_id])
                            {
                                value = woundedUnitArray[unit_id];
                            }

                            woundedUnitArray[unit_id] = woundedUnitArray[unit_id] - value;
                            pk::add_troops(unit_array[j], value, true);

                            if (value > 0 && !is_say)
                            {
                                if (pk::is_in_screen(unit_array[j].get_pos()))
                                {
                                    is_say = true;
                                    string kunshuName = pk::u8decode(pk::get_name(pk::get_person(force.kunshu)));
                                    pk::say(pk::u8encode(pk::format("우오오오! 끝까지 \x1b[2x{}\x1b[0x님을 따르겠습니다!", kunshuName)), pk::get_person(무장_병사), unit_array[j]);
                                }
                            }
                        }
                    }
                }
            }
        }


        // ================================================= 101 징병 치안 증감 =====================================================================

        int func101(pk::city@ city, const pk::detail::arrayptr<pk::person@>& in actors, int troops)
        {
            int value = prev_callback_101(city, actors, troops);

            int forceId = actors[0].get_force_id();
            pk::force@ force = pk::get_force(forceId);
            int buff = 천축_2단계_징병치안보조;
            // 형남 지역이점 유무
            if (false == IsEnableZhou(force, 형남))
            {
                buff = buff / 2;
            }
            // 천축국 실리론 유무
            int relation_level = GetRelationLevel(force, 우호_천축국);
            if (relation_level >= 2)
            {
                value = value * (100 - buff) / 100;
            }

            return value;
        }

        // ==================================================== 징병 치안 증감 끝 ===================================================================

        // ================================================= 102 병기생산량 =========================================================================

        int func102(pk::city@ city, const pk::detail::arrayptr<pk::person@>& in actors, int weapon_id)
        {
            int value = prev_callback_102(city, actors, weapon_id);

            // 연주 지역이점
            pk::force@ force = pk::get_force(city.get_force_id());

            if (weapon_id <= 병기_노)
            {
                ExecuteYanZhou(force, value);
            }

            return value;
        }
        // =================================================== 병기생산량 끝 ========================================================================

        // ================================================= 158 월별 본거지 발생 확률 ===============================================================
        
        int func158(pk::city@ city)
        {
            int value = prev_callback_158(city);

            if (HasUniqueTech(city.get_force_id(), 고유기교_덕왕위덕))
            {
                return 0;
            }

            int city_id = city.get_id();

            if (city_id == 도시_북평 || city_id == 도시_계 || city_id == 도시_양평)
            {
                bool isAlien = false;
                auto forces = pk::get_force_list();
                array<pk::force@> arr = pk::list_to_array(forces);

                for (int i = 0; i < arr.length; ++i)
                {
                    if (true == IsValidForce(arr[i]))
                    {
                        if (GetRelationLevel(arr[i], 우호_오환) >= 1)
                        {
                            isAlien = true;
                        }
                    }
                }

                if (true == isAlien)
                {
                    value = 0;
                }
            }

            // 량주 강 체크
            if (city_id == 도시_무위 || city_id == 도시_천수 || city_id == 도시_안정)
            {
                bool isAlien = false;
                auto forces = pk::get_force_list();
                array<pk::force@> arr = pk::list_to_array(forces);

                for (int i = 0; i < arr.length; ++i)
                {
                    if (true == IsValidForce(arr[i]))
                    {
                        if (GetRelationLevel(arr[i], 우호_강) >= 1)
                        {
                            isAlien = true;
                        }
                    }
                }

                if (true == isAlien)
                {
                    value = 0;
                }
            }

            // 양주 산월 체크
            if (city_id == 도시_건업 || city_id == 도시_오 || city_id == 도시_회계 || city_id == 도시_시상)
            {
                bool isAlien = false;
                auto forces = pk::get_force_list();
                array<pk::force@> arr = pk::list_to_array(forces);

                for (int i = 0; i < arr.length; ++i)
                {
                    if (true == IsValidForce(arr[i]))
                    {
                        if (GetRelationLevel(arr[i], 우호_산월) >= 1)
                        {
                            isAlien = true;
                        }
                    }
                }

                if (true == isAlien)
                {
                    value = 0;
                }
            }

            // 남중지역 남만 체크
            if (city_id == 도시_운남 || city_id == 도시_건녕 || city_id == 도시_강주)
            {
                bool isAlien = false;
                auto forces = pk::get_force_list();
                array<pk::force@> arr = pk::list_to_array(forces);


                for (int i = 0; i < arr.length; ++i)
                {
                    if (true == IsValidForce(arr[i]))
                    {
                        if (GetRelationLevel(arr[i], 우호_남만) >= 1)
                        {
                            isAlien = true;
                        }
                    }
                }

                if (true == isAlien)
                {
                    value = 0;
                }
            }

            return value;
        }

        // ==========================================================================================================================================

        // ================================================= 163 부대 능력치 =========================================================================
        void func163(pk::unit_attr& attr, const pk::detail::arrayptr<pk::person@>& in member, int weapon_id, uint troops, int type, int status, bool navy, bool shoubyou)
        {
            prev_callback_163(attr, member, weapon_id, troops, type, status, navy, shoubyou);

            pk::person@ leader = member[0];
            if (leader == null)
                return;

            pk::force@ force = pk::get_force(leader.get_force_id());

            int relation_level = 0;

            int atk = attr.stat[부대능력_공격];
            int def = attr.stat[부대능력_방어];
            int mov = attr.stat[부대능력_이동];

            if (weapon_id <= 병기_군마)
            {
                if (weapon_id <= 병기_검)
                {
                    if (HasUniqueTech(leader.get_force_id(), 고유기교_황천당립))
                    {
                        atk = atk + 황천당립_검병공방증가;
                        def = def + 황천당립_검병공방증가;
                        mov = mov + 황천당립_검병이속증가;
                    }
                }

                if (weapon_id <= 병기_노)
                {
                    // 남만 3단계 적용
                    if (pk::get_hex(leader.get_pos()).terrain == 지형_숲)
                    {
                        relation_level = GetRelationLevel(force, 우호_남만);
                    
                        if (relation_level == 3)
                        {
                            atk = atk * (100 + 남만_3단계_숲강화) / 100;
                            //attr.stat[부대능력_공격] = pk::min(255, atk);
                        }
                    }
                    
                    relation_level = GetRelationLevel(force, 우호_천축국);
                    
                    // 천축 3단계 적용
                    if (relation_level == 3)
                    {
                        bool isJingNan = IsEnableZhou(force, 형남);
                        pk::city@ city = pk::get_city(pk::get_city_id(leader.get_pos()));
                    
                        if (city != null)
                        {
                            if (pk::get_distance(leader.get_pos(), city.get_pos()) <= 3)
                            {
                                if (true == isJingNan)
                                {
                                    atk = atk * (100 + 천축_3단계_공방상승) / 100;
                                    def = def * (100 + 천축_3단계_공방상승) / 100;
                                }
                                else
                                {
                                    atk = atk * (100 + 천축_3단계_공방상승 / 2) / 100;
                                    def = def * (100 + 천축_3단계_공방상승 / 2) / 100;
                                }
                            }
                        }
                    }
                }
            
                if (weapon_id == 병기_창)
                {
                    // 대진국 지역이점
                    relation_level = GetRelationLevel(force, 우호_대진국);
                    bool isSili = IsEnableZhou(force, 사예);
                    
                    if (relation_level == 3)
                    {
                        if (true == isSili)
                        {
                            def = def * (100 + 대진_3단계_창병방어) / 100;
                        }
                        else
                        {
                            def = def * (100 + 대진_3단계_창병방어 / 2) / 100;
                        }
                    }
                    else if(relation_level > 0)
                    {
                        if (true == isSili)
                        {
                            def = def * (100 + 대진_1단계_창병방어) / 100;
                        }
                        else
                        {
                            def = def * (100 + 대진_1단계_창병방어 / 2) / 100;
                        }
                    }
                }
                else if (weapon_id == 병기_노)
                {
                    // 귀상국 지역이점
                    relation_level = GetRelationLevel(force, 우호_귀상국);
                    bool isYiZhou = IsEnableZhou(force, 익주);
                    if (relation_level >= 2)
                    {
                        if (true == isYiZhou)
                        {
                            atk = atk * (100 + 귀상_2단계_궁병공격) / 100;
                        }
                        else
                        {
                            atk = atk * (100 + 귀상_2단계_궁병공격 / 2) / 100;
                        }
                    }
                }
                else if (weapon_id == 병기_군마)
                {
                    // 안식국 지역이점
                    relation_level = GetRelationLevel(force, 우호_안식국);
                    bool isJingZhao = IsEnableZhou(force, 경조);
                    if (relation_level == 3)
                    {
                        if (true == isJingZhao)
                        {
                            atk = atk * (100 + 안식_3단계_기병공격) / 100;
                        }
                        else
                        {
                            atk = atk * (100 + 안식_3단계_기병공격 / 2) / 100;
                        }
                    }
                    else if (relation_level > 0)
                    {
                        if (true == isJingZhao)
                        {
                            atk = atk * (100 + 안식_1단계_기병공격) / 100;
                        }
                        else
                        {
                            atk = atk * (100 + 안식_1단계_기병공격 / 2) / 100;
                        }
                    }
                }
            
                if (!navy)
                {
                    int forceId = force.get_force_id();
            
                    // 병주 지역이점
                    bool isEnemyGround = false;
            
                    pk::city@ city = pk::get_city(pk::get_city_id(leader.get_pos()));
            
                    if (city == null)
                    {
                        isEnemyGround = true;
                    }
                    else
                    {
                        if (true == pk::is_enemy(leader, city))
                        {
                            isEnemyGround = true;
                        }
                    }
                    
                    if (true == isEnemyGround)
                    {
                        ExecuteBingZhouMove(force, mov);
                    }
                }
            }
            
            if (weapon_id == 병기_투석)
            {
                // 대진국 지역이점
                relation_level = GetRelationLevel(force, 우호_대진국);
                bool isSili = IsEnableZhou(force, 사예);
            
                if (relation_level >= 2)
                {
                    if (true == isSili)
                    {
                        atk = atk * (100 + 대진_2단계_투석공격) / 100;
                    }
                    else
                    {
                        atk = atk * (100 + 대진_2단계_투석공격 / 2) / 100;
                    }
                }
            }

            if (type != 부대종류_전투)
            {
                relation_level = GetRelationLevel(force, 우호_귀상국);
                bool isYiZhou = IsEnableZhou(force, 익주);
                if (relation_level >= 1)
                {
                    if (true == isYiZhou)
                    {
                        mov = mov + 귀상_1단계_수송이동;
                    }
                    else
                    {
                        mov = mov + 귀상_1단계_수송이동 / 2;
                    }
                }
            }

            int force_id = force.get_force_id();
            
            
            if (HasUniqueTech(force_id, 고유기교_위무지강))
            {
                int percent = pk::max(위무지강_최소병력, GetTroopsPercent(leader));

                int valid_percent = 100 - percent;      // (70 ~ 0)

                int valid_stat = 위무지강_공방증가 * valid_percent / (100 - 위무지강_최소병력);

                atk = atk * (100 + valid_stat) / 100;
                def = def * (100 + valid_stat) / 100;
            }

            if (HasUniqueTech(force_id, 고유기교_자모위용))
            {
                int percent = pk::max(자모위용_최소병력, GetTroopsPercent(leader));  // 100 ~ 30

                int valid_stat = 자모위용_공방증가 * (percent - 30) / (100 - 자모위용_최소병력);

                atk = atk * (100 + valid_stat) / 100;
                def = def * (100 + valid_stat) / 100;
            }

            if (GetWorldClassFlags(leader) == 0)
            {
                atk = (atk * 110) / 100;
                def = (def * 110) / 100;
            }
            else if (GetWorldClassFlags(leader) == 1)
            {
                atk = (atk * 90) / 100;
                def = (def * 90) / 100;
            }

            pk::building@ building = pk::get_building(pk::get_building_id(leader.get_pos()));

            if (HasUniqueTech(force_id, 고유기교_미주랑) && pk::is_on_fire(leader.get_pos()))
            {
                bool is_exist = false;

                if (member[0] != null)
                {
                    if (GetPersonUniqueTech(member[0].get_id()) == 고유기교_미주랑)
                    {
                        is_exist = true;
                    }
                }

                if (member[1] != null)
                {
                    if (GetPersonUniqueTech(member[1].get_id()) == 고유기교_미주랑)
                    {
                        is_exist = true;
                    }
                }

                if (member[2] != null)
                {
                    if (GetPersonUniqueTech(member[2].get_id()) == 고유기교_미주랑)
                    {
                        is_exist = true;
                    }
                }

                if (is_exist)
                {
                    atk = atk + 미주랑_공방증가 * 2;
                    def = def + 미주랑_공방증가 * 2;
                }
                else
                {
                    atk = atk + 미주랑_공방증가;
                    def = def + 미주랑_공방증가;
                }
            }

            // 소패왕 특정 숫자로 증가
            if (HasUniqueTech(force_id, 고유기교_소패왕) && pk::is_enemy(leader, building))
            {
                atk = atk + 소패왕_공방추가;
                def = def + 소패왕_공방추가;
            }

            // 황천당립 숫자로 증가
            if (HasUniqueTech(force_id, 고유기교_황천당립))
            {
                int percent = GetEnergyPercent(leader);

                atk = atk + 황천당립_공격력증가 * (100 - percent) / 100;
            }

            if (HasUniqueTech(force_id, 고유기교_속전고수))
            {
                mov = mov + 속전고수_기동력증가;
            }

            array<pk::point> arr = pk::range(leader.get_pos(), 1, 1);

            if (HasUniqueTech(force_id, 고유기교_효명진천))
            {
                int adjacent_count = 0;

                for (int i = 0; i < arr.length; ++i)
                {
                    pk::unit@ dst = pk::get_unit(arr[i]);

                    if (dst == null)
                    {
                        continue;
                    }
                    else
                    {
                        if (!pk::is_enemy(leader, dst))
                        {
                            adjacent_count--;
                        }
                        else
                        {
                            adjacent_count++;
                        }
                    }
                }

                if (adjacent_count > 0)
                {
                    atk = atk + 효명진천_공격증가 * adjacent_count;
                }
            }

            if (HasUniqueTech(force_id, 고유기교_일신시담))
            {
                int adjacent_count = 0;

                for (int i = 0; i < arr.length; ++i)
                {
                    pk::unit@ dst = pk::get_unit(arr[i]);

                    if (dst == null)
                    {
                        continue;
                    }
                    else
                    {
                        if (!pk::is_enemy(leader, dst))
                        {
                            adjacent_count--;
                        }
                        else
                        {
                            adjacent_count++;
                        }
                    }
                }

                if (adjacent_count > 0)
                {
                    def = def + 일신시담_방어증가 * adjacent_count;
                }
            }

            if (HasUniqueTech(force_id, 고유기교_일치단결))
            {
                int adjacent_count = 0;

                for (int i = 0; i < arr.length; ++i)
                {
                    pk::unit@ dst = pk::get_unit(arr[i]);

                    if (dst == null || pk::is_enemy(leader, dst))
                    {
                        continue;
                    }

                    adjacent_count++;
                }

                if (adjacent_count > 0)
                {
                    atk = atk + 일치단결_공방증가 * adjacent_count;
                    def = def + 일치단결_공방증가 * adjacent_count;
                }
            }

            if (HasUniqueTech(force_id, 고유기교_정예수군) && navy)
            {
                atk = atk * (100 + 정예수군_공방증가) / 100;
                def = def * (100 + 정예수군_공방증가) / 100;
                mov = mov + 정예수군_이속증가;
            }

            if (HasUniqueTech(force_id, 고유기교_팔문금쇄) && !pk::is_enemy(leader, building))
            {
                def = def + 팔문금쇄_방어증가;
            }

            if (HasUniqueTech(force_id, 고유기교_당도고))
            {
                // 대장이 한실 중시가 아닌 경우
                if (leader.kanshitsu != 2)
                {
                    int value = 9 - force.title;

                    atk = atk + 당도고_공방강화 * value;
                    def = def + 당도고_공방강화 * value;

                    // 공 이상인 경우 부대 이동속도도 추가로 증가
                    if (force.title <= 작위_공)
                    {
                        mov += (3 - force.title) * 당도고_이속강화;
                    }
                }
            }

            if (HasUniqueTech(building.get_force_id(), 고유기교_남만왕) && pk::is_enemy(leader, building))
            {
                mov = mov * (100 - 남만왕_이동저하) / 100;
            }

            atk = pk::min(255, atk);
            def = pk::min(255, def);
            mov = pk::min(255, mov);

            atk = pk::max(1, atk);
            def = pk::max(1, def);
            mov = pk::max(1, mov);

            attr.stat[부대능력_공격] = atk;
            attr.stat[부대능력_방어] = def;
            attr.stat[부대능력_이동] = mov;

            if (HasUniqueTech(force_id, 고유기교_비마대))
            {
                if (attr.tekisei[병종_기병] < 적성_A)
                {
                    attr.tekisei[병종_기병] = 적성_A;
                }
            }

            if (HasUniqueTech(force_id, 고유기교_원융노병))
            {
                if (attr.tekisei[병종_노병] < 적성_A)
                {
                    attr.tekisei[병종_노병] = 적성_A;
                }
            }

            if (HasUniqueTech(force_id, 고유기교_동주병))
            {
                if (attr.tekisei[병종_극병] < 적성_A)
                {
                    attr.tekisei[병종_극병] = 적성_A;
                }
            }

            if (HasUniqueTech(force_id, 고유기교_청주병))
            {
                if (attr.tekisei[병종_창병] < 적성_A)
                {
                    attr.tekisei[병종_창병] = 적성_A;
                }
            }
        }

        int GetTroopsPercent(pk::person@ leader)
        {
            pk::unit@ unit = pk::get_unit(pk::get_unit_id(leader));

            int max = pk::get_max_troops(unit);

            int curr = unit.troops;

            return (curr * 100 / max);
        }

        int GetEnergyPercent(pk::person@ leader)
        {
            pk::unit@ unit = pk::get_unit(pk::get_unit_id(leader));
            pk::force@ force = pk::get_force(unit.get_force_id());
            int max_energy = 100;

            if (force.tech[기교_숙련병])
                max_energy = 120;

            return (unit.energy * 100 / max_energy);
        }

        // ================================================== 부대 능력치 끝 ==========================================================================

        // ================================================== 168 거점 점령 후 처리 ====================================================================
        
        void func168(pk::building@ base, pk::unit@ attacker)
        {
            pk::person@ leader;

            if (pk::is_alive(attacker))
                @leader = pk::get_person(attacker.leader);

            pk::force@ force = pk::get_force(leader.get_force_id());
            pk::person@ moo = pk::get_person(무장_문관);

            int n = 5;
            int charisma = 20;

            bool has_buff = false;
            int relation_level = GetRelationLevel(force, 우호_천축국);
            
            if (relation_level >= 1)
            {
                has_buff = true;
            }
            int value = 천축_1단계_추가보존;
            
            if (false == IsEnableZhou(force, 형남))
            {
                value = value / 2;
            }

            if (pk::is_alive(leader))
            {
                charisma = leader.stat[무장능력_매력];
                n = pk::max(charisma / 10, 5);
            }

            // 천축국 지역이점이 있으면 금, 군량등의 소실 경감
            if (true == has_buff)
            {
                n = n * (100 + value) / 100;
            }
	// 여기가 내가(황주호)가 수정한 부분
            pk::set_gold(base, pk::get_gold(base) * n / 10);
            pk::set_food(base, pk::get_food(base) * n / 10);
            pk::set_troops(base, pk::get_troops(base) * n / 10);
            for (int i = 0; i < 병기_끝; i++)
                pk::set_weapon_amount(base, i, pk::get_weapon_amount(base, i) * n / 10);

            pk::city@ city = pk::building_to_city(base);

            // 도시가 아닌경우 여기서 종료
            if (!pk::is_alive(city))
                return;
            
            int city_id = city.get_id();
            int city_force_id = city.get_force_id();
            pk::list<pk::building@> city_devs;
            pk::list<pk::building@> buildings = pk::get_building_list();

            pk::force@ baseForce = pk::get_force(city.get_force_id());
            int zhou = GetZhouId(city_id);
            
            bool isAttackerGet = IsRegionBuffChange(force, city_id, false);             // 공격자가 지역이점 획득
            bool isDefenderLose = IsRegionBuffChange(baseForce, city_id, true);            // 피격자가 지역이점 상실
            
            // 지역이점 변동여부 체크
            
            if (true == IsValidForce(force))
            {
                if (true == force.is_player())
                {
                    // 플레이어가 공격자인 경우
                    if (true == isAttackerGet)
                    {
                        // 얻는 소리
                        pk::play_se(10);
                        pk::message_box(pk::u8encode(pk::format("아군이 \x1b[2x{}\x1b[0x지역의 지역이점을 획득했습니다.", 주_이름[zhou])), moo);
                    }
                }
            }

            if (true == IsValidForce(baseForce))
            {
                if (true == baseForce.is_player())
                {
                    // 플레이어가 피격자인 경우
                    if (true == isDefenderLose)
                    {
                        // 잃는 소리
                        pk::play_se(27);
                        pk::message_box(pk::u8encode(pk::format("아군이 \x1b[2x{}\x1b[0x지역의 지역이점을 상실했습니다.", 주_이름[zhou])), moo);
                    }
                }
            }

            // 피격 세력이 멸망당하지 않고 지역이점을 상실했을 경우
            if (true == isDefenderLose && pk::get_city_count(baseForce) > 1)
            {
                string forceName;

                if (baseForce.kokugou != -1)
                {
                    forceName = pk::get_kokugou(baseForce.kokugou).get_name() + pk::u8encode("군");
                }
                else
                {
                    forceName = pk::get_name(pk::get_person(baseForce.kunshu)) + pk::u8encode("군");
                }

                pk::history_log(base.get_pos(), baseForce.color, pk::u8encode(pk::format("\x1b[1x{}\x1b[0x이 \x1b[1x{}\x1b[0x의 지역이점 상실", pk::u8decode(forceName), 주_이름[zhou])));
            }
            
            // 공격세력이 지역이점을 획득했을 경우
            if (true == isAttackerGet)
            {
                string forceName;

                if (force.kokugou != -1)
                {
                    forceName = pk::get_kokugou(force.kokugou).get_name() + pk::u8encode("군");
                }
                else
                {
                    forceName = pk::get_name(pk::get_person(force.kunshu)) + pk::u8encode("군");
                }

                pk::history_log(base.get_pos(), force.color, pk::u8encode(pk::format("\x1b[1x{}\x1b[0x이 \x1b[1x{}\x1b[0x의 지역이점 획득", pk::u8decode(forceName), 주_이름[zhou])));
            }

            for (int i = 0; i < buildings.size; i++)
            {
                pk::building@ building = buildings[i];
                if (pk::is_alive(building) and pk::get_city_id(building.get_pos()) == city_id)
                {
                    switch (pk::get_facility_type(building))
                    {
                    case 시설종류_내정시설:
                        if (building.completed)
                        {
                            // 건설 완료된 내정시설은 동작대가 아니라면 무작위로 파괴.
                            if (building.facility != 시설_동작대)
                                city_devs.push_back(building);
                        }
                        else
                        {
                            // 건설중인 동작대가 파괴된 경우 동작 보물도 사라짐.
                            if (building.facility == 시설_동작대)
                            {
                                pk::item@ item = pk::get_item(보물_동작);
                                if (pk::is_alive(item))
                                    pk::kill(item);
                            }
                            // 건설중인 내정시설은 모두 파괴.
                            else
                            {
                                pk::kill(building, false);
                            }
                        }
                        break;

                    case 시설종류_군사시설:
                        // 구역 내 도시를 점령하고 있던 세력과 같은 세력의 군사시설은 모두 파괴
                        if (pk::is_valid_force_id(city_force_id) and city_force_id == building.get_force_id())
                            pk::kill(building, false);
                        break;
                    }
                }
            }

            n = city_devs.size;
            if (pk::is_valid_normal_force_id(attacker.get_force_id()))
                n = n - pk::min(charisma / 20, n);

            // 천축국 지역이점이 있으면 파괴되는 시설 감소
            if (true == has_buff)
            {
                n = (n * 100) / (100 + value);
            }

            if (HasUniqueTech(attacker.get_force_id(), 고유기교_대기대덕))
            {
                n = n * (100 - 대기대덕_시설보존) / 100;
            }

            city_devs.shuffle();
            for (int i = 0; i < n; i++)
                pk::kill(city_devs[i], false);
        }
    
        
        // ===========================================================================================================================================

        // =============================================== 205 계략 소비 기력 =========================================================================
        int func205(pk::unit@ src, int strategy_id)
        {
            pk::force@ force = pk::get_force(src.get_force_id());

            int energy = 0;

            switch (strategy_id)
            {
            case 계략_화계: energy = 10;
                break;
            case 계략_소화: energy = 10;
                break;
            case 계략_위보: energy = 15;
                break;
            case 계략_교란: energy = 15;
                break;
            case 계략_진정: energy = 10;
                break;
            case 계략_복병: energy = 10;
                break;
            case 계략_동토: energy = 20;
                break;
            case 계략_요술: energy = 50;
                break;
            case 계략_낙뢰: energy = 50;
                break;
            }

            // 회남 지역이점. 계략소비 경감
            ExecuteHuaiNan(force, energy);

            if (src.has_skill(특기_백출))
            {
                if (백출_기력반감 == 1)
                    energy = (energy + 1) / 2;
                else
                    energy = 1;
            }

            return energy;
        }
        // ================================================== 계략 소비 기력 끝 ========================================================================


        // ================================================ 211 건물의 공격 데미지 =====================================================================
        void func211(pk::damage_info& info, pk::building@ attacker, pk::hex_object@ target)
        {
            prev_callback_211(info, attacker, target);

            pk::force@ force = pk::get_force(attacker.get_force_id());

            // 서주 지역이점 획득 시 성, 관문, 항구의 공격력 20% 상승
            if (attacker.facility >= 시설_도시 && attacker.facility <= 시설_항구)
            {
                ExecuteXuZhouDamage(force, info);
            }

            pk::unit@ target_unit = pk::hex_object_to_unit(target);

            int id;
            int damage = info.troops_damage;

            if (target_unit != null)
            {
                if (HasUniqueTech(attacker.get_force_id(), 고유기교_팔진도))
                {
                    if (pk::rand_bool(팔진도_상태이상확률))
                    {
                        // 화계로 인해 부대가 전멸당해 팅기는 경우를 방지하기 위해 화계는 부대가 3000명 이상일 경우에만 발생
                        if (target_unit.troops >= 3000)
                        {
                            int r = pk::rand(1000) % 4;
                            string dialog = "";
                            if (r == 0)
                            {
                                dialog = "전열을 가다듬어야 한다..";
                                pk::set_status(target_unit, null, 부대상태_혼란, 1, true);
                            }
                            else if (r == 1)
                            {
                                dialog = "으으.. 병사들이 현혹되었군..";
                                pk::set_status(target_unit, null, 부대상태_위보, 1, true);
                            }
                            else if (r == 2)
                            {
                                dialog = "으음.. 병사들의 사기가..";
                                pk::add_energy(target_unit, -10, true);
                            }
                            else
                            {
                                dialog = "뭣이..? 누가 불을 질렀단 말이냐..!";
                                pk::create_fire(target_unit.get_pos(), 2, null, false);
                            }

                            pk::person@ person = pk::get_person(target_unit.leader);

                            if (pk::is_in_screen(target_unit.get_pos()))
                            {
                                pk::say(pk::u8encode(dialog), person, target_unit);
                            }
                        }
                        else
                        {
                            int r = pk::rand(1000) % 3;
                            string dialog = "";
                            if (r == 0)
                            {
                                dialog = "전열을 가다듬어야 한다..";
                                pk::set_status(target_unit, null, 부대상태_혼란, 1, true);
                            }
                            else if (r == 1)
                            {
                                dialog = "으으.. 병사들이 현혹되었군..";
                                pk::set_status(target_unit, null, 부대상태_위보, 1, true);
                            }
                            else
                            {
                                dialog = "으음.. 병사들의 사기가..";
                                pk::add_energy(target_unit, -10, true);
                            }

                            pk::person@ person = pk::get_person(target_unit.leader);

                            if (pk::is_in_screen(target_unit.get_pos()))
                            {
                                pk::say(pk::u8encode(dialog), person, target_unit);
                            }
                        }
                    }
                }

                if (HasUniqueTech(attacker.get_force_id(), 고유기교_유시))
                {
                    int percentage = 유시_부상확률;

                    if (pk::has_member(target_unit, 무장_방통))
                    {
                        percentage *= 2;
                    }

                    // 등갑이나 호위의 경우 무시
                    if (target_unit.has_skill(특기_등갑) || target_unit.has_skill(특기_호위))
                    {
                        percentage = 0;
                    }

                    if (pk::rand_bool(percentage))
                    {
                        pk::list<pk::person@> moo_list;
                        moo_list.add(pk::get_person(target_unit.leader));

                        pk::person@ deputy_1 = pk::get_person(target_unit.member[1]);
                        pk::person@ deputy_2 = pk::get_person(target_unit.member[2]);

                        if (deputy_1 != null)
                        {
                            moo_list.add(deputy_1);
                        }

                        if (deputy_2 != null)
                        {
                            moo_list.add(deputy_2);
                        }

                        moo_list.shuffle();

                        string dialog = "";
                        
                        pk::person@ target_person = moo_list[0];

                        if (target_person.shoubyou == 상병_건강)
                        {
                            target_person.shoubyou = 상병_경증;

                            if (pk::rand_bool(50))
                                dialog = "쳇.. 이정도는 아무렇지도 않다..!";
                            else
                                dialog = "크읏.. 어디서 눈먼 화살이..";
                        }
                        else if (target_person.shoubyou == 상병_경증)
                        {
                            target_person.shoubyou = 상병_중증;

                            if (pk::rand_bool(50))
                                dialog = "쳇.. 이정도는 아무렇지도 않다..!";
                            else
                                dialog = "크읏.. 어디서 눈먼 화살이..";
                        }
                        else if (target_person.shoubyou == 상병_중증)
                        {
                            target_person.shoubyou = 상병_빈사;

                            if (pk::rand_bool(50))
                                dialog = "으으.. 위험하다!";
                            else
                                dialog = "헉... 큰일이군..";
                        }

                        target_person.update();

                        if (pk::is_in_screen(target_unit.get_pos()))
                        {
                            pk::say(pk::u8encode(dialog), target_person, target_unit);
                        }
                    }
                }

                // 이민족 부대의 경우 패스
                if (target_unit.leader >= 적장_시작 && target_unit.leader < 적장_끝)
                    return;

                id = target_unit.get_id();

                if (target_unit.troops <= damage)
                {
                    damage = target_unit.troops;
                }

                int value = 부상병_전환율;

                if (HasUniqueTech(target_unit.get_force_id(), 고유기교_오두미도))
                {
                    value = value + 오두미도_추가_전환율;
                }

                if (HasUniqueTech(attacker.get_force_id(), 고유기교_주지육림))
                {
                    value = value * (100 - 주지육림_부상병_경감) / 100;
                }

                woundedUnitArray[id] = woundedUnitArray[id] + ((damage * value) / 100);
                //string s = pk::format("{}, {}", pk::u8decode(pk::get_name(pk::get_person(target_unit.leader))), damage);
                //pk::history_log(pk::point(0, 0), -1, pk::u8encode(s));
            }
        }

        // ================================================ 건물의 공격 데미지 끝 ======================================================================


        // ======================================================== 111 등용 확률 =====================================================================

        bool func111(pk::person@ target, pk::person@ actor, int type, int seed)
        {
            if (!pk::is_alive(target) or !pk::is_alive(actor)) return false;

            // 실행 무장의 군주가 없다면 항상 실패
            pk::person@ actor_kunshu = pk::get_person(pk::get_kunshu_id(actor));
            if (!pk::is_alive(actor_kunshu)) return false;

            // 특별한 관계가 있는지 확인
            pk::bool_bool tuple = func_4b0040(target, actor, type);
            if (tuple.first) return tuple.second;

            int giri = 10;
            if (type != 0) giri = pk::min(15 - target.giri * 2, 10);
            int n = pk::min(func_5c6030(target, actor, type, seed) * giri / 10, 100);

            // 포로처우인 경우
            if (type != 0)
            {
                return pk::rand_bool(n);
            }

            return n > pk::rand(100, seed, target.get_id(), actor.get_id(), target.loyalty, actor.stat[무장능력_매력], pk::get_aishou_distance(actor, target.get_id()), 0);
        }

        /**
            목표 무장과 실행 무장 사이에 특별한 관계가 있는지 판단합니다.
            @return 특별한 관계 여부, 등용 성공 여부
        */
        pk::bool_bool func_4b0040(pk::person@ target, pk::person@ actor, int type)
        {
            int target_force_id = target.get_force_id();
            // 귀환 가능함을 나타냄
            bool is_valid_target_force_id = pk::is_valid_force_id(target_force_id);

            // 목표 무장의 세력이 멸망
            if (type == 2) is_valid_target_force_id = false;

            if (!pk::is_alive(target) or !pk::is_alive(actor)) return pk::bool_bool(true, false);

            int actor_kunshu_id = pk::get_kunshu_id(actor);
            pk::person@ actor_kunshu = pk::get_person(actor_kunshu_id);

            // 실행 무장의 세력에 군주가 없는 경우 항상 실패
            if (!pk::is_alive(actor_kunshu)) return pk::bool_bool(true, false);

            // 목표 무장의 사관 금지 군주가 실행 무장의 군주인 경우 항상 실패
            if (target.banned_kunshu == actor_kunshu_id) return pk::bool_bool(true, false);

            // 목표 무장이 군주인 경우 항상 실패
            if (target.mibun == 신분_군주 and is_valid_target_force_id) return pk::bool_bool(true, false);

            pk::person@ target_gikyoudai = pk::get_person(target.gikyoudai);

            // 목표 무장이 의형제 있음(2인)
            if (pk::is_alive(target_gikyoudai) and @target_gikyoudai != @target)
            {
                // 목표 무장이 의형제와 같은 세력인 경우 항상 실패
                if (is_valid_target_force_id and pk::is_valid_force_id(target_force_id) and target_gikyoudai.get_force_id() == target_force_id) return pk::bool_bool(true, false);
                /*
                                // 목표 무장이 실행 무장 세력의 군주나 실행 무장과 의형제인 경우 항상 성공
                                if (@target_gikyoudai == @actor_kunshu or @target_gikyoudai == @actor) return pk::bool_bool(true, true);
                */
            }

            pk::person@ target_spouse = pk::get_person(target.spouse);

            // 목표 무장이 배우자와 같은 세력인 경우 항상 실패
            if (pk::is_alive(target_spouse))
            {
                if (is_valid_target_force_id and pk::is_valid_force_id(target_force_id) and target_spouse.get_force_id() == target_force_id)
                    return pk::bool_bool(true, false);
            }

            pk::list<pk::person@> target_gikyoudai_list = pk::get_gikyoudai_list(target);

            // 목표 무장이 의형제와 같은 세력인 경우 항상 실패
            if (is_valid_target_force_id and pk::is_alive(target_gikyoudai) and pk::is_valid_force_id(target_force_id))
            {
                for (int i = 0; i < target_gikyoudai_list.size; i++)
                {
                    if (target_gikyoudai_list[i].get_force_id() == target_force_id)
                        return pk::bool_bool(true, false);
                }
            }

            // 모두 등용 난이도 상승이 아닌 경우
            if (수정된_등용확률 != 1)
            {
                bool is_valid = true;

                // 유저만 상승일때 actor 가 유저 세력인 경우
                if (수정된_등용확률 == 3 && actor.is_player())
                {
                    is_valid = false;
                }

                // AI만 상승일때 actor가 AI 세력인 경우
                if (수정된_등용확률 == 2 && !actor.is_player())
                {
                    is_valid = false;
                }

                if (is_valid)
                {
                    // 목표 무장의 의형제가 다른 세력에 소속되어 있다면 항상 실패
                    if (pk::is_alive(target_gikyoudai) and @target_gikyoudai != @target)
                    {
                        int gikyoudai_force_id = target_gikyoudai.get_force_id();
                        if (is_valid_target_force_id or target_force_id != gikyoudai_force_id)
                        {
                            if (pk::is_valid_force_id(gikyoudai_force_id) and actor_kunshu.get_force_id() != gikyoudai_force_id)
                                return pk::bool_bool(true, false);
                        }
                    }


                    // 목표 무장의 배우자가 다른 세력에 소속되어 있다면 항상 실패
                    if (pk::is_alive(target_spouse))
                    {
                        int spouse_force_id = target_spouse.get_force_id();
                        if (is_valid_target_force_id or target_force_id != spouse_force_id)
                        {
                            if (pk::is_valid_force_id(spouse_force_id) and actor_kunshu.get_force_id() != spouse_force_id)
                                return pk::bool_bool(true, false);
                        }
                    }


                    // 목표 무장의 배우자가 실행 무장이거나 실행 무장의 군주인 경우 항상 성공
                    if (pk::is_alive(target_spouse))
                    {
                        if (@target_spouse == @actor_kunshu or @target_spouse == @actor)
                            return pk::bool_bool(true, true);
                    }
                }
            }

            // 목표 무장이 실행 무장의 군주를 혐오하는 경우 항상 실패
            if (pk::is_dislike(target, actor_kunshu_id)) return pk::bool_bool(true, false);

            int actor_id = actor.get_id();

            // 목표 무장이 실행 무장을 혐오하는 경우 항상 실패
            if (pk::is_dislike(target, actor_id)) return pk::bool_bool(true, false);

            int actor_force_id = actor.get_force_id();
            int target_kunshu_id = pk::get_kunshu_id(target);

            bool is_hard = false;

            if (수정된_등용확률 == 1)
                is_hard = true;
            else
            {
                if (수정된_등용확률 == 3 && actor.is_player())
                {
                    is_hard = true;
                }
                else if (수정된_등용확률 == 2 && !actor.is_player())
                {
                    is_hard = true;
                }
            }

            if (type == 0) //일반적인 등용
            {
                // 목표 무장이 재야이면서 실행 무장과 의형제나 부부이거나, 실행 무장의 군주와 의형제나 부부인경우 항상 성공
                if (pk::is_gikyoudai(target, actor_id) or pk::is_gikyoudai(target, actor_kunshu_id) or pk::is_fuufu(target, actor_id) or pk::is_fuufu(target, actor_kunshu_id))
                {
                    if (target.mibun == 신분_재야)
                        return pk::bool_bool(true, true);
                }

                // 목표 무장의 충성도, 의리x4의 합이 92 이상인 경우 항상 실패
                if (is_hard)
                {
                    if (target.loyalty + target.giri * 4 >= 92) return pk::bool_bool(true, false);
                }
                else
                {
                    if (target.loyalty + target.giri >= 96) return pk::bool_bool(true, false);
                }

                if (!is_hard)
                {
                    // 목표 무장의 의형제가 실행 무장의 세력에 소속되어 있다면 항상 성공
                    if (pk::is_alive(target_gikyoudai) and target_gikyoudai.get_force_id() == actor_force_id) return pk::bool_bool(true, true);
                    

                    // 목표 무장의 배우자가 실행 무장의 세력에 소속되어 있다면 항상 성공
                    if (pk::is_alive(target_spouse) and target_spouse.get_force_id() == actor_force_id) return pk::bool_bool(true, true);
                   
                }
                // 목표 무장이 목표 무장의 군주를 친애한다면 항상 실패
                if (target.mibun != 신분_군주 and pk::is_valid_person_id(target_kunshu_id) and pk::is_like(target, target_kunshu_id)) return pk::bool_bool(true, false);

                // 목표 무장이 실행 무장이나 실행 무장의 군주를 친애한다면 항상 성공
                if (pk::is_like(target, actor_id) or pk::is_like(target, actor_kunshu_id)) return pk::bool_bool(true, true);
            }
            else //포로에 대한 등용
            {
                if (!is_hard)
                {
                    // 목표 무장의 의형제가 실행 무장의 세력에 소속되어 있다면 항상 성공
                    for (int i = 0; i < target_gikyoudai_list.size; i++)
                    {
                        if (target_gikyoudai_list[i].get_force_id() == actor_force_id)
                        return pk::bool_bool(true, true);
                    }
                }
                // 목표 무장의 배우자가 실행 무장의 세력에 소속되어 있다면 항상 성공
                if (pk::is_alive(target_spouse) and target_spouse.get_force_id() == actor_force_id) return pk::bool_bool(true, true);

                // 목표 무장이 목표 무장의 군주를 친애한다면 항상 실패
                if (is_valid_target_force_id and target.mibun != 신분_군주 and pk::is_valid_person_id(target_kunshu_id) and pk::is_like(target, target_kunshu_id)) return pk::bool_bool(true, false);

                // 목표 무장이 실행 무장의 군주를 친애한다면 항상 성공
                if (pk::is_like(target, actor_kunshu_id)) return pk::bool_bool(true, true);
            }

            return pk::bool_bool(false, false);
        }

        /***/
        int func_5c6030(pk::person@ target, pk::person@ actor, int type, int seed)
        {
            if (!pk::is_alive(target) or !pk::is_alive(actor)) return 0;

            pk::force@ force = pk::get_force(actor.get_force_id());
            int loyalty = target.loyalty;
            int aishou = 25;
            int giri = target.giri;
            int target_kunshu_id = pk::get_kunshu_id(target);
            int actor_kunshu_id = pk::get_kunshu_id(actor);
            int n = 0;

            if (type == 2)
                loyalty = pk::min(loyalty, 70);

            // 목표 무장이 재야이거나 멸망한 세력의 포로인 경우
            if (target.mibun == 신분_재야 or (target.mibun == 신분_포로 and !pk::is_valid_force_id(target.get_force_id())))
                loyalty = pk::get_scenario().difficulty == 난이도_초급 ? 60 : 70;

            if (pk::is_valid_person_id(target_kunshu_id))
                aishou = pk::get_aishou_distance(target, target_kunshu_id);

            if (target.mibun == 신분_재야)
                giri = 의리_보통;

            n = (aishou - pk::get_aishou_distance(target, actor_kunshu_id)) / 5;
            n -= (giri + 18) * loyalty * 5 / 100;
            n += pk::max(actor.stat[무장능력_매력], 30) * 3 / 5;
            n -= pk::is_like(target, target_kunshu_id) ? 15 : 0;
            n -= pk::is_oyako(target, target_kunshu_id) ? 15 : 0;
            n += pk::is_dislike(target, target_kunshu_id) ? 15 : 0;
            n += pk::rand(의리_끝 - giri, actor.get_id(), target.get_id(), actor.stat[무장능력_매력], seed, actor_kunshu_id, 0, 0);
            n += target.mibun == 신분_포로 ? 5 : 0;
            n += 45;

            if (pk::has_skill(actor, 특기_안력) and target.mibun == 신분_재야)
                n += 15;

            // 형북 지역이점. 등용확률 상승
            if (target.mibun == 신분_포로 || target.mibun == 신분_재야)
            {
                ExecuteJingBeiMoo(force, n);
            }

            return pk::max(n, 0);
        }

        // ======================================================== 등용 확률 끝 =====================================================================

        // ======================================================== 220 포로 확률 ====================================================================

        void func220(const pk::destroy_info& in info, pk::list<pk::person@>& captured, pk::list<pk::person@>& escaped, bool tactics_bonus)
        {
            pk::hex_object@ attacker = info.attacker;
            pk::hex_object@ target = info.target;

            int attacker_force_id = attacker.get_force_id();
            int target_force_id = target.get_force_id();
            pk::building@ attacker_building = attacker.get_type_id() == pk::building::type_id ? attacker : null;
            pk::unit@ attacker_unit = attacker.get_type_id() == pk::unit::type_id ? attacker : null;
            pk::building@ target_building = target.get_type_id() == pk::building::type_id ? target : null;
            pk::unit@ target_unit = target.get_type_id() == pk::unit::type_id ? target : null;
            int target_border_radius = pk::is_alive(target_building) and target_building.facility == 시설_도시 ? 2 : 1;
            pk::point attacker_pos = attacker.get_pos();
            pk::point target_pos = target.get_pos();
            bool in_border = pk::is_in_range(target_pos, target_border_radius, attacker_pos);
            bool cant_capture = !pk::is_valid_normal_force_id(attacker_force_id) or !pk::is_valid_normal_force_id(target_force_id);
            bool penalty = pk::get_scenario().difficulty == 난이도_특급 and attacker.is_player() and not target.is_player();
            bool has_hobaku_skill = false;
            int hobaku_chance = 0;
            pk::list<pk::person@> prisoner_list;


            bool is_hard = false;

            // 둘다 포로 난이도 상승인 경우
            if (수정된_포로확률 == 1)
                is_hard = true;
            else
            {
                // 유저만 상승인 경우, 공격자가 플레이어 라면
                if (수정된_포로확률 == 3 && attacker.is_player())
                {
                    is_hard = true;
                }
                // AI만 난이도 상승인 경우, 공격자가 AI 라면
                else if (수정된_포로확률 == 2 && !attacker.is_player())
                {
                    is_hard = true;
                }
            }

            // 공격 오브젝트의 포박 특기 보유 확인
            if (pk::is_alive(attacker_unit))
            {
                if (!pk::is_alive(target_building))
                {
                    has_hobaku_skill = in_border and attacker_unit.has_skill(특기_포박);
                    hobaku_chance = int(pk::core::skill_constant(attacker_unit, 특기_포박));
                }
            }
            else if (pk::is_alive(attacker_building))
            {
                int building_id = attacker_building.get_id();
                int hex_object_id = pk::building_id_to_hex_object_id(building_id);
                pk::list<pk::person@> list = pk::get_person_list(hex_object_id, pk::mibun_flags(신분_군주, 신분_도독, 신분_태수, 신분_일반));
                pk::filter_list(list, 무장속성_세력, attacker_force_id, COMPARE_EQ);

                if (list.size == 0)
                    cant_capture = true;

                if (in_border)
                {
                    for (int i = 0; i < list.size; i++)
                    {
                        if (pk::has_skill(list[i], 특기_포박))
                        {
                            has_hobaku_skill = true;
                            hobaku_chance = pk::max(hobaku_chance, int(pk::core::skill_constant(list[i].get_id(), 특기_포박)));
                        }
                    }
                }
            }

            // 목표 오브젝트 무장 확인
            if (pk::is_alive(target_unit))
            {
                for (int i = 0; i < 3; i++)
                {
                    pk::person@ member = pk::get_person(target_unit.member[i]);
                    if (pk::is_alive(member))
                        prisoner_list.push_back(member);
                }
            }
            else if (pk::is_alive(target_building))
            {
                int building_id = target_building.get_id();
                int hex_object_id = pk::building_id_to_hex_object_id(building_id);
                prisoner_list = pk::get_person_list(hex_object_id, pk::mibun_flags(신분_군주, 신분_도독, 신분_태수, 신분_일반));
                pk::filter_list(prisoner_list, 무장속성_세력, target_force_id, COMPARE_EQ);
            }

            int bordered_unit_count = 0;
            int terrain_id = -1;

            if (pk::is_valid_pos(target_pos))
            {
                array<pk::point>@ range = pk::range(target_pos, 0, target_border_radius);
                for (int i = 0; i < range.length; i++)
                {
                    pk::unit@ unit = pk::get_unit(range[i]);
                    if (pk::is_alive(unit) and unit.get_force_id() == attacker_force_id)
                        bordered_unit_count++;
                }
                terrain_id = pk::get_hex(target_pos).terrain;
            }

            if (멸망시_공적감소 == 1)
            {
                //세력이 멸망할 경우 해당 세력 무장들의 공적 감소 (최저 6000)
                if (not info.releasable)
                {
                    for (int i = 0; i < 무장_끝; i++)
                    {
                        pk::person@ person_ = pk::get_person(i);
                        if (!pk::is_alive(person_))
                            continue;

                        if (person_.mibun == 신분_재야 or person_.mibun == 신분_미등장 or person_.mibun == 신분_미발견)
                            continue;

                        if (person_.get_force_id() != target_force_id)
                            continue;

                        if (person_.kouseki <= 10000 and person_.kouseki >= 6000)
                        {
                            person_.kouseki = 6000;
                        }
                        else if (person_.kouseki > 10000)
                        {
                            int koseki = person_.kouseki;
                            koseki *= 0.6f;

                            person_.kouseki = koseki;
                        }
                    }
                }
            }

            for (int i = 0; i < prisoner_list.size; i++)
            {
                pk::person@ person = prisoner_list[i];
                int n = 0;

                if (cant_capture)
                {
                    escaped.push_back(person);
                    continue;
                }

                //세력이 멸망할 경우 마지막 거점의 무장을
                if (not info.releasable)
                {
                    // 포박 난이도 증가가 아닌 경우 모두 포박
                    if (!is_hard)
                    {
                        captured.push_back(person);
                        continue;
                    }
                    // 포박 난이도 증가인 경우 25% 확률로 포박
                    else
                    {
                        int r = pk::rand(1000);
                        
                        if (r % 4 == 0)
                        {
                            captured.push_back(person);
                            continue;
                        }
                    }
                }

                // 플레이어의 이민족 요청일 경우 무조건 탈출
                if (attacker_force_id < 도시_끝)
                {
                    if (pk::is_alive(attacker_unit))
                    {
                        if (attacker_unit.leader >= 적장_시작 && attacker_unit.leader < 적장_끝)
                        {
                            escaped.push_back(person);
                            continue;
                        }
                    }
                }

                // 이민족 무장의 경우도 포로로 잡히지 아니한다.
                if (pk::is_alive(target_unit))
                {
                    if (target_unit.leader >= 적장_시작 && target_unit.leader <= 적장_끝)
                    {
                        escaped.push_back(person);
                        continue;
                    }
                }

                //세력이 멸망하지 않고 아이템 명마 또는 특기 강운을 보유할 경우 무조건 탈출
                if (info.releasable and pk::has_item(person, 보물종류_명마) or pk::has_skill(person, 특기_강운))
                {
                    escaped.push_back(person);
                    continue;
                }

                n += int(pk::core["무장.최대능력치"]) + 20 - pk::max(person.stat[무장능력_무력], person.stat[무장능력_지력]);
                n /= 3;
                if (bordered_unit_count > 1) //포위 부대가 두 개 이상인 경우 확률 증가 (pk 원본에 비해 감소)
                    n *= 100 + 40 * (pk::has_skill(person, 특기_철벽) ? 0 : bordered_unit_count);
                else if (bordered_unit_count == 1)
                    n *= 100;

                if (terrain_id == 지형_습지 or terrain_id == 지형_독천)
                    n *= 1.5f;
                n /= 100;

                pk::force@ attackerForce = pk::get_force(attacker_force_id);
                pk::force@ targetForce = pk::get_force(target_force_id);
                int skillLevel = 0;

                if (tactics_bonus)
                {
                    n += 30;
                }
                else
                {
                    if (attacker_unit != null)
                    {
                        // 산월 지역이점. 공격자가 극병 평타
                        skillLevel = GetRelationLevel(attackerForce, 우호_산월);
                        if (병기_극 == pk::get_weapon_id(attacker_unit) && skillLevel >= 3)
                        {
                            n += 산월_3단계_포박상승;
                        }

                        // 오환 지역이점. 공격자가 기병부대
                        skillLevel = GetRelationLevel(attackerForce, 우호_오환);

                        if (병기_군마 == pk::get_weapon_id(attacker_unit) && skillLevel >= 3)
                        {
                            n += 오환_3단계_포박상승;
                        }
                    }
                }

                if (target_unit != null)
                {
                    // 강 지역이점. 피격자가 기병부대
                    skillLevel = GetRelationLevel(targetForce, 우호_강);
                    if (병기_군마 == pk::get_weapon_id(target_unit) && skillLevel >= 3)
                    {
                        n = (n * (100 - 강_3단계_퇴각상승)) / 100;
                    }

                    // 후위대
                    if (HasUniqueTech(target_force_id, 고유기교_후위대))
                    {
                        n -= 후위대_탈출증가;
                    }
                }
               
                n /= penalty ? 2 : 1;
                n += has_hobaku_skill ? hobaku_chance : 0;

                if (person.mibun == 신분_군주)
                    n -= 7;

                n -= 3;

                if (pk::rand_bool(n))
                    captured.push_back(person);
                else
                {
                    if (info.releasable) //세력이 아직 멸망하지 않았으면 그냥 탈출
                    {
                        escaped.push_back(person);
                    }
                    else 
                    {
                        if (is_hard)
                        {
                            //세력이 멸명할 경우 탈출한 무장들은 의리, 인간관계, 상성에 따라 확률적으로 멸망시킨 세력에 대한 사관금지기간 설정
                            int kunshu_id = pk::get_kunshu_id(attacker);
                            int target_kunshu = pk::get_kunshu_id(target);
                            pk::force@ force_ = pk::get_force(attacker.get_force_id());
                            pk::person@ target_gikyoudai = pk::get_person(person.gikyoudai);
                            pk::person@ target_spouse = pk::get_person(person.spouse);
                            pk::person@ kunshu_ = pk::get_person(kunshu_id);
                            pk::person@ emperor = pk::get_person(pk::get_scenario().emperor);
                            int sagwan = 2 + pk::rand(4);

                            if (pk::is_alive(target_gikyoudai) and target_gikyoudai.get_force_id() == attacker_force_id) //의형제가 멸망시킨 세력내에 있으면 사관금지기간 없음
                            {
                                sagwan = 0;
                            }
                            else if (pk::is_alive(target_spouse) and target_spouse.get_force_id() == attacker_force_id) //배우자가 멸망시킨 세력내에 있으면 사관금지기간 없음
                            {
                                sagwan = 0;
                            }
                            else if (pk::is_like(person, kunshu_id)) //멸망시킨 세력의 군주를 친애하면 사관금지기간 없음
                            {
                                sagwan = 0;
                            }
                            else if (pk::is_ketsuen(person, kunshu_id)) //멸망시킨 세력의 군주와 혈연 관계면 사관금지기간 없음
                            {
                                sagwan = 0;
                            }
                            else if (!pk::is_normal_force(force_)) //멸망시킨 세력이 일반적인 세력이 아닐경우 사관금지기간 없음
                            {
                                sagwan = 0;
                            }
                            else
                            {
                                switch (person.giri) //의리에 따라 사관금지기간 증감
                                {
                                case 의리_매우낮음: sagwan -= 4; break;
                                case 의리_낮음: sagwan -= 2; break;
                                case 의리_보통: sagwan += 1; break;
                                case 의리_높음: sagwan += 2; break;
                                case 의리_매우높음: sagwan += 4; break;
                                }

                                if (person.ambition >= 야망_높음) //야망이 높으면 사관금지기간 소폭 증가
                                    sagwan += 1;

                                if (person.mibun == 신분_군주) //군주일 경우 사관금지기간 증가
                                    sagwan += 3;
                                else if (pk::is_alive(target_gikyoudai) and target_gikyoudai.get_id() == target_kunshu) //의형제가 군주였을 경우 사관금지기간 증가
                                    sagwan += 3;
                                else if (pk::is_alive(target_spouse) and target_spouse.get_id() == target_kunshu) //배우자가 군주였을 경우 사관금지기간 증가
                                    sagwan += 3;
                                else if (pk::is_ketsuen(person, target_kunshu)) //혈연이 군주였을 경우 사관금지기간 증가
                                    sagwan += 3;
                                else if (pk::is_like(person, target_kunshu)) //멸망시킨 세력의 군주를 친애하면 사관금지기간 증가
                                    sagwan += 3;

                                if (pk::is_valid_person_id(target_kunshu) and pk::get_aishou_distance(person, target_kunshu) <= 10) //원래 군주와의 상성차가 적으면 사관금지기간 증가
                                    sagwan += 2;
                                else if (pk::is_valid_person_id(target_kunshu) and pk::get_aishou_distance(person, target_kunshu) <= 30)
                                    sagwan += 1;

                                if (person.kouseki >= 20000) //공적이 높으면 사관금지기간 증가 (위의 멸망시 공적감소를 적용받고난 기준으로 적용됨에 주의)
                                    sagwan += 2;
                                else if (person.kouseki >= 12000)
                                    sagwan += 1;

                                if (force_.kokugou == 국호_황건 or force_.kokugou == 국호_성) //멸망시킨 세력이 황건이나 원술의 제국(성)일 때 한실중시 무장일 경우 사관금지기간 증가
                                {
                                    if (person.kanshitsu == 한실_중시)
                                        sagwan += 3;
                                }
                                else if (emperor !is null and kunshu_.kanshitsu == 한실_무시 and person.kanshitsu == 한실_중시) //한제가 존재할 때 멸망시킨 세력의 군주가 한실무시고 한실중시 무장일 경우 사관금지기간 증가
                                    sagwan += 2;

                                if (person.get_id() == 무장_장각 or person.get_id() == 무장_장보 or person.get_id() == 무장_장량) //황건적의 수괴일 경우 한실중시 군주에 대한 사관금지기간 대폭 증가
                                {
                                    if (kunshu_.kanshitsu == 한실_중시)
                                        sagwan += 5;
                                }

                                if (pk::is_protecting_the_emperor(force_) or force_.kokugou == 국호_한) //멸망시킨 세력이 한실을 보호하고 있거나 국호가 한(후한)일때 한실보통 이상인 장수들은 사관금지기간 감소
                                {
                                    if (person.kanshitsu >= 한실_보통)
                                        sagwan -= 1;
                                }

                                if (person.kanshitsu == 한실_중시 and kunshu_.kanshitsu == 한실_중시) //한실중시 일치시 사관금지기간 감소
                                    sagwan -= 1;

                                if (person.kanshitsu == 한실_무시 and kunshu_.kanshitsu == 한실_무시) //한실무시 일치시 사관금지기간 감소
                                    sagwan -= 1;

                                if (pk::is_valid_person_id(kunshu_id) and pk::get_aishou_distance(person, kunshu_id) <= 10) //상성차가 적으면 사관금지기간 감소
                                    sagwan -= 3;
                                else if (pk::is_valid_person_id(kunshu_id) and pk::get_aishou_distance(person, kunshu_id) <= 20)
                                    sagwan -= 2;
                                else if (pk::is_valid_person_id(kunshu_id) and pk::get_aishou_distance(person, kunshu_id) <= 30)
                                    sagwan -= 1;

                                if (sagwan > 0)
                                {
                                    person.banned_kunshu = kunshu_id;
                                    person.ban_timer = sagwan;
                                }
                            }
                        }
                        escaped.push_back(person);
                    }
                }
            }
        }

        // 209 부대의 공격 데미지
        void func209(pk::damage_info& info, pk::unit@ attacker, int tactics_id, const pk::point& in target_pos, int type, int critical, bool ambush)
        {
            prev_callback_209(info, attacker, tactics_id, target_pos, type, critical, ambush);

            pk::unit@ target_unit = pk::get_unit(target_pos);
            pk::building@ target_building = pk::get_building(target_pos);

            pk::person@ leader = pk::get_person(attacker.leader);

            // 맹호조아
            if (HasUniqueTech(attacker.get_force_id(), 고유기교_맹호조아))
            {
                if (target_unit != null)
                {
                    if (!info.tactics_hit)
                        info.troops_damage = info.troops_damage * (100 + 맹호조아_데미지_증가) / 100;
                }

                if (target_building != null)
                {
                    if (!info.tactics_hit)
                        info.hp_damage = info.hp_damage * (100 + 맹호조아_데미지_증가) / 100;
                }
            }

            if (HasUniqueTech(attacker.get_force_id(), 고유기교_함진영))
            {
                // 거점인 경우
                if (target_building != null)
                {
                    if (pk::is_general_type(target_building))
                    {
                        info.troops_damage = info.troops_damage * (100 + 함진영_도시병력피해증가) / 100;
                    }
                    else if (pk::is_military_type(target_building))
                    {
                        info.hp_damage = info.hp_damage * (100 + 함진영_군사시설피해증가) / 100;
                    }
                }
            }

            if (HasUniqueTech(attacker.get_force_id(), 고유기교_침략황폐))
            {
                if (target_building != null)
                {
                    if (pk::is_military_type(target_building))
                    {
                        info.hp_damage = info.hp_damage * (100 + 침략황폐_내정시설피해증가) / 100;
                    }
                }
            }

            if (target_unit != null)
            {
                int attacker_atk = attacker.attr.stat[부대능력_공격];
                int target_atk = target_unit.attr.stat[부대능력_공격];

                int attacker_int = attacker.attr.stat[부대능력_지력];
                int target_int = target_unit.attr.stat[부대능력_지력];

                // 만인지적
                // 공격부대가 만인지적 기교를 보유한 경우
                
                if (type == 0)
                {
                    if (HasUniqueTech(attacker.get_force_id(), 고유기교_만인지적))
                    {
                        if (attacker.status == 부대상태_통상)
                        {
                            if (attacker_atk > target_atk)
                            {
                                info.troops_damage = info.troops_damage * (100 + 만인지적_피해증가) / 100;
                            }
                        }
                    }

                    // 피격부대가 만인지적 기교를 보유한 경우
                    if (HasUniqueTech(target_unit.get_force_id(), 고유기교_만인지적))
                    {
                        if (target_unit.status == 부대상태_통상)
                        {
                            if (attacker_atk < target_atk)
                            {
                                info.troops_damage = info.troops_damage * (100 - 만인지적_피해경감) / 100;
                            }
                        }
                    }
                }
                else
                {
                    pk::building@ building = pk::get_building(pk::get_building_id(attacker.get_pos()));

                    if (HasUniqueTech(attacker.get_force_id(), 고유기교_팔문금쇄) && !pk::is_enemy(attacker, building))
                    {
                        info.troops_damage = info.troops_damage * (100 + 팔문금쇄_반격증가) / 100;
                    }
                }

                if (target_unit.status != 부대상태_통상)
                {
                    // 효명진천
                    if (HasUniqueTech(attacker.get_force_id(), 고유기교_효명진천))
                    {
                        info.troops_damage = info.troops_damage * (100 + 효명진천_피해증가) / 100;
                    }

                    // 일신시담
                    if (HasUniqueTech(target_unit.get_force_id(), 고유기교_일신시담))
                    {
                        info.troops_damage = info.troops_damage * (100 - 일신시담_피해경감) / 100;
                    }
                }

                // 묘수
                if (HasUniqueTech(attacker.get_force_id(), 고유기교_묘수))
                {
                    int extra_damage = 0;

                    // 전법이 성공했고 공격부대의 지력이 대상 부대의 지력보다 높은경우
                    if (info.tactics_hit && attacker_int > target_int)
                    {
                        extra_damage = 묘수_지력차피해_배수 * (attacker_int - target_int);

                        switch (tactics_id)
                        {
                        case 전법_돌출:
                        case 전법_나선첨:
                        case 전법_이단첨:
                        case 전법_갈퀴:
                        case 전법_돌격:
                        case 전법_돌파:
                        case 전법_돌진:
                        case 전법_공성방사:
                        case 전법_함선격돌:

                            break;

                        case 전법_횡치:
                        case 전법_선풍:
                        case 전법_화시:
                        case 전법_공성화시:
                        case 전법_함선화시:
                            extra_damage = extra_damage / 2;
                            break;

                        case 전법_관시:
                        case 전법_난사:
                        case 전법_공성투석:
                        case 전법_함선투석:
                            extra_damage = extra_damage / 3;
                            break;

                        default:
                            break;
                        }
                    }

                    if (extra_damage > 0)
                    {
                        info.troops_damage = info.troops_damage + extra_damage;
                    }
                }
            }

            // 수성강화
            if (target_building != null)
            {
                if (HasUniqueTech(target_building.get_force_id(), 고유기교_수성강화))
                {
                    pk::building@ building = pk::get_building(pk::get_building_id(target_building.get_pos()));

                    if (building.get_force_id() == target_building.get_force_id())
                    {
                        info.hp_damage = info.hp_damage * (100 - 수성강화_건물피해_경감) / 100;
                    }
                }
            }

            int id;
            int damage = info.troops_damage;
            bool isEliminate = false;

            //if ((attacker.action_done && type == 0) || (type != 0 && target_unit.action_done))
            if (type != 0)
            {
                if (target_unit != null)
                {
                    // 이민족 부대의 경우 패스
                    if (attacker.leader >= 적장_시작 && attacker.leader < 적장_끝)
                        return;

                    // 이민족 부대의 경우 패스
                    if (target_unit.leader >= 적장_시작 && target_unit.leader < 적장_끝)
                        return;

                    id = target_unit.get_id();

                    // 부대가 괴멸 당하는 경우
                    if (target_unit.troops <= damage)
                    {
                        damage = target_unit.troops;
                        isEliminate = true;
                    }

                    int value = 부상병_전환율;

                    if (HasUniqueTech(target_unit.get_force_id(), 고유기교_오두미도))
                    {
                        value = value + 오두미도_추가_전환율;
                    }

                    if (HasUniqueTech(attacker.get_force_id(), 고유기교_주지육림))
                    {
                        value = value * (100 - 주지육림_부상병_경감) / 100;
                    }

                    woundedUnitArray[id] = woundedUnitArray[id] + ((damage * value) / 100);

                    // 공격부대가 생존해있는 경우 대상부대의 부상병을 흡수한다
                    if (isEliminate)
                    {
                        if (attacker.is_alive())
                        {
                            woundedUnitArray[attacker.get_id()] = woundedUnitArray[attacker.get_id()] + ((woundedUnitArray[id] * 부상병_흡수율) / 100);
                            if (부상병_흡수_로그_출력 && 부상병시스템_사용여부 == 1)
                            {
                                string s = pk::format("{}대가 {}대의 부상병 흡수", pk::u8decode(pk::get_name(pk::get_person(attacker.leader))), pk::u8decode(pk::get_name(pk::get_person(target_unit.leader))));
                                pk::history_log(attacker.get_pos(), attacker.get_force_id(), pk::u8encode(s));
                            }
                        }
                    }

                    //string s = pk::format("{}, {}", pk::u8decode(pk::get_name(pk::get_person(target_unit.leader))), damage);
                    //pk::history_log(pk::point(0, 0), -1, pk::u8encode(s));
                }
                // 건물이 고정시설인 경우(거점)
                else if (target_building != null && pk::is_general_type(target_building))
                {
                    id = target_building.get_id();

                    if (target_building.get_troops() <= damage)
                    {
                        damage = target_building.get_troops();
                    }

                    int value = 부상병_전환율;

                    if (HasUniqueTech(target_building.get_force_id(), 고유기교_오두미도))
                    {
                        value = value + 오두미도_추가_전환율;
                    }

                    if (HasUniqueTech(attacker.get_force_id(), 고유기교_주지육림))
                    {
                        value = value * (100 - 주지육림_부상병_경감) / 100;
                    }

                    woundedBuildingArray[id] = woundedBuildingArray[id] + ((damage * value) / 100);

                    //string s = pk::format("{}, {}", pk::u8decode(pk::get_name(target_building)), damage);
                    //pk::history_log(pk::point(0, 0), -1, pk::u8encode(s));
                }
            }
            else
            {
                if (temp_attacker == null)
                {
                    @temp_attacker = attacker;
                }

                if (target_unit != null)
                {
                    if (target_unit_list.contains(target_unit))
                    {
                        int index = target_unit_list.index_of(target_unit);
                        @target_unit_list[index] = target_unit;
                    }
                    else
                    {
                        target_unit_list.add(target_unit);
                    }
                    origin_unit_leader_array[target_unit.get_id()] = target_unit.leader;
                    unit_origin_troops_array[target_unit.get_id()] = target_unit.troops;
                    unit_damage_array[target_unit.get_id()] = damage;
                }
                else if (target_building != null && pk::is_general_type(target_building))
                {
                    if (target_building_list.contains(target_building))
                    {
                        int index = target_building_list.index_of(target_building);
                        @target_building_list[index] = target_building;
                    }
                    else
                    {
                        target_building_list.add(target_building);
                    }

                    building_origin_troops_array[target_building.get_id()] = target_building.get_troops();
                    building_damage_array[target_building.get_id()] = damage;
                }
            }
        }
        
        // 164 부대 혼란 확률
        int func164(pk::unit@ unit)
        {
            int value = prev_callback_164(unit);

            int force_id = unit.get_force_id();

            if (force_id >= 0 && force_id < 도시_끝)
            {
                if (HasUniqueTech(force_id, 고유기교_맹호조아))
                {
                    value = 0;
                }
            }

            return value;
        }

        // 165 부대의 병량 소비
        int func165(pk::unit@ unit)
        {
            int value = prev_callback_165(unit);
           
            int force_id = unit.get_force_id();

            if (force_id >= 0 && force_id < 도시_끝)
            {
                if (HasUniqueTech(force_id, 고유기교_위무지강))
                {
                    value = value * (100 - 위무지강_병량경감) / 100;
                }
            }

            return pk::max(1, value);
        }

        // 부대의 계략 성공 확률
        pk::int_bool func206(pk::unit@ src, const pk::point& in src_pos, const pk::point& in dst_pos, int strategy_id)
        {
            pk::int_bool tuple = prev_callback_206(src, src_pos, dst_pos, strategy_id);

            // 특기로 인한 100% 성공, 100% 실패는 기존의 확률로 반환
            if (tuple.first == 100 && tuple.second == false)
            {
                return tuple;
            }
            else if (tuple.first == 0 && tuple.second == true)
            {
                return tuple;
            }

            // 그 이외의 상황에서는 고유기교의 영향을 반환
            int force_id = src.get_force_id();

            pk::unit@ dst = pk::get_unit(dst_pos);
           
            if (dst != null)
            {
                int dst_force_id = dst.get_force_id();

                if (HasUniqueTech(force_id, 고유기교_이간계))
                {
                    if (dst.deputy[0] != -1 || dst.deputy[1] != -1)
                    {
                        tuple.first = tuple.first * (100 + 이간계_계략증가) / 100;
                    }
                }

                if (strategy_id == 계략_위보 || strategy_id == 계략_교란)
                {
                    if (HasUniqueTech(dst_force_id, 고유기교_비마대))
                    {
                        if (pk::get_weapon_id(dst) == 병기_군마)
                        {
                            tuple.first = tuple.first * (100 - 비마대_계략감소) / 100;
                        }
                    }

                    if (HasUniqueTech(dst_force_id, 고유기교_청주병))
                    {
                        if (pk::get_weapon_id(dst) == 병기_창)
                        {
                            tuple.first = tuple.first * (100 - 청주병_계략감소) / 100;
                        }
                    }

                    if (HasUniqueTech(dst_force_id, 고유기교_동주병))
                    {
                        if (pk::get_weapon_id(dst) == 병기_극)
                        {
                            tuple.first = tuple.first * (100 - 동주병_계략감소) / 100;
                        }
                    }

                    if (HasUniqueTech(dst_force_id, 고유기교_원융노병))
                    {
                        if (pk::get_weapon_id(dst) == 병기_노)
                        {
                            tuple.first = tuple.first * (100 - 원융노병_계략감소) / 100;
                        }
                    }
                }
            }

            return pk::int_bool(tuple.first, false);
        }

        void CalculateWoundedTroops()
        {
            // 부대 검사.  부대가 소멸했거나, 병력이 줄었을 경우
            if (target_unit_list.count > 0)
            {
                for (int i = 0; i < target_unit_list.count; ++i)
                {
                    pk::unit@ unit = target_unit_list[i];
                    int damage = unit_damage_array[unit.get_id()];

                    if (unit_origin_troops_array[unit.get_id()] > unit.troops)
                    {
                        int value = 부상병_전환율;

                        if (HasUniqueTech(unit.get_force_id(), 고유기교_오두미도))
                        {
                            value = value + 오두미도_추가_전환율;
                        }

                        if (HasUniqueTech(temp_attacker.get_force_id(), 고유기교_주지육림))
                        {
                            value = value * (100 - 주지육림_부상병_경감) / 100;
                        }

                        woundedUnitArray[unit.get_id()] = woundedUnitArray[unit.get_id()] + ((damage * value) / 100);

                        // 타깃이 전멸했을 경우
                        if (unit.troops == 0)
                        {
                            if (temp_attacker.get_id() >= 적장_시작 && temp_attacker.leader < 적장_끝)
                                return;

                            if (origin_unit_leader_array[unit.get_id()] >= 적장_시작 && origin_unit_leader_array[unit.get_id()] < 적장_끝)
                                return;

                            // 공격자가 생존해있을 경우 타깃의 부상병 흡수
                            if (temp_attacker.is_alive())
                            {
                                woundedUnitArray[temp_attacker.get_id()] = woundedUnitArray[temp_attacker.get_id()] + ((woundedUnitArray[unit.get_id()] * 부상병_흡수율) / 100);
                                
                                if (부상병_흡수_로그_출력 && 부상병시스템_사용여부 == 1)
                                {
                                    string s = pk::format("{}대가 {}대의 부상병 흡수", pk::u8decode(pk::get_name(pk::get_person(temp_attacker.leader))), pk::u8decode(pk::get_name(pk::get_person(origin_unit_leader_array[unit.get_id()]))));
                                    pk::history_log(temp_attacker.get_pos(), temp_attacker.get_force_id(), pk::u8encode(s));
                                }
                            }
                        }
                        else
                        {
                            //string s = pk::format("{}, {}", pk::u8decode(pk::get_name(pk::get_person(unit.leader))), damage);
                            //pk::history_log(pk::point(0, 0), -1, pk::u8encode(s));
                        }
                    }
                }
            }
            // 건물 검사.  소유 세력이 바뀌었거나, 병력이 줄었을 경우
            if (target_building_list.count > 0)
            {
                for (int i = 0; i < target_building_list.count; ++i)
                {
                    pk::building@ building = target_building_list[i];
                    int damage = building_damage_array[building.get_id()];

                    if (building.get_troops() < building_origin_troops_array[building.get_id()])
                    {
                        int value = 부상병_전환율;

                        if (HasUniqueTech(building.get_force_id(), 고유기교_오두미도))
                        {
                            value = value + 오두미도_추가_전환율;
                        }

                        if (HasUniqueTech(temp_attacker.get_force_id(), 고유기교_주지육림))
                        {
                            value = value * (100 - 주지육림_부상병_경감) / 100;
                        }

                        woundedBuildingArray[building.get_id()] = woundedBuildingArray[building.get_id()] + ((damage * value) / 100);

                        //string s = pk::format("{}, {}", pk::u8decode(pk::get_name(building)), damage);
                        //pk::history_log(pk::point(0, 0), -1, pk::u8encode(s));
                    }
                }
            }
        }

        void ResetTargetList()
        {
            @temp_attacker = null;

            if (target_unit_list.count > 0)
            {
                target_unit_list.clear();
            }

            if (target_building_list.count > 0)
            {
                target_building_list.clear();
            }
        }

        // 210 지원 공격 데미지 =======> 작성은 했지만 210 함수가 작동되지는 않음
        void func210(pk::damage_info& info, pk::unit@ attacker, const pk::point& in target_pos)
        {
            prev_callback_210(info, attacker, target_pos);

            pk::unit@ target_unit = pk::get_unit(target_pos);
            int id;
            int damage = info.troops_damage;
            bool isEliminate = false;

            if (target_unit != null)
            {
                // 이민족 부대의 경우 패스
                if (attacker.leader >= 적장_시작 && attacker.leader < 적장_끝)
                    return;

                // 이민족 부대의 경우 패스
                if (target_unit.leader >= 적장_시작 && target_unit.leader < 적장_끝)
                    return;

                id = target_unit.get_id();

                // 부대가 괴멸 당하는 경우
                if (target_unit.troops <= damage)
                {
                    damage = target_unit.troops;
                    isEliminate = true;
                }

                woundedUnitArray[id] = woundedUnitArray[id] + ((damage * 부상병_전환율) / 100);

                // 공격부대가 생존해있는 경우 대상부대의 부상병을 흡수한다
                if (isEliminate)
                {
                    if (attacker.is_alive())
                    {
                        woundedUnitArray[attacker.get_id()] = woundedUnitArray[attacker.get_id()] + ((woundedUnitArray[id] * 부상병_흡수율) / 100);
                        if (부상병_흡수_로그_출력 && 부상병시스템_사용여부 == 1)
                        {
                            string s = pk::format("{}대가 {}대의 부상병 흡수", pk::u8decode(pk::get_name(pk::get_person(attacker.leader))), pk::u8decode(pk::get_name(pk::get_person(target_unit.leader))));
                            pk::history_log(attacker.get_pos(), attacker.get_force_id(), pk::u8encode(s));
                        }
                    }
                }
            }
        }

        void CheckWaitingUnit()
        {
            if (waiting_leader_id == -1 || waiting_unit_id == -1)
                return;

            if (is_waiting)
            {
                pk::person@ leader = pk::get_person(waiting_leader_id);
                // 부상병은 부대의 소재 거점으로 귀환
                pk::building@ new_service = pk::get_building(leader.service);
                if (new_service != null && pk::is_general_type(new_service))
                {
                    woundedBuildingArray[new_service.get_id()] = woundedBuildingArray[new_service.get_id()] + woundedUnitArray[waiting_unit_id];
                }
                woundedUnitArray[waiting_unit_id] = 0;
                waiting_leader_id = -1;
                waiting_unit_id = -1;
                is_waiting = false;
                //
                //string s = pk::format("{}대, {}(으)로 진입", pk::u8decode(pk::get_name(leader)), pk::u8decode(pk::get_name(new_service)));
                //pk::history_log(leader.get_pos(), leader.get_force_id(), pk::u8encode(s));
            }
        }

        // AI 세력별 고유기교 우선순위 정하기 (랜덤)
        void PrioritizeUniqueTech()
        {
            // 초기화
            for (int i = 0; i < ai_prefer_uniqueTech_data.length; ++i)
            {
                ai_prefer_uniqueTech_data[i] = 0;
            }

            // shuffle 함수용 무장 리스트
            pk::list<pk::person@> person_list;

            for (int m = 1; m < 40; ++m)
            {
                person_list.add(pk::get_person(m));
            }

            for (int i = 0; i < 100; ++i)
            {
                person_list.shuffle();
                
                ConvertMooListToIntArray(person_list, i);
            }
        }

        void ConvertMooListToIntArray(pk::list<pk::person@> person_list, int arrayIndex)
        {
            int start = arrayIndex * 10;

            array<pk::person@> arr = pk::list_to_array(person_list);
            array<int> arr_int(arr.length);
            
            for (int i = 0; i < arr_int.length; ++i)
            {
                int s = i / 4;
                int r = i % 4;

                ai_prefer_uniqueTech_data[s + start] += GetDigit(r) * arr_int[i];
            }
        }

        int GetDigit(int i)
        {
            int value = 1;

            for (int y = 3 - i; y > 0; --y)
            {
                value *= 100;
            }

            return value;
        }

        //void CheckUniqueTech()
        //{
        //    //if (!세력_고유기교_사용)
        //    //    return;
        //
        //    auto force_array = pk::list_to_array(pk::get_force_list());
        //
        //    for (int i = 0; i < force_array.length; ++i)
        //    {
        //        pk::force@ force = force_array[i];
        //        if (!pk::is_alive(force))
        //            continue;
        //
        //        if (force.is_player())
        //            continue;
        //
        //        int force_id = force.get_id();
        //        int tp = 0;
        //
        //        if (force_id >= 세력_강)
        //        {
        //            continue;
        //        }
        //        else
        //        {
        //            for (int i = 0; i < 기교_끝; ++i)
        //            {
        //                if (force.tech[i] == true)
        //                {
        //                    tp += pk::get_tech(i).tp_cost;
        //                }
        //            }
        //
        //            // 아직 고유 기교가 없는 경우
        //            if (GetUniqueTech(force_id) == 0)
        //            {
        //                auto arr = GetValidTech(force.kunshu);
        //                
        //                if (arr[0] == -1)
        //                {
        //                    // 세력에 배정된 고유기교 없음
        //                }
        //                else
        //                {
        //                    // 조건을 만족한 경우
        //                    if (tp >= arr[2])
        //                    {
        //                        string name;
        //
        //                        if (force.kokugou != -1)
        //                        {
        //                            if (force.is_player())
        //                            {
        //                                name = "아군";
        //                            }
        //                            else
        //                            {
        //                                name = pk::format("\x1b[2x{}\x1b[0x군", pk::u8decode(pk::get_kokugou(force.kokugou).get_name()));
        //                            }
        //                        }
        //                        else
        //                        {
        //                            if (force.is_player())
        //                            {
        //                                name = "아군";
        //                            }
        //                            else
        //                            {
        //                                name = pk::format("\x1b[2x{}\x1b[0x군", pk::u8decode(pk::get_name(pk::get_person(force.kunshu))));
        //                            }
        //                        }
        //
        //                        uniqueTechArray[force_id] = arr[1];
        //
        //                        pk::message_box(pk::u8encode(pk::format("{}이 고유기교 {}(을)를 획득했습니다", name, 고유기교_이름[arr[1]])));
        //                        pk::history_log(pk::get_person(force.kunshu).get_pos(), force.color, pk::u8encode(pk::format("{} 고유기교 {} 획득.", name, 고유기교_이름[arr[1]])));
        //                    }
        //                }
        //            }
        //        }
        //    }
        //}

        pk::force@ unique_tech_player_force;

        void UpdateUniqueTech(pk::force@ force)
        {
            if (고유기교_사용여부 == 0)
                return;

            int force_id = force.get_force_id();
            
            if (force_id >= 세력_강)
                return;

            if (!pk::is_alive(force))
                return;

            int slot_count = uniqueTechCount[force_id];
            int tp = 0;

            for (int i = 0; i < 기교_끝; ++i)
            {
                if (force.tech[i] == true)
                {
                    tp += pk::get_tech(i).tp_cost;
                }
            }

            if (force.is_player())
            {
                Update_Player_UniqueTech(force_id, slot_count);

                if (slot_count >= 4)
                    return;

                if (tp >= 플레이어_고유기교_개방조건[slot_count])
                {
                    slot_count += 1;
                    uniqueTechCount[force_id] = slot_count;
                    // 슬롯 추가 이벤트
                    @unique_tech_player_force = force;
                    pk::scene(pk::scene_t(UniqueTech_Event));

                    pk::person@ kunshu = pk::get_person(force.kunshu);
                    string s = "";
                    if (force.kokugou != -1)
                    {
                        s = pk::u8decode(pk::get_name(pk::get_kokugou(force.kokugou)));
                    }
                    else
                    {
                        s = pk::u8decode(pk::get_name(kunshu));
                    }
                    pk::history_log(kunshu.get_pos(), force.color, pk::u8encode(pk::format("\x1b[2x{}군\x1b[0x 고유기교 슬롯 추가.", s)));
                }
            }
            else
            {
                int day = pk::get_day();

                if (day != 1)
                    return;

                if (slot_count < 4)
                {
                    // AI의 경우 게임 정해진 우선순위의 고유기교를 슬롯에 먼저 채워넣는다.
                    if (tp >= AI_고유기교_개방조건[slot_count])
                    {
                        pk::person@ kunshu = pk::get_person(force.kunshu);
                        string s = "";
                        if (force.kokugou != -1)
                        {
                            s = pk::u8decode(pk::get_name(pk::get_kokugou(force.kokugou)));
                        }
                        else
                        {
                            s = pk::u8decode(pk::get_name(kunshu));
                        }

                        slot_count += 1;
                        uniqueTechCount[force_id] = slot_count;
                        pk::history_log(kunshu.get_pos(), force.color, pk::u8encode(pk::format("\x1b[2x{}군\x1b[0x 고유기교 슬롯 추가.", s)));
                    }
                }

                Update_AI_UniqueTech(force_id, slot_count);
            }
        }

        // 유저의 고유기교 체크 (매턴)
        void Update_Player_UniqueTech(int force_id, int slot_count)
        {
            pk::list<pk::person@> list;
            //pk::list<pk::person@> originList;
            int kunshu = pk::get_force(force_id).kunshu;
            pk::person@ kunshu_moo = pk::get_person(kunshu);
            pk::force@ force = pk::get_force(force_id);
            for (int i = 0; i < 고유기교_무장목록.length; ++i)
            {
                pk::person@ moo = pk::get_person(고유기교_무장목록[i][0]);

                if (moo.get_force_id() == force_id)
                {
                    // 생존중이고 포로가 아닌 무장
                    if (moo.is_alive() && moo.mibun != 신분_포로)
                    {
                        int unique_id = GetPersonUniqueTech(moo.get_id());

                        // 한실중시 군주인 경우 당도고 패스
                        if (unique_id == 고유기교_당도고 && kunshu_moo.kanshitsu == 한실_중시)
                            continue;

                        // 군주의 경우 목록에 추가
                        if (moo.get_id() == kunshu)
                        {
                            list.add(moo);
                        }
                        else
                        {
                            // 부하의 경우 공적조건 체크
                            if (IsSatisfyKouseki(moo.get_id()))
                            {
                                list.add(moo);
                            }
                        }
                    }
                }
            }
            array<int> unique_tech_array(4);
            int unique_tech_data = GetUniqueTechData(force_id);
            unique_tech_array[0] = unique_tech_data / 1000000;
            unique_tech_array[1] = (unique_tech_data / 10000) % 100;
            unique_tech_array[2] = (unique_tech_data / 100) % 100;
            unique_tech_array[3] = unique_tech_data % 100;

            string s = "";
            if (force.kokugou != -1)
            {
                s = pk::u8decode(pk::get_name(pk::get_kokugou(force.kokugou)));
            }
            else
            {
                s = pk::u8decode(pk::get_name(kunshu_moo));
            }

            for (int i = 0; i < 4; ++i)
            {
                if (unique_tech_array[i] == 0)
                    continue;
                else
                {
                    bool isExist = false;

                    for (int j = 0; j < list.count; ++j)
                    {
                        if (GetPersonUniqueTech(list[j].get_id()) == unique_tech_array[i])
                        {
                            isExist = true;
                            break;
                        }
                    }

                    if(!isExist)
                    {
                        // 메시지 후 고유기교 삭제
                        SetUniqueTech(force_id, 0, i);
                        pk::play_se(27);
                        pk::history_log(kunshu_moo.get_pos(), force.color, pk::u8encode(pk::format("\x1b[2x{}군\x1b[0x의 고유기교 {} 해제", s, 고유기교_이름[unique_tech_array[i]])));
                        pk::message_box(pk::u8encode(pk::format("고유기교 {}(이)가 해제 되었습니다.", 고유기교_이름[unique_tech_array[i]])));
                    }
                }
            }
        }

        void Update_AI_UniqueTech(int force_id, int slot_count)
        {
            if (slot_count <= 0)
                return;

            pk::list<pk::person@> list;
            pk::list<pk::person@> originList;
            int kunshu = pk::get_force(force_id).kunshu;

            for (int i = 0; i < 고유기교_무장목록.length; ++i)
            {
                pk::person@ moo = pk::get_person(고유기교_무장목록[i][0]);
                
                if (moo.get_force_id() == force_id)
                {
                    // AI의 경우 부하 무장이 생존중이면 고유기교 적용 가능
                    if (moo.is_alive())
                    {
                        list.add(moo);
                        originList.add(moo);
                    }
                }
            }

            array<int> prefer_arr = GetUniqueTechPriority(force_id);

            // 원본 데이터 백업
            array<int> originSkill(originList.count);
            for (int i = 0; i < originList.count; ++i)
            {
                originSkill[i] = originList[i].skill;
            }

            // skill을 고유기교 우선순위로 변경 (군주일 경우는 -1로 변환해서 최우선 처리)
            for (int i = 0; i < list.count; ++i)
            {
                if (list[i].get_id() == kunshu)
                    list[i].skill = -1;
                else
                {
                    list[i].skill = GetRankUniqueTechPriority(GetPersonUniqueTech(list[i].get_id()), prefer_arr);
                }
            }

            list.sort(function(a, b)
            {
                return (a.skill < b.skill);
            });

            
            int currIndex = 0;
            uniqueTechArray[force_id] = 0;

            pk::person@ kunshu_moo = pk::get_person(kunshu);
            // 조건에 맞춰서 고유기교 세팅
            // 1. 군주의 고유기교가 있다면 최우선으로, 중복고유기교는 패스
            for (int i = 0; i < list.count; ++i)
            {
                if (currIndex >= slot_count)
                {
                    break;
                }

                int unique_id = GetPersonUniqueTech(list[i].get_id());

                // 한실중시 군주는 당도고 패스
                if (unique_id == 고유기교_당도고 && kunshu_moo.kanshitsu == 한실_중시)
                    continue;

                // 군주가 최우선
                if (list[i].get_id() == kunshu)
                {
                    uniqueTechArray[force_id] += GetDigit(currIndex) * unique_id;
                    currIndex++;
                }
                else
                {
                    // 중복 체크
                    if (HasUniqueTech(force_id, unique_id))
                    {
                        continue;
                    }

                    // 공적 체크
                    if (IsSatisfyKouseki(list[i].get_id()))
                    {
                        uniqueTechArray[force_id] += GetDigit(currIndex) * unique_id;
                        currIndex++;
                    }
                }
            }

            // 데이터 롤백
            for (int i = 0; i < originList.count; ++i)
            {
                originList[i].skill = originSkill[i];
            }
        }


        void UniqueTech_Event()
        {
            //int slot_count = uniqueTechCount[force_id];

            // 짤막한 상황극
        }

        array<int> GetUniqueTechPriority(int force_id)
        {
            array<int> arr(40);
            int type = ai_uniqueTech_perfer_type[force_id];

            for (int i = 0; i < 10; ++i)
            {
                arr[i * 4] = ai_prefer_uniqueTech_data[type * 10 + i] / 1000000;
                arr[i * 4 + 1] = (ai_prefer_uniqueTech_data[type * 10 + i] / 10000) % 100;
                arr[i * 4 + 2] = (ai_prefer_uniqueTech_data[type * 10 + i] / 100) % 100;
                arr[i * 4 + 3] = ai_prefer_uniqueTech_data[type * 10 + i] % 100;
            }

            return arr;
        }

        int GetRankUniqueTechPriority(int ut, array<int> priority)
        {
            for (int i = 0; i < priority.length; ++i)
            {
                if (priority[i] == ut)
                    return i;
            }

            return -1;
        }

        int GetPersonUniqueTech(int moo)
        {
            if (moo == -1)
                return 0;

            for (int i = 0; i < 고유기교_무장목록.length; ++i)
            {
                if (고유기교_무장목록[i][0] == moo)
                    return 고유기교_무장목록[i][1];
            }

            return 0;
        }

        bool IsSatisfyKouseki(int moo)
        {
            pk::person@ p = pk::get_person(moo);

            for (int i = 0; i < 고유기교_무장목록.length; ++i)
            {
                if (고유기교_무장목록[i][0] == moo)
                {
                    if (p.kouseki >= 고유기교_무장목록[i][2])
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }
            }

            return false;
        }

        //array<int> GetValidTech(int kunshuId)
        //{
        //    for (int i = 0; i < 고유기교_무장목록.length; ++i)
        //    {
        //        if (고유기교_무장목록[i][0] == kunshuId)
        //        {
        //            return 고유기교_무장목록[i];
        //        }
        //    }
        //
        //    return { -1 };
        //}
        //

        // 세력별 적용 고유기교 데이터 반환
        int GetUniqueTechData(int force_id)
        {
            if (force_id >= 도시_끝 || force_id <= -1)
                return 0;
        
            return uniqueTechArray[force_id];
        }

        // 플레이어 세력의 고유기교 적용을 위한 데이터    0 : 슬롯 부족,  1 : 고유기교 무장 없음, 2 : 기교p 부족, 3 : 정상, 4 : 사용안함 설정
        int GetUniqueTechApplyData(pk::force@ force)
        {
            if (고유기교_사용여부 == 0)
                return 4;

            int slot_count = uniqueTechCount[force.get_force_id()];

            if (slot_count <= 0)
                return 0;

            int valid_count = GetValidUniqueTechMooList(force).count;

            if (valid_count <= 0)
                return 1;

            if (force.tp < 500)
                return 2;

            return 3;
        }

        pk::list<pk::person@> GetValidUniqueTechMooList(pk::force@ force)
        {
            pk::list<pk::person@> list;
            int kunshu = pk::get_force(force.get_force_id()).kunshu;

            for (int i = 0; i < 고유기교_무장목록.length; ++i)
            {
                pk::person@ moo = pk::get_person(고유기교_무장목록[i][0]);

                if (moo.get_force_id() == force.get_force_id())
                {
                    if (moo.is_alive())
                    {
                        list.add(moo);
                    }
                }
            }

            pk::list<pk::person@> valid_list;

            if (list.count > 0)
            {
                for (int i = 0; i < list.count; ++i)
                {
                    if (list[i].get_id() == kunshu)
                    {
                        valid_list.add(list[i]);
                        continue;
                    }

                    if (IsSatisfyKouseki(list[i].get_id()))
                    {
                        valid_list.add(list[i]);
                    }
                }
            }

            return valid_list;
        }

        void SetUniqueTech(int force_id, int unique_tech, int digit)
        {
            int data = uniqueTechArray[force_id];
            int origin;
            switch (digit)
            {
            case 0 :
                origin = data / 1000000;
                data -= 1000000 * origin;
                data += 1000000 * unique_tech;
                break;

            case 1:
                origin = (data / 10000) % 100;
                data -= 10000 * origin;
                data += 10000 * unique_tech;
                break;

            case 2:
                origin = (data / 100) % 100;
                data -= 100 * origin;
                data += 100 * unique_tech;
                break;

            case 3:
                origin = data % 100;
                data -= origin;
                data += unique_tech;
                break;
            }

            uniqueTechArray[force_id] = data;
        }

        void UpdateHoryo()
        {
            array<pk::person@> horyo_array = pk::list_to_array(pk::get_person_list(신분_포로));

            for (int i = 0; i < horyo_array.length; ++i)
            {
                pk::person@ person = horyo_array[i];

                if (person.is_alive())
                {
                    pk::building@ building = pk::get_building(person.get_pos());

                    if (building != null)
                    {
                        if (HasUniqueTech(building.get_force_id(), 고유기교_자모위용))
                        {
                            pk::add_loyalty(person, -1 * 자모위용_충성하락);
                        }
                    }
                }
            }
        }

        void UpdatePillage(pk::force@ force)
        {
            if (HasUniqueTech(force.get_force_id(), 고유기교_주지육림))
            {
                array<pk::unit@> unit_array = pk::list_to_array(pk::get_unit_list(force));
                bool is_say = false;

                for (int i = 0; i < unit_array.length; ++i)
                {
                    pk::unit@ unit = unit_array[i];
                    pk::city@ city = pk::get_city(pk::get_city_id(unit.get_pos()));

                    if (city == null || !unit.is_alive())
                    {
                        continue;
                    }
                    else
                    {
                        int distance;
                        int gold;
                        if (true == pk::is_enemy(unit, city))
                        {
                            distance = pk::get_distance(unit.get_pos(), city.get_pos());
                        }
                        else
                        {
                            continue;
                        }

                        // 도시와 5칸 이상 떨어져 있는경우 패스
                        if (distance >= 5)
                        {
                            continue;
                        }

                        pk::building@ building = pk::get_building(city.get_id());

                        gold = pk::get_gold(building);

                        // 도시의 금이 없는경우 패스
                        if (gold <= 0)
                        {
                            continue;
                        }

                        int troops = unit.troops;

                        // 병사가 1000명 미만인 경우 패스
                        if (troops < 1000)
                        {
                            continue;
                        }

                        int value = troops * 주지육림_금약탈_비율 / 100;
                        value = pk::min(value, 주지육림_금약탈_최대);
                        value = value / distance;
                        //value = pk::min(value, gold);
                        
                        if (value <= 0)
                            continue;

                        pk::add_gold(building, -1 * value, true);
                        pk::add_gold(unit, value, true);

                        if (pk::is_in_screen(unit.get_pos()))
                        {
                            if (!is_say)
                            {
                                is_say = true;
                                if (pk::rand_bool(50))
                                {
                                    pk::say(pk::u8encode("주군의 명이다. 적의 금을 빼앗아라!"), pk::get_person(unit.leader), unit);
                                }
                                else
                                {
                                    pk::say(pk::u8encode("하하하. 놈들의 금을 가져왔다! "), pk::get_person(unit.leader), unit);
                                }
                            }

                        }
                    }
                }
            }
        }

        // 150 금 수입
        int func150(pk::city@ city)
        {
            int value = prev_callback_150(city);

            int force_id = city.get_force_id();

            if (HasUniqueTech(force_id, 고유기교_왕좌지재))
            {
                pk::facility@ facility = pk::get_facility(시설_시장);
                int add_value = 0;
                int y = facility.yield * 왕좌지재_시설당_추가금 / 100;

                for (auto i = 0; i < city.max_devs; i++)
                {
                    pk::building@ building = city.dev[i].building;
                    int facility_id = -1;

                    if (pk::is_alive(building))
                    {
                        facility_id = building.facility;
                        if (!building.completed)
                            continue;

                        if (facility_id == 시설_시장 || facility_id == 시설_대시장 || facility_id == 시설_어시장 || facility_id == 시설_암시장 || facility_id == 시설_시장2단 || facility_id == 시설_시장3단)
                            continue;
                    }

                    add_value += y;
                }

                switch (pk::get_scenario().difficulty)
                {
                case 난이도_특급:
                    // 특급일 경우 플레이어 0.75배, 컴퓨터 1.25배.
                    if (city.is_player())
                        add_value = add_value * 0.75f;
                    else
                        add_value = add_value * 1.25f;
                    break;

                case 난이도_초급:
                    // 초급일 경우 플레이어, 컴퓨터 모두 1.25배.
                    add_value = add_value * 1.25f;
                    break;
                }
                value += add_value;
            }

            return value;
        }

        // 151 병량 수입
        int func151(pk::city@ city)
        {
            int value = prev_callback_151(city);

            int force_id = city.get_force_id();

            if (HasUniqueTech(force_id, 고유기교_오두미도))
            {
                pk::facility@ facility = pk::get_facility(시설_농장);
                int add_value = 0;
                int y = facility.yield * 오두미도_시설당_추가병량 / 100;

                for (auto i = 0; i < city.max_devs; i++)
                {
                    pk::building@ building = city.dev[i].building;
                    int facility_id = -1;

                    if (pk::is_alive(building))
                    {
                        facility_id = building.facility;
                        if (!building.completed)
                            continue;

                        if (facility_id == 시설_농장 || facility_id == 시설_군둔농 || facility_id == 시설_농장2단 || facility_id == 시설_농장3단)
                            continue;
                    }

                    add_value += y;
                }

                switch (pk::get_scenario().difficulty)
                {
                case 난이도_특급:
                    // 특급일 경우 플레이어 0.75배, 컴퓨터 1.25배.
                    if (city.is_player())
                        add_value = add_value * 0.75f;
                    else
                        add_value = add_value * 1.25f;
                    break;

                case 난이도_초급:
                    // 초급일 경우 플레이어, 컴퓨터 모두 1.25배.
                    add_value = add_value * 1.25f;
                    break;
                }
                value += add_value;
            }

            return value;
        }
        
        // 지원 공격 확률
        int func200(pk::unit@ assister, pk::unit@ attacker, pk::unit@ target)
        {
            int value = prev_callback_200(assister, attacker, target);

            int force_id = assister.get_force_id();

            if (HasUniqueTech(force_id, 고유기교_인화))
            {
                value += 인화_지원증가;
            }

            return value;
        }

        // 공격 크리티컬 확률
        bool func201(pk::unit@ attacker, pk::hex_object@ target, int tactics_id, bool ranged)
        {
            // 이전 공격 크리티컬 
            bool enabled = prev_callback_201(attacker, target, tactics_id, ranged);

            pk::unit@ target_unit = pk::hex_object_to_unit(target);

            // 대상 부대가 없는 경우
            if (target_unit == null)
                return enabled;

            if (pk::is_valid_tactics_id(tactics_id))
            {
                if (pk::is_enemy(attacker, target) && pk::is_on_fire(target_unit.get_pos()))
                {
                    if (HasUniqueTech(attacker.get_force_id(), 고유기교_미주랑))
                    {
                        if (enabled == false)
                        {
                            if (HasUnitUniqueTechMoo(attacker, 고유기교_미주랑))
                            {
                                enabled = pk::rand_bool(미주랑_크리확률증가 * 2);
                            }
                            else
                            {
                                enabled = pk::rand_bool(미주랑_크리확률증가);
                            }
                        }
                    }
                }
            }

            return enabled;
        }

        int func202(pk::unit@ attacker, const pk::point& in pos, pk::hex_object@ target, int tactics_id)
        {
            int value = prev_callback_202(attacker, pos, target, tactics_id);

            // 공성전법은 무조건 100%
            if (tactics_id == 전법_공성화시 || tactics_id == 전법_공성파쇄 || tactics_id == 전법_공성방사 || tactics_id == 전법_공성투석)
            {
                return 100;
            }

            if (HasUniqueTech(attacker.get_force_id(), 고유기교_군신))
            {
                value = value + 군신_전법성공률;
            }

            if (HasUniqueTech(attacker.get_force_id(), 고유기교_당도고))
            {
                pk::force@ force = pk::get_force(attacker.get_force_id());
                
                if (force.title == 작위_황제)
                {
                    value = value + 당도고_전법성공률;
                }
            }

            if (HasUniqueTech(target.get_force_id(), 고유기교_신기))
            {
                value = value * (100 - 신기_전법성공률) / 100;
            }

            value = pk::min(100, value);

            return value;
        }

        // 덕왕위덕
        void UpdateKingOfVirtue(pk::force@ force)
        {
            if (HasUniqueTech(force.get_force_id(), 고유기교_덕왕위덕))
            {
                auto force_city_array = pk::list_to_array(pk::get_city_list(force));
                pk::list<pk::city@> valid_city_list;

                for (int i = 0; i < force_city_array.length; ++i)
                {
                    for (int j = 0; j < 도시_끝; ++j)
                    {
                        pk::city@ city = pk::get_city(j);

                        if (city.get_force_id() == force.get_force_id())
                        {
                            continue;
                        }

                        if (pk::has_neighbor(city, j))
                        {
                            if (!valid_city_list.contains(city))
                            {
                                valid_city_list.add(city);
                            }
                        }
                    }
                }

                for (int i = 0; i < valid_city_list.count; ++i)
                {
                    pk::add_public_order(valid_city_list[i], 덕왕위덕_치안감소, true);
                }
            }
        }

        // 남만왕
        void UpdateKingOfNamman()
        {
            auto unit_array = pk::list_to_array(pk::get_unit_list());

            for (int i = 0; i < unit_array.length; ++i)
            {
                pk::building@ building = pk::get_building(pk::get_building_id(unit_array[i].get_pos()));

                if (HasUniqueTech(building.get_force_id(), 고유기교_남만왕))   
                {
                    if (pk::is_enemy(building, unit_array[i]))
                    {
                        pk::add_energy(unit_array[i], -남만왕_기력저하, true);
                    }
                }
            }
        }

        pk::force@ talent_force;
        // 팔준
        void UpdateTalentPerson()
        {
            auto force_array = pk::list_to_array(pk::get_force_list());

            for (int i = 0; i < force_array.length; ++i)
            {
                pk::force@ force = force_array[i];

                if (!force.is_alive())
                    continue;

                if (HasUniqueTech(force.get_force_id(), 고유기교_팔준))
                {
                    @talent_force = force;
                    pk::scene(pk::scene_t(ExecuteTalentPerson));
                }
            }
        }

        void ExecuteTalentPerson()
        {
            int type; 

            if (talent_force.is_player())
            {
                type = pk::choose(pk::u8encode("실시할 교련을 선택해주십시오."), 팔준_이름);

                if (type == 4)
                {
                    return;
                }
                else
                {
                    auto person_list = pk::get_person_list(talent_force, pk::mibun_flags(신분_군주, 신분_도독, 신분_태수, 신분_일반));

                    person_list = SortByMooStat(person_list, type);

                    pk::list<pk::person@> educator_sel = pk::person_selector(pk::u8encode("장수 선택"), pk::u8encode("교련을 실행할 무장을 선택해주십시오."), person_list, 1, 1);

                    if (educator_sel.count <= 0)
                    {
                        ExecuteTalentPerson();
                        return;
                    }
                    else
                    {
                        pk::list<pk::person@> valid_person_list;

                        for (int i = 0; i < person_list.count; ++i)
                        {
                            pk::person@ person = person_list[i];

                            if (person.get_id() == educator_sel[0].get_id())
                                continue;

                            if (person.stat[type] >= educator_sel[0].stat[type])
                                continue;

                            valid_person_list.add(person);
                        }

                        if (valid_person_list.count <= 0)
                        {
                            pk::message_box(pk::u8encode("해당 무장에게서 교련이 가능한 대상이 존재하지 않습니다."));
                            ExecuteTalentPerson();
                            return;
                        }

                        valid_person_list = SortByMooStat(valid_person_list, type);

                        //valid_person_list.sort(function(a, b)
                        //{
                        //    return (a.stat[type] > b.stat[type]);
                        //});

                        int index = person_list.index_of(educator_sel[0]);
                        pk::list<pk::person@> person_sel = pk::person_selector(pk::u8encode("장수 선택"), pk::u8encode("교련 대상 무장을 선택해주십시오."), valid_person_list, 1, 10);

                        pk::list<pk::person@> valid_list;
                        pk::list<pk::person@> unValid_list;

                        if (person_sel.count <= 0)
                        {
                            ExecuteTalentPerson();
                            return;
                        }
                        else
                        {
                            for (int i = 0; i < person_sel.count; ++i)
                            {
                                // 서로 혐오 대상인지 ?
                                if (pk::is_dislike(person_sel[i], educator_sel[0].get_id()) || pk::is_dislike(educator_sel[0], person_sel[i].get_id()))
                                {
                                    unValid_list.add(person_sel[i]);
                                }
                                else
                                {
                                    valid_list.add(person_sel[i]);
                                }
                            }
                        }

                        if (unValid_list.count > 0)
                        {
                            string member = "";

                            for (int i = 0; i < unValid_list.count; ++i)
                            {
                                if (i == 0)
                                {
                                    member = member + pk::u8decode(pk::get_name(unValid_list[i]));
                                }
                                else
                                {
                                    member = member + ", " + pk::u8decode(pk::get_name(unValid_list[i]));
                                }
                            }

                            string ment = "";
                            for (int i = 0; i < unValid_list.count; ++i)
                            {
                                int rand = pk::rand(100);
                                
                                if (rand <= 33)
                                {
                                    ment = pk::u8encode(pk::format("비록 명령이라고 해도 \x1b[2x{}\x1b[0x 따위에게 가르침을 받을 순 없다.", pk::u8decode(pk::get_name(educator_sel[0]))));
                                }
                                else if (rand <= 66)
                                {
                                    ment = pk::u8encode("건강이 좋지 않아서 교련에 참여하지 못하겠습니다.");
                                }
                                else
                                {
                                    ment = pk::u8encode("저는 더 배울것이 없다고 생각되니 다른 이를 찾아주십시오.");
                                }

                                // 잃는 소리
                                pk::play_se(27);
                                pk::message_box(ment, unValid_list[i]);
                            }
                            // 혐오무장 참가 안함 멘트
                            pk::message_box(pk::u8encode(pk::format("다음의 무장이 교련에 참가하지 않았습니다. \n\x1b[2x{}\x1b[0x", member)));
                        }

                        if (valid_list.count > 0)
                        {
                            pk::list<pk::person@> critical_list;
                            pk::person@ educator = educator_sel[0];
                            int critical_count = 0;
                            string critical_member = "";

                            int critical_percent = (educator.stat[무장능력_매력] - 50) / 10;
                            if (critical_percent <= 0)
                                critical_percent = 0;

                            for (int i = 0; i < valid_list.count; ++i)
                            {
                                int exp = 0;
                                int bonus = 0;
                                pk::person@ trainee = valid_list[i];
                                
                                int gap = educator.stat[type] - trainee.stat[type];

                                if (gap >= 20)
                                {
                                    exp = 팔준_능력최대경험치;
                                }
                                else
                                {
                                    exp = gap * 2;
                                }

                                exp = pk::max(팔준_능력최소경험치, exp);

                                trainee.stat_exp[type] = trainee.stat_exp[type] + exp;

                                if (pk::is_like(educator, trainee.get_id()) || pk::is_like(trainee, educator.get_id()))
                                {
                                    bonus = 5;
                                }

                                if (pk::rand_bool(critical_percent + bonus))
                                {
                                    int heishu_type = GetRandomHeishuTraining(educator, trainee);
                                    
                                    if (heishu_type != -1)
                                    {
                                        trainee.heishu_exp[heishu_type] = trainee.heishu_exp[heishu_type] + 팔준_적성경험치;
                                        critical_count++;
                                        critical_list.add(trainee);
                                        if (i == 0)
                                        {
                                            critical_member = critical_member + pk::u8decode(pk::get_name(trainee));
                                        }
                                        else
                                        {
                                            critical_member = critical_member + ", " + pk::u8decode(pk::get_name(trainee));
                                        }
                                    }
                                }
                            }
                            // 참가 멘트 및 교련 효과
                            pk::play_se(6);
                            pk::message_box(pk::u8encode(pk::format("교련에 참여한 모든 무장의 {} 경험치가 상승했습니다.", 무장능력_이름[type])));
                            if (critical_count > 0)
                            {
                                pk::play_se(10);
                                pk::message_box(pk::u8encode(pk::format("다음의 무장이 추가 효과로 특정 병종 경험치가 상승했습니다. \n\x1b[2x{}\x1b[0x", critical_member)));
                            }
                        }
                    }
                }
            }
            else
            {
                // AI의 교련
                type = pk::rand(10000) % 4;

                auto person_list = pk::get_person_list(talent_force, pk::mibun_flags(신분_군주, 신분_도독, 신분_태수, 신분_일반));

                person_list = SortByMooStat(person_list, type);

                //person_list.sort(function(a, b)
                //{
                //    return (a.stat[type] > b.stat[type]);
                //});

                pk::person@ educator = person_list[0];

                int critical_percent = (educator.stat[무장능력_매력] - 50) / 10;
                if (critical_percent <= 0)
                    critical_percent = 0;

                for (int i = 1; i < person_list.count; ++i)
                {
                    int exp = 0;
                    int bonus = 0;
                    pk::person@ trainee = person_list[i];

                    int gap = educator.stat[type] - trainee.stat[type];

                    if (gap >= 20)
                    {
                        exp = 팔준_능력최대경험치;
                    }
                    else
                    {
                        exp = gap * 2;
                    }

                    exp = pk::max(팔준_능력최소경험치, exp);

                    trainee.stat_exp[type] = trainee.stat_exp[type] + exp;

                    if (pk::is_like(educator, trainee.get_id()) || pk::is_like(trainee, educator.get_id()))
                    {
                        bonus = 5;
                    }

                    if (pk::rand_bool(critical_percent + bonus))
                    {
                        int heishu_type = GetRandomHeishuTraining(educator, trainee);

                        if (heishu_type != -1)
                        {
                            trainee.heishu_exp[heishu_type] = trainee.heishu_exp[heishu_type] + 팔준_적성경험치;
                        }
                    }

                    if (i >= 11)
                        break;
                }

                pk::person@ kunshu = pk::get_person(talent_force.kunshu);
                string s = "";

                if (talent_force.kokugou != -1)
                {
                    s = pk::u8decode(pk::get_name(pk::get_kokugou(talent_force.kokugou)));
                }
                else
                {
                    s = pk::u8decode(pk::get_name(kunshu));
                }
                pk::history_log(kunshu.get_pos(), talent_force.color, pk::u8encode(pk::format("\x1b[2x{}군\x1b[0x, \x1b[1x팔준\x1b[0x에 의해 교련 실시.", s)));
            }
        }

        int GetRandomHeishuTraining(pk::person@ educator, pk::person@ trainee)
        {
            array<int> random_heishu_array = { -1, -1, -1, -1, -1, -1 };

            for (int i = 0; i < random_heishu_array.length; ++i)
            {
                bool is_done = false;

                while (!is_done)
                {
                    int r = pk::rand(1000) % 6;
                    if (random_heishu_array[i] != r)
                    {
                        random_heishu_array[i] = r;
                        is_done = true;
                    }
                }
            }

            bool is_satisfy = false;

            for (int i = 0; i < random_heishu_array.length; ++i)
            {
                int type = random_heishu_array[i];

                if (trainee.tekisei[i] < educator.tekisei[i])
                    return type;
            }

            return -1;
        }

        pk::list<pk::person@> SortByMooStat(pk::list<pk::person@> origin ,int type)
        {
            if (type == 무장능력_통솔)
            {
                origin.sort(function(a, b)
                {
                    return (a.stat[무장능력_통솔] > b.stat[무장능력_통솔]);
                });
            }
            else if (type == 무장능력_무력)
            {
                origin.sort(function(a, b)
                {
                    return (a.stat[무장능력_무력] > b.stat[무장능력_무력]);
                });
            }
            else if (type == 무장능력_지력)
            {
                origin.sort(function(a, b)
                {
                    return (a.stat[무장능력_지력] > b.stat[무장능력_지력]);
                });
            }
            else if (type == 무장능력_정치)
            {
                origin.sort(function(a, b)
                {
                    return (a.stat[무장능력_정치] > b.stat[무장능력_정치]);
                });
            }

            return origin;
        }

        void UpdateDevastation(pk::force@ force)
        {
            if (HasUniqueTech(force.get_force_id(), 고유기교_침략황폐))
            {
                array<pk::unit@> unit_array = pk::list_to_array(pk::get_unit_list(force));
                bool is_say = false;

                for (int i = 0; i < unit_array.length; ++i)
                {
                    pk::unit@ unit = unit_array[i];
                    pk::city@ city = pk::get_city(pk::get_city_id(unit.get_pos()));

                    if (city == null || !unit.is_alive())
                    {
                        continue;
                    }
                    else
                    {
                        int distance;
                        
                        if (true == pk::is_enemy(unit, city))
                        {
                            distance = pk::get_distance(unit.get_pos(), city.get_pos());
                        }
                        else
                        {
                            continue;
                        }

                        // 최대 적용거리보다 먼 경우 패스
                        if (distance >= 침략황폐_적용거리 + 1)
                        {
                            continue;
                        }

                        pk::building@ building = pk::get_building(city.get_id());

                        int troops = unit.troops;

                        // 병사가 1000명 미만인 경우 패스
                        if (troops < 1000)
                        {
                            continue;
                        }

                        if (pk::rand_bool(침략황폐_치안감소확률))
                        {
                            pk::add_public_order(city, 침략황폐_치안감소량, true);
                        }

                        if (pk::is_in_screen(unit.get_pos()))
                        {
                            if (!is_say)
                            {
                                is_say = true;
                                if (pk::rand_bool(50))
                                {
                                    pk::say(pk::u8encode("항복하지 않으면 민초들만 고통받을 뿐이다!"), pk::get_person(unit.leader), unit);
                                }
                                else
                                {
                                    pk::say(pk::u8encode("약탈 또한 전쟁의 일부다. 도시를 황폐화시켜라!"), pk::get_person(unit.leader), unit);
                                }
                            }

                        }
                    }
                }
            }
        }

        void CheckReturnOfKing()
        {
            if (GetReturnOfKingMoo() == null)
                return;
            else
            {
                pk::force@ force = pk::get_force(GetReturnOfKingMoo().get_force_id());

                // 플레이어 세력이 아닐 경우 무효화
                if (!force.is_player())
                {
                    SetReturnOfKingMoo(-1);
                }
                // 왕귀무장이 플레이어 세력인 경우
                else
                {
                    // 왕귀 고유기교 미적용 시 무효화
                    if (!HasUniqueTech(force.get_force_id(), 고유기교_왕귀))
                    {
                        SetReturnOfKingMoo(-1);
                    }
                    
                    // 무장이 사망한 경우 초기화
                    if (!GetReturnOfKingMoo().is_alive())
                    {
                        SetReturnOfKingMoo(-1);
                    }
                }
            }

            if (GetReturnOfKingDate() == 1)
            {
                UpdateReturnOfKingDate();
                array<int> stat_arr = { 0,0,0,0,0 };
                array<int> origin_stat = { 0,0,0,0,0 };
                pk::person@ moo = GetReturnOfKingMoo();
                for (int i = 0; i < 무장능력_끝; ++i)
                {
                    origin_stat[i] = moo.base_stat[i];
                    stat_arr[i] = KingReturnCalcuate(moo.base_stat[i]);
                    moo.base_stat[i] = moo.base_stat[i] + stat_arr[i];
                }
                int total = stat_arr[0] + stat_arr[1] + stat_arr[2] + stat_arr[3] + stat_arr[4];
                SetReturnOfKingMoo(-1);
                MoveScreen(moo.get_pos());
                pk::play_se(6);

                if (total <= 0)
                {
                    pk::message_box(pk::u8encode("전혀 성장하지 않았다.. 시간만 낭비했군."), moo);
                }
                else if (total <= 30)
                {
                    pk::message_box(pk::u8encode("조금은 성장한 기분이다."), moo);
                }
                else if (total <= 100)
                {
                    pk::message_box(pk::u8encode("이전의 나와는 다르다. 효과가 확실히 느껴지는군."), moo);
                }
                else
                {
                    pk::message_box(pk::u8encode("하하하하. 활약할 날이 너무 기대되는군, 상대가 누구든 모조리 상대해주마!"), moo);
                }

                if (total > 0)
                {
                    pk::play_se(6);
                    pk::message_box(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x의 육성이 끝났습니다. 성장한 능력치는 다음과 같습니다.", pk::u8decode(pk::get_name(moo)))));
                    pk::message_box(pk::u8encode(pk::format("\x1b[1x통솔\x1b[0x : {}(+{})\n\x1b[1x무력\x1b[0x : {}(+{})\n\x1b[1x지력\x1b[0x : {}(+{})\n\x1b[1x정치\x1b[0x : {}(+{})\n\x1b[1x매력\x1b[0x : {}(+{})", origin_stat[0], stat_arr[0], origin_stat[1], stat_arr[1], origin_stat[2], stat_arr[2], origin_stat[3], stat_arr[3], origin_stat[4], stat_arr[4])));
                    moo.update();
                }
                else
                {
                    pk::play_se(27);
                    pk::message_box(pk::u8encode(pk::format("육성에 실패했습니다. \x1b[2x{}\x1b[0x의 능력치 변화가 없습니다.", pk::u8decode(pk::get_name(moo)))));
                }
                return;
            }
            
            if(GetReturnOfKingDate() > 0)
            {
                UpdateReturnOfKingDate();
            }
        }

        pk::person@ GetReturnOfKingMoo()
        {
            int value = ReturnOfKingMoo.kouseki;

            if (value < 10000)
            {
                return null;
            }
            else
            {
                return pk::get_person(value - 10000);
            }
        }

        int GetReturnOfKingDate()
        {
            return ReturnOfKingDateMoo.kouseki;
        }

        void UpdateReturnOfKingDate()
        {
            ReturnOfKingDateMoo.kouseki = ReturnOfKingDateMoo.kouseki - 1;
        }

        void SetReturnOfKingMoo(int id)
        {
            ReturnOfKingMoo.kouseki = id + 10000;
            ReturnOfKingDateMoo.kouseki = 왕귀_날짜;
        }

        // 왕귀계산기
        int KingReturnCalcuate(int origin)
        {
            if (origin >= 100)
                return 0;

            int value;

            value = (100 - origin) * (100 - origin) / 125 + 1;

            return value;
        }

        bool HasUnitUniqueTechMoo(pk::unit@ unit, int ut)
        {
            bool is_valid = false;

            if (unit.member[0] != -1)
            {
                if (GetPersonUniqueTech(unit.member[0]) == ut)
                {
                    is_valid = true;
                }
            }

            if (unit.member[1] != -1)
            {
                if (GetPersonUniqueTech(unit.member[1]) == ut)
                {
                    is_valid = true;
                }
            }

            if (unit.member[2] != -1)
            {
                if (GetPersonUniqueTech(unit.member[2]) == ut)
                {
                    is_valid = true;
                }
            }

            return is_valid;
        }

        bool HasUniqueTech(int forceId, int techId)
        {
            if (고유기교_사용여부 == 0)
                return false;

            if (forceId >= 도시_끝 || forceId <= -1)
                return false;

            bool enabled = false;
            
            int data = uniqueTechArray[forceId];

            if ((data / 1000000) == techId)
            {
                enabled = true;
            }
            else if ((data / 10000) % 100 == techId)
            {
                enabled = true;
            }
            else if ((data / 100) % 100 == techId)
            {
                enabled = true;
            }
            else if (data % 100 == techId)
            {
                enabled = true;
            }

            return enabled;
        }

        bool HasTitle(pk::person@ person)
        {
            for (int i = 0; i < 3; ++i)
            {
                if (titleArray[i] == person.get_id())
                {
                    return true;
                }
            }

            return false;
        }

        int GetCompetitionCount(pk::person@ person, int type)
        {
            if (type == 대회_무술)
            {
                return (competitionCountArray[person.get_id()] / 1000);
            }
            else if(type == 대회_설전)
            {
                return (competitionCountArray[person.get_id()] % 1000);
            }

            return 0;
        }

        void AddCompetitionCount(pk::person@ person, int type)
        {
            int id = person.get_id();

            if (type == 대회_무술)
            {
                competitionCountArray[id] = competitionCountArray[id] + 1000;
            }
            else if (type == 대회_설전)
            {
                competitionCountArray[id] = competitionCountArray[id] + 1;
            }
        }

        bool IsEmptyTitle(int type)
        {
            if (titleArray[type] >= 0)
            {
                return false;
            }

            return true;
        }

        // 칭호 보유자 생존 유무 확인
        void UpdateTitlePerson()
        {
            for (int i = 0; i < 3; ++i)
            {
                if (titleArray[i] >= 0)
                {
                    pk::person@ person = pk::get_person(titleArray[i]);

                    // 죽었을 경우 칭호 초기화
                    if (!person.is_alive())
                    {
                        titleArray[i] = -1;
                    }
                }
            }
        }

        void SetTitle(pk::person@ person, int type)
        {
            titleArray[type] = person.get_id();
        }

        // 무효 -1, 아군 0, 적군 1
        int GetWorldClassFlags(pk::person@ leader)
        {
            int person_id = titleArray[2];

            if (person_id == -1)
            {
                return -1;
            }

            pk::unit@ title_unit = pk::get_unit(pk::get_unit_id(pk::get_person(person_id)));

            // 부대가 없거나 멀리 떨어져 있음
            if (title_unit == null || !title_unit.is_alive())
            {
                return -1;
            }
            else
            {
                if (pk::get_distance(title_unit.get_pos(), leader.get_pos()) <= 3)
                {
                    if (pk::is_enemy(title_unit, leader))
                    {
                        return 1;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return -1;
                }
            }
            
            return -1;
        }

        // ============================================= 왕귀 ======================================================================

        bool isReturnOfKing;
        pk::force@ ReturnOfKing_force;
        void AddReturnOfKingMenu()
        {
            pk::menu_item item;
            item.menu = 102;
            item.pos = 12;
            item.shortcut = "R";
            item.init = pk::building_menu_item_init_t(ReturnOfKingInit);
            item.is_enabled = pk::menu_item_is_enabled_t(IsReturnOfKingEnabled);
            item.get_text = pk::menu_item_get_text_t(GetReturnOfKingText);
            item.get_desc = pk::menu_item_get_desc_t(GetReturnOfKingDesc);
            item.handler = pk::menu_item_handler_t(ReturnOfKingHandler);
            pk::add_menu_item(item);
        }

        void ReturnOfKingInit(pk::building@ building)
        {
            isReturnOfKing = HasUniqueTech(building.get_force_id(), 고유기교_왕귀);
            @ReturnOfKing_force = pk::get_force(building.get_force_id());
        }

        bool IsReturnOfKingEnabled()
        {
            return isReturnOfKing;
        }

        string GetReturnOfKingText()
        {
            return pk::u8encode("왕귀");
        }

        string GetReturnOfKingDesc()
        {
            if (!isReturnOfKing)
            {
                return pk::u8encode("실행하려면 해당 고유기교가 필요합니다.");
            }
            else
            {
                pk::person@ moo = GetReturnOfKingMoo();

                if (moo == null)
                {
                    return pk::u8encode("4년 이후의 성장을 지켜볼 무장을 선택합니다");
                }
                else
                {
                    return pk::u8encode(pk::format("현재 진행중인 육성을 취소합니다. \x1b[2x{}\x1b[0x : {}일 남음", pk::u8decode(pk::get_name(moo)), GetReturnOfKingDate() * 10));
                }
            }
        }

        bool ReturnOfKingHandler()
        {
            pk::person@ moo = GetReturnOfKingMoo();
            auto validList = pk::get_person_list(ReturnOfKing_force, pk::mibun_flags(신분_군주, 신분_도독, 신분_태수, 신분_일반));

            if (moo == null)
            {
                pk::list<pk::person@> person_sel = pk::person_selector(pk::u8encode("장수 선택"), pk::u8encode("육성시킬 무장을 선택합니다"), validList, 1, 1);

                if (person_sel.count <= 0)
                {
                    return false;
                }
                else
                {
                    @moo = person_sel[0];
                    pk::message_box(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x의 육성을 시작합니다. 4년 후의 성장을 기대합니다.", pk::u8decode(pk::get_name(moo)))));
                    SetReturnOfKingMoo(moo.get_id());
                    return true;
                }
            }
            else
            {
                if (true == pk::yes_no(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x의 육성을 중단하시겠습니까?)", pk::u8decode(pk::get_name(moo))))))
                {
                    SetReturnOfKingMoo(-1);
                    pk::message_box(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x의 육성을 중단했습니다. 다른 무장을 선택할 수 있습니다.", pk::u8decode(pk::get_name(moo)))));
                }

                return true;
            }
        }


        // =========================================================================================================================

        // ===========================================================================================================================================

        // 교역, 이민족 우호에 사용되는 변수
        pk::building@ tradeBuilding;
        pk::person@ tradeKunshu;
        pk::force@ tradeForce;
        pk::city@ tradeCity;
        uint16 tradeBuildingGold;
        uint16 tradeBuildingFood;
        uint16 tradeBuildingTroops;
        int tradeData;
        int tradeStatus;
        int rapprochmentData;
        int rapprochementStatus;
        array<string> tempArray(4);
        array<int> tradeForceArray(4);
        pk::person@ eventKunshu;
        pk::person@ eventMoo;
        int eventLevel;                     //  교역국 이벤트 level
        int eventForceId;                   //  교역국 이벤트 Id
        int eventRapprochmentLevel;         //  이민족 이벤트 level
        int eventAlienId;                   //  이민족 이벤트 Id
        //int barbarianSkillId;               //  이민족 전수 스킬
        //int barbarianId;                    //  전수 이민족 Id
        // =================================================== 교역 메뉴 추가 ========================================================================
        
        // 외국과의 교역메뉴
        void AddTradeMenu()
        {
            pk::menu_item item;
            item.menu = 103;
            item.pos = 7;
            item.shortcut = "D";
            item.init = pk::building_menu_item_init_t(TradeInit);
            item.is_enabled = pk::menu_item_is_enabled_t(TradeEnabled);
            item.get_text = pk::menu_item_get_text_t(GetTradeText);
            item.get_desc = pk::menu_item_get_desc_t(GetTradeDescription);
            item.handler = pk::menu_item_handler_t(TradeHandler);
            pk::add_menu_item(item);
        }

        void TradeInit(pk::building@ building)
        {
            @tradeBuilding = @building;
            @tradeForce = pk::get_force(building.get_force_id());
            @tradeKunshu = pk::get_person(tradeForce.kunshu);
            @tradeCity = pk::building_to_city(tradeBuilding);
            tradeBuildingGold = pk::get_gold(building);
            tradeBuildingFood = pk::get_food(building);
            tradeBuildingTroops = pk::get_troops(building);
            tradeData = GetPossibleTrade(tradeForce, tradeBuilding, tradeStatus);
        }

        bool TradeEnabled()
        {
            if (-1 == tradeData)
            {
                return false;
            }

            return true;
        }
        
        string GetTradeText()
        {
            return  pk::u8encode("교역");
        }
        
        string GetTradeDescription()
        {
            if (-1 == tradeData)
            {
                switch (tradeStatus)
                {
                case 교역불가_교역중 :
                    return  pk::u8encode(pk::format("현재 \x1b[2x{}\x1b[0x과 교역중에 있습니다. 남은 일수 : {}일", 교역대상_이름[GetTradeForce(tradeForce)], GetTradeDay(tradeForce) * 10));
                case 교역불가_지역이점없음:
                    return  pk::u8encode("교역이 가능한 지역을 얻지 못했습니다");
                case 교역불가_기교부족:
                    return  pk::u8encode(pk::format("기교가 부족합니다. (기교 P{})", 교역_기교));
                case 교역불가_물자부족:
                    return  pk::u8encode("교역에 필요한 물자가 부족합니다");
                case 교역불가_최대:
                    return  pk::u8encode("교역이 가능한 대상이 모두 최대치입니다");
                }
            }

            return pk::u8encode(pk::format("타국과의 교역을 실행합니다. (기교P {} 사용)", 교역_기교));
        }

        bool TradeHandler()
        {
            int level;
            int count = 0;
            
            // 대진국
            if (tradeData % 2 == 1)
            {
                level = GetRelationLevel(tradeForce, 우호_대진국);
                tradeForceArray[count] = 0;
                tempArray[count] = pk::u8encode(pk::format("\x1b[2x대진국\x1b[0x (현재 우호도 {})", level));
                count += 1;
            }
            // 안식국
            if ((tradeData / 2) % 2 == 1)
            {
                level = GetRelationLevel(tradeForce, 우호_안식국);
                tradeForceArray[count] = 1;
                tempArray[count] = pk::u8encode(pk::format("\x1b[2x안식국\x1b[0x (현재 우호도 {})", level));
                count += 1;
            }
            // 천축국
            if ((tradeData / 4) % 2 == 1)
            {
                level = GetRelationLevel(tradeForce, 우호_천축국);
                tradeForceArray[count] = 2;
                tempArray[count] = pk::u8encode(pk::format("\x1b[2x천축국\x1b[0x (현재 우호도 {})", level));
                count += 1;
            }
            // 귀상국
            if ((tradeData / 8) % 2 == 1)
            {
                level = GetRelationLevel(tradeForce, 우호_귀상국);
                tradeForceArray[count] = 3;
                tempArray[count] = pk::u8encode(pk::format("\x1b[2x귀상국\x1b[0x (현재 우호도 {})", level));
                count += 1;
            }
            array<string> menuArray(count + 1);

            for (int i = 0; i < count; ++i)
            {
                menuArray[i] = tempArray[i];
            }

            menuArray[count] = pk::u8encode("취소");

            int choose = pk::choose(pk::u8encode("교역을 실행할 세력을 선택하십시오."), menuArray);
            
            if (choose == count)
            {
                return false;
            }
            else
            {
                if (false == pk::yes_no(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x과 교역을 실행하시겠습니까? \n\n(금{} 군량{} 병력{} 소모)", 교역대상_이름[tradeForceArray[choose]], 교역_금[level], 교역_군량[level], 교역_병사[level]))))
                {
                    return TradeHandler();
                }
            }

            int selectForce = tradeForceArray[choose];
            int selectLevel = GetRelationLevel(tradeForce, selectForce);
            pk::add_tp(tradeForce, -교역_기교, tradeBuilding.get_pos());
            pk::add_gold(tradeBuilding, -교역_금[selectLevel], true);
            pk::add_food(tradeBuilding, -교역_군량[selectLevel], true);
            pk::add_troops(tradeBuilding, -교역_병사[selectLevel], true);
            ExecuteTrade(tradeForce, selectForce);
            RelationStartEvent(tradeForce, selectForce);
            return true;
        }

        // 이민족과의 화친 메뉴
        void AddrapprochementMenu()
        {
            pk::menu_item item;
            item.menu = 103;
            item.pos = 8;
            item.shortcut = "C";
            item.init = pk::building_menu_item_init_t(RapprochementInit);
            item.is_enabled = pk::menu_item_is_enabled_t(RapprochementEnabled);
            item.get_text = pk::menu_item_get_text_t(GetRapprochementText);
            item.get_desc = pk::menu_item_get_desc_t(GetRapprochementDescription);
            item.handler = pk::menu_item_handler_t(RapprochementHandler);
            pk::add_menu_item(item);
        }

        void RapprochementInit(pk::building@ building)
        {
            @tradeBuilding = @building;
            @tradeForce = pk::get_force(building.get_force_id());
            @tradeKunshu = pk::get_person(tradeForce.kunshu);
            @tradeCity = pk::building_to_city(tradeBuilding);
            tradeBuildingGold = pk::get_gold(building);
            rapprochmentData = GetPossibleRapprochement(tradeForce, tradeBuilding, rapprochementStatus);
        }

        bool RapprochementEnabled()
        {
            if (-1 == rapprochmentData)
            {
                return false;
            }

            return true;
        }

        string GetRapprochementText()
        {
            return  pk::u8encode("이민족");
        }

        string GetRapprochementDescription()
        {
            if (-1 == rapprochmentData)
            {
                switch (rapprochementStatus)
                {
                case 교역불가_지역이점없음:
                    return  pk::u8encode("교류가 가능한 이민족이 없습니다.");
                case 교역불가_기교부족:
                    return  pk::u8encode(pk::format("기교가 부족합니다. (기교 P{})", 화친_기교));
                case 교역불가_물자부족:
                    return  pk::u8encode("친선에 필요한 물자가 부족합니다");
                case 교역불가_최대:
                    return  pk::u8encode("친선이 가능한 대상이 모두 최대치입니다");
                }
            }

            return pk::u8encode(pk::format("이민족과의 친선을 실행합니다. (기교P {} 사용)", 화친_기교));
        }

        bool RapprochementHandler()
        {
            int level;
            int targetForceId = -1;
            pk::list<pk::force@> forceList;

            // 오환
            if (rapprochmentData % 2 == 1)
            {
                forceList.add(pk::get_force(세력_오환));
            }
            // 강
            if ((rapprochmentData / 2) % 2 == 1)
            {
                forceList.add(pk::get_force(세력_강));
            }
            // 남만
            if ((rapprochmentData / 4) % 2 == 1)
            {
                forceList.add(pk::get_force(세력_남만));
            }
            // 산월
            if ((rapprochmentData / 8) % 2 == 1)
            {
                forceList.add(pk::get_force(세력_산월));
            }

            if (forceList.count != 0)
            {
                pk::list<pk::force@> force_sel = pk::force_selector(pk::u8encode("세력 선택"), pk::u8encode("교류의 대상을 선택합니다."), forceList, 1, 1);
                
                if (force_sel.count == 0)
                {
                    return false; // 미선택 시 취소 종료
                }

                switch (force_sel[0].get_id())
                {
                case 세력_오환 :
                    targetForceId = 우호_오환;
                    break;

                case 세력_강 :
                    targetForceId = 우호_강;
                    break;

                case 세력_남만 :
                    targetForceId = 우호_남만;
                    break;

                case 세력_산월 :
                    targetForceId = 우호_산월;
                    break;
                }
            }

            int selectLevel = GetRelationLevel(tradeForce, targetForceId);
            int requiredGold = 교역_금[selectLevel];
            int personCount = GetRapprochmentPersonCount(tradeForce, targetForceId);

            if (personCount > 0)
            {
                if (personCount >= 5)
                {
                    personCount = 5;
                }

                requiredGold = (requiredGold / 10) * (10 - personCount);
            }

            if (pk::choose(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x에 친선을 위한 사절을 보내시겠습니까?\n(기교 {} 필요, 금 {} 필요)\n", 교역대상_이름[targetForceId], 화친_기교, requiredGold)) , { pk::u8encode("예"), pk::u8encode("아니오") }) == 1)
            {
                return  RapprochementHandler();
            }

            pk::add_tp(tradeForce, -화친_기교, tradeBuilding.get_pos());
            pk::add_gold(tradeBuilding, -requiredGold, true);
            ExecuteRapprochment(tradeForce, targetForceId);
            RelationStartEvent(tradeForce, targetForceId);
            return true;
        }

        // 이벤트

        void RelationStartEvent(pk::force@ force, int type)
        {
            string forceName = 교역대상_이름[type];
            pk::person@ p = pk::get_person(무장_사자);

            pk::play_se(17);
            pk::message_box(pk::u8encode(pk::format("반드시 \x1b[2x{}\x1b[0x에 도착해 좋은 소식을 가져오겠습니다.", forceName)), p);
            pk::message_box(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x을 향해 교역의 사절이 떠났습니다.", forceName)));
        }

        void TradeEventScene()
        {
            string forceName = 교역대상_이름[eventForceId];
            @eventMoo = pk::get_person(무장_사자);
            pk::play_se(17);
            pk::message_box(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x을 향해 떠났던 사절이 돌아왔습니다.", forceName)));
            
            pk::move_screen(eventKunshu.get_pos());

            pk::fade(0);
            pk::sleep();
            pk::background(35);
            pk::fade(255);

            switch (eventForceId)
            {
            case 우호_대진국:
                pk::message_box(pk::u8encode("주공! 이제 막 도착했습니다."), eventMoo);
                pk::message_box(pk::u8encode("오.. 그래 \x1b[2x대진국\x1b[0x은 어떻던가?"), eventKunshu);
                switch (eventLevel)
                {
                case 0:
                    pk::message_box(pk::u8encode("\x1b[2x대진국\x1b[0x의 왕은 저희를 크게 환대해주었습니다."), eventMoo);
                    pk::message_box(pk::u8encode("\x1b[2x대진국\x1b[0x은 주변의 \x1b[2x안식국\x1b[0x이라는 국가와 전쟁을 하는중인듯 합니다."), eventMoo);
                    pk::play_se(6);
                    pk::message_box(pk::u8encode("왕은 저희가 가져간 선물이 마음에 들었는지 \x1b[2x안식국\x1b[0x에 대비해 개발한 \x1b[1x귀갑진\x1b[0x이라는 진법을 전수해주었습니다."), eventMoo);
                    pk::message_box(pk::u8encode("\x1b[1x귀갑진\x1b[0x을 통해 아군 창병부대의 수비력이 향상될거라 기대됩니다."), eventMoo);
                    break;

                case 1:
                    pk::message_box(pk::u8encode("\x1b[2x대진국\x1b[0x의 왕은 여전히 저희를 크게 환대해주었습니다."), eventMoo);
                    pk::message_box(pk::u8encode("여전히 그들은 \x1b[2x안식국\x1b[0x과 사이가 좋지 않은듯 보였습니다."), eventMoo);
                    pk::play_se(6);
                    pk::message_box(pk::u8encode("이번에는 그들이 공성전에 사용하는 \x1b[1x발석거\x1b[0x라는 병기에 대해 전수받았습니다."), eventMoo);
                    if (true == tradeForce.tech[기교_투석개발])
                    {
                        pk::message_box(pk::u8encode("그들의 \x1b[1x발석거\x1b[0x는 기존에 저희가 사용하던 \x1b[1x투석기\x1b[0x와는 또 다른 위력을 보였습니다."), eventMoo);
                        pk::message_box(pk::u8encode("\x1b[1x발석거\x1b[0x는 성을 공격할때 매우 강력한 위력을 보일거라고 기대됩니다."), eventMoo);
                    }
                    else
                    {
                        // 만약 해당 기교가 개발중이면 개발 취소
                        if (tradeForce.researching_tech == 기교_투석개발)
                        {
                            auto officers = pk::get_person_list(tradeForce, pk::mibun_flags(신분_군주, 신분_도독, 신분_태수, 신분_일반));

                            for (int i = 0; i < officers.count; ++i)
                            {
                                if (officers[i].order == 무장임무_기교연구)
                                {
                                    officers[i].order = 무장임무_없음;
                                    officers[i].absence_timer = 0;
                                    officers[i].action_done = false;
                                }
                            }

                            tradeForce.researching_tech = -1;
                        }
                        // 투석기교 확득
                        tradeForce.tech[기교_투석개발] = true;
                        ChangeWeaponCatapult(tradeForce);
                        pk::message_box(pk::u8encode("\x1b[1x발석거\x1b[0x는 성을 공격할때 매우 강력한 위력을 보일거라고 기대됩니다."), eventMoo);
                        pk::play_se(10);
                        pk::message_box(pk::u8encode("기교 \x1b[1x투석개발\x1b[0x을 획득했습니다."));
                    }
                    break;

                case 2:
                    pk::message_box(pk::u8encode("\x1b[2x대진국\x1b[0x의 왕은 여전히 저희를 크게 환대해주었습니다."), eventMoo);
                    pk::message_box(pk::u8encode("여전히 그들은 \x1b[2x안식국\x1b[0x과 사이가 좋지 않은듯 보였습니다."), eventMoo);
                    pk::message_box(pk::u8encode("그들의 상대인 \x1b[2x안식국\x1b[0x의 \x1b[1x철갑기병\x1b[0x은 매우 높은 명성을 떨치고 있었습니다."), eventMoo);
                    pk::play_se(6);
                    pk::message_box(pk::u8encode("이번에는 그들이 \x1b[1x철갑기병\x1b[0x에 대항하기 위해 고안한 \x1b[1x군단병\x1b[0x이라는 병과에 대해 전수받았습니다."), eventMoo);
                    pk::message_box(pk::u8encode("그들의 지식을 토대로 아군 창병부대의 수비력이 크게 향상될거라 기대됩니다."), eventMoo);
                    break;
                }
                break;
                
            case 우호_안식국:
                pk::message_box(pk::u8encode("주공! 이제 막 도착했습니다."), eventMoo);
                pk::message_box(pk::u8encode("오.. 그래. \x1b[2x안식국\x1b[0x은 어떻던가?"), eventKunshu);
                switch (eventLevel)
                {
                case 0:
                    pk::message_box(pk::u8encode("\x1b[2x안식국\x1b[0x의 왕은 저희를 크게 환대해주었습니다."), eventMoo);
                    pk::message_box(pk::u8encode("\x1b[2x안식국\x1b[0x은 주변의 \x1b[2x대진국\x1b[0x이라는 국가와 전쟁을 하는중인듯 합니다."), eventMoo);
                    pk::play_se(6);
                    pk::message_box(pk::u8encode("왕은 저희가 가져간 선물이 마음에 들었는지 \x1b[2x대진국\x1b[0x에 대비해 개발한 \x1b[1x파도기병술\x1b[0x이라는 전법을 전수해주었습니다."), eventMoo);
                    pk::message_box(pk::u8encode("\x1b[1x파도기병술\x1b[0x을 통해 아군 기병부대의 공격력이 향상될거라 기대됩니다."), eventMoo);
                    break;

                case 1:
                    pk::message_box(pk::u8encode("\x1b[2x안식국\x1b[0x의 왕은 여전히 저희를 크게 환대해주었습니다."), eventMoo);
                    pk::message_box(pk::u8encode("여전히 그들은 \x1b[2x대진국\x1b[0x과 사이가 좋지 않은듯 보였습니다."), eventMoo);
                    pk::play_se(6);
                    pk::message_box(pk::u8encode("이번에는 그들의 기병을 더욱 강력하게 만든 \x1b[1x안식사법\x1b[0x이라는 궁술에 대해 전수받았습니다."), eventMoo);
                    if (true == tradeForce.tech[기교_기사])
                    {
                        pk::message_box(pk::u8encode("\x1b[1x안식사법\x1b[0x은 기존에 저희가 사용하던 \x1b[1x기사\x1b[0x보다 더 강력한 위력을 보였습니다."), eventMoo);
                        pk::message_box(pk::u8encode("\x1b[1x안식사법\x1b[0x은 아군의 기마부대를 더욱 강력하게 만들어줄거라 기대됩니다."), eventMoo);
                    }
                    else
                    {
                        // 만약 해당 기교가 개발중이면 개발취소
                        if (tradeForce.researching_tech == 기교_기사)
                        {
                            auto officers = pk::get_person_list(tradeForce, pk::mibun_flags(신분_군주, 신분_도독, 신분_태수, 신분_일반));

                            for (int i = 0; i < officers.count; ++i)
                            {
                                if (officers[i].order == 무장임무_기교연구)
                                {
                                    officers[i].order = 무장임무_없음;
                                    officers[i].absence_timer = 0;
                                    officers[i].action_done = false;
                                }
                            }

                            tradeForce.researching_tech = -1;
                        }
                        // 기사 획득
                        tradeForce.tech[기교_기사] = true;
                        pk::message_box(pk::u8encode("\x1b[1x안식사법\x1b[0x은 아군의 기마부대를 더욱 강력하게 만들어줄거라 기대됩니다."), eventMoo);
                        pk::play_se(10);
                        pk::message_box(pk::u8encode("기교 \x1b[1x기사\x1b[0x를 획득했습니다."));
                    }
                    break;

                case 2:
                    pk::message_box(pk::u8encode("\x1b[2x안식국\x1b[0x의 왕은 여전히 저희를 크게 환대해주었습니다."), eventMoo);
                    pk::message_box(pk::u8encode("여전히 그들은 \x1b[2x대진국\x1b[0x과 사이가 좋지 않은듯 보였습니다."), eventMoo);
                    pk::message_box(pk::u8encode("그들의 상대인 \x1b[2x대진국\x1b[0x의 \x1b[1x군단병\x1b[0x은 매우 높은 명성을 떨치고 있었습니다."), eventMoo);
                    pk::play_se(6);
                    pk::message_box(pk::u8encode("이번에는 그들이 \x1b[1x군단병\x1b[0x을 분쇄하기 위해 고안한 \x1b[1x철갑기병\x1b[0x이라는 병과에 대해 전수받았습니다."), eventMoo);
                    pk::message_box(pk::u8encode("그들의 지식을 토대로 아군 기마부대의 공격력이 크게 향상될거라 기대됩니다."), eventMoo);
                    break;
                }
                break;

            case 우호_천축국 :
                pk::message_box(pk::u8encode("주공! 지금 막 다녀왔습니다."), eventMoo);
                pk::message_box(pk::u8encode("오.. 그래. \x1b[2x천축국\x1b[0x은 어떻던가?"), eventKunshu);
                switch (eventLevel)
                {
                case 0:
                    pk::message_box(pk::u8encode("\x1b[2x천축국\x1b[0x의 왕은 저희를 크게 환대해주었습니다."), eventMoo);
                    pk::message_box(pk::u8encode("\x1b[2x천축국\x1b[0x은 주변의 \x1b[2x귀상국\x1b[0x이라는 국가와 전쟁을 하는중인듯 합니다."), eventMoo);
                    pk::play_se(6);
                    pk::message_box(pk::u8encode("왕은 저희가 가져간 선물이 마음에 들었는지 \x1b[1x마누법전\x1b[0x이라는 경전에 대해 알려주었습니다."), eventMoo);
                    if (true == tradeForce.tech[기교_공병육성])
                    {
                        pk::message_box(pk::u8encode("\x1b[1x마누법전\x1b[0x은 기존에 저희가 시행하던 \x1b[1x공병육성\x1b[0x보다 더 효율적인 면모를 보였습니다."), eventMoo);
                        pk::message_box(pk::u8encode("\x1b[1x마누법전\x1b[0x을 통해 도시의 지배를 더 굳건히 할 수 있을것입니다."), eventMoo);
                    }
                    else
                    {
                        // 만약 해당 기교가 개발중이면 개발취소
                        if (tradeForce.researching_tech == 기교_공병육성)
                        {
                            auto officers = pk::get_person_list(tradeForce, pk::mibun_flags(신분_군주, 신분_도독, 신분_태수, 신분_일반));

                            for (int i = 0; i < officers.count; ++i)
                            {
                                if (officers[i].order == 무장임무_기교연구)
                                {
                                    officers[i].order = 무장임무_없음;
                                    officers[i].absence_timer = 0;
                                    officers[i].action_done = false;
                                }
                            }

                            tradeForce.researching_tech = -1;
                        }
                        // 공병육성 획득
                        tradeForce.tech[기교_공병육성] = true;
                        pk::message_box(pk::u8encode("\x1b[1x마누법전\x1b[0x을 통해 도시의 지배를 더 굳건히 할 수 있을것입니다."), eventMoo);
                        pk::play_se(10);
                        pk::message_box(pk::u8encode("기교 \x1b[1x공병육성\x1b[0x을 획득했습니다."));
                    }
                    break;

                case 1:
                    pk::message_box(pk::u8encode("\x1b[2x천축국\x1b[0x의 왕은 여전히 저희를 크게 환대해주었습니다."), eventMoo);
                    pk::message_box(pk::u8encode("여전히 그들은 \x1b[2x귀상국\x1b[0x과 사이가 좋지 않은듯 보였습니다."), eventMoo);
                    pk::play_se(6);
                    pk::message_box(pk::u8encode("이번에는 그들의 나라를 더욱 풍족하게 만든 \x1b[1x실리론\x1b[0x이라는 통치술에 대해 전수받았습니다."), eventMoo);
                    if (true == tradeForce.tech[기교_법령정비])
                    {
                        pk::message_box(pk::u8encode("\x1b[1x실리론\x1b[0x은 기존에 저희가 시행하던 \x1b[1x법령정비\x1b[0x보다 더 효율적인 면모를 보였습니다."), eventMoo);
                        pk::message_box(pk::u8encode("\x1b[1x실리론\x1b[0x을 통해 백성들의 군역에 대한 동요를 감소시킬 수 있을 것입니다."), eventMoo);
                    }
                    else
                    {
                        // 만약 해당 기교가 개발중이면 개발취소
                        if (tradeForce.researching_tech == 기교_법령정비)
                        {
                            auto officers = pk::get_person_list(tradeForce, pk::mibun_flags(신분_군주, 신분_도독, 신분_태수, 신분_일반));

                            for (int i = 0; i < officers.count; ++i)
                            {
                                if (officers[i].order == 무장임무_기교연구)
                                {
                                    officers[i].order = 무장임무_없음;
                                    officers[i].absence_timer = 0;
                                    officers[i].action_done = false;
                                }
                            }

                            tradeForce.researching_tech = -1;
                        }
                        // 정령정비 획득
                        tradeForce.tech[기교_법령정비] = true;
                        pk::message_box(pk::u8encode("\x1b[1x실리론\x1b[0x을 통해 백성들의 군역에 대한 동요를 감소시킬 수 있을 것입니다."), eventMoo);
                        pk::play_se(10);
                        pk::message_box(pk::u8encode("기교 \x1b[1x법령정비\x1b[0x를 획득했습니다."));
                    }
                    break;

                case 2:
                    pk::message_box(pk::u8encode("\x1b[2x천축국\x1b[0x의 왕은 여전히 저희를 크게 환대해주었습니다."), eventMoo);
                    pk::message_box(pk::u8encode("여전히 그들은 \x1b[2x귀상국\x1b[0x과 분쟁을 일으키고 있었습니다."), eventMoo);
                    pk::message_box(pk::u8encode("그들의 상대인 \x1b[2x귀상국\x1b[0x이 믿는 \x1b[1x아미타바\x1b[0x는 그 곳 백성들을 하나로 뭉치고 있었습니다."), eventMoo);
                    pk::play_se(6);
                    pk::message_box(pk::u8encode("이번에는 그들이 \x1b[2x귀상국\x1b[0x을 상대하기 위해 고안한 \x1b[1x가루다진법\x1b[0x이라는 진형에 대해 전수받았습니다."), eventMoo);
                    pk::message_box(pk::u8encode("\x1b[1x가루다진법\x1b[0x을 활용한다면 공성과 수성 모두에 큰 도움을 받을 수 있습니다."), eventMoo);
                    break;
                }
                break;

            case 우호_귀상국 :
                pk::message_box(pk::u8encode("주공! 지금 막 다녀왔습니다."), eventMoo);
                pk::message_box(pk::u8encode("오.. 그래. \x1b[2x귀상국\x1b[0x은 어떻던가?"), eventKunshu);
                switch (eventLevel)
                {
                case 0:
                    pk::message_box(pk::u8encode("\x1b[2x귀상국\x1b[0x의 왕은 저희를 크게 환대해주었습니다."), eventMoo);
                    pk::message_box(pk::u8encode("\x1b[2x귀상국\x1b[0x은 주변의 \x1b[2x천축국\x1b[0x이라는 국가와 전쟁을 하는중인듯 합니다."), eventMoo);
                    pk::play_se(6);
                    pk::message_box(pk::u8encode("왕은 저희가 가져간 선물이 마음에 들었는지 \x1b[1x전륜왕수송술\x1b[0x이라는 운반기술을 알려주었습니다."), eventMoo);
                    if (true == tradeForce.tech[기교_목우유마])
                    {
                        pk::message_box(pk::u8encode("\x1b[1x전륜왕수송술\x1b[0x은 기존에 저희가 시행하던 \x1b[1x목우유마\x1b[0x보다 더 빼어난 면모를 보였습니다."), eventMoo);
                        pk::message_box(pk::u8encode("\x1b[1x전륜왕수송술\x1b[0x을 활용하여 수송부대의 기동성을 극대화시킬 수 있습니다."), eventMoo);
                    }
                    else
                    {
                        // 만약 해당 기교가 개발중이면 개발취소
                        if (tradeForce.researching_tech == 기교_목우유마)
                        {
                            auto officers = pk::get_person_list(tradeForce, pk::mibun_flags(신분_군주, 신분_도독, 신분_태수, 신분_일반));

                            for (int i = 0; i < officers.count; ++i)
                            {
                                if (officers[i].order == 무장임무_기교연구)
                                {
                                    officers[i].order = 무장임무_없음;
                                    officers[i].absence_timer = 0;
                                    officers[i].action_done = false;
                                }
                            }

                            tradeForce.researching_tech = -1;
                        }
                        // 정령정비 획득
                        tradeForce.tech[기교_목우유마] = true;
                        pk::message_box(pk::u8encode("\x1b[1x전륜왕수송술\x1b[0x을 활용하여 수송부대의 기동성을 극대화시킬 수 있습니다."), eventMoo);
                        pk::play_se(10);
                        pk::message_box(pk::u8encode("기교 \x1b[1x목우유마\x1b[0x를 획득했습니다."));
                    }
                    break;

                case 1:
                    pk::message_box(pk::u8encode("\x1b[2x귀상국\x1b[0x의 왕은 여전히 저희를 크게 환대해주었습니다."), eventMoo);
                    pk::message_box(pk::u8encode("여전히 그들은 \x1b[2x천축국\x1b[0x과 사이가 좋지 않은듯 보였습니다."), eventMoo);
                    pk::play_se(6);
                    pk::message_box(pk::u8encode("이번에는 그들의 응용지식의 토대인 \x1b[1x우파베다\x1b[0x에 대해서 배울 기회가 생겼습니다."), eventMoo);
                    pk::message_box(pk::u8encode("\x1b[1x우파베다\x1b[0x의 지식을 통해 아군 노병부대의 위력이 더욱 강해질 것입니다."), eventMoo);
                    break;

                case 2:
                    pk::message_box(pk::u8encode("\x1b[2x귀상국\x1b[0x의 왕은 여전히 저희를 크게 환대해주었습니다."), eventMoo);
                    pk::message_box(pk::u8encode("여전히 그들은 \x1b[2x천축국\x1b[0x과 분쟁을 일으키고 있었습니다."), eventMoo);
                    pk::message_box(pk::u8encode("그들의 상대인 \x1b[2x천축국\x1b[0x이 자랑하는 \x1b[1x가루다진법\x1b[0x은 주변의 나라들을 두렵게 만드는 전투방식으로 보였습니다."), eventMoo);
                    pk::play_se(6);
                    pk::message_box(pk::u8encode("이번에는 \x1b[2x귀상국\x1b[0x 사람들을 하나로 뭉치게 만드는 \x1b[1x아미타바\x1b[0x라는 신앙에 대해 배워왔습니다."), eventMoo);
                    pk::message_box(pk::u8encode("\x1b[1x아미타바\x1b[0x를 통한 정신수양으로 아군 군대의 동요를 크게 방지할 수 있을 것입니다."), eventMoo);
                    break;
                }
                break;
            }

            pk::message_box(pk::u8encode("그것 참 훌륭한 소식이군. 수고했네."), eventKunshu);
            pk::fade(0);
            pk::sleep();
            pk::background(-1);
            pk::fade(255);
        }
        
        void RapprochmentEventScene()
        {
            string forceName = 교역대상_이름[eventAlienId];
            @eventMoo = pk::get_person(무장_사자);
            pk::play_se(17);
            pk::message_box(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x을 향해 떠났던 사절이 돌아왔습니다.", forceName)));

            pk::fade(0);
            pk::sleep();
            pk::background(35);
            pk::fade(255);

            switch (eventAlienId)
            {   
            case 우호_오환:
                pk::message_box(pk::u8encode("주공! 이제 막 도착했습니다."), eventMoo);
                pk::message_box(pk::u8encode("오.. 그래. \x1b[2x오환\x1b[0x은 어떻던가?"), eventKunshu);
                switch (eventRapprochmentLevel)
                {
                case 0:
                    pk::message_box(pk::u8encode("\x1b[2x오환족장\x1b[0x은 저희의 방문을 몹시 반가워했습니다."), eventMoo);
                    pk::message_box(pk::u8encode("주공의 배려에 감탄한 족장은 \x1b[1x유주\x1b[0x를 침략하지 않겠다고 했습니다."), eventMoo);
                    pk::message_box(pk::u8encode("또 주기적으로 병력과 물자를 보내 화친을 돈독히 하고자한다는 성의를 표시한다고 했습니다."), eventMoo);
                    break;

                case 1:
                    pk::message_box(pk::u8encode("\x1b[2x오환족장\x1b[0x은 여전히 저희를 반가워했습니다."), eventMoo);
                    pk::message_box(pk::u8encode("족장은 주공에게 큰 힘이 될 수 있게 더 많은 물자를 보내기로 약속했습니다."), eventMoo);
                    pk::message_box(pk::u8encode("그리고 매년 그들의 경험을 아군 무장들에게 전수해줄거라 전했습니다."), eventMoo);
                    break;

                case 2:
                    pk::message_box(pk::u8encode("\x1b[2x오환족장\x1b[0x은 여전히 저희를 반가워했습니다."), eventMoo);
                    pk::message_box(pk::u8encode("\x1b[2x오환족장\x1b[0x은 주공에 호의에 감탄하여 그들의 노련한 용사들을 파견해주었습니다."), eventMoo);
                    pk::message_box(pk::u8encode("그들의 경험을 살린 기마술로 하여금 아군의 기마군단은 적의 패장들을 효과적으로 제압할 수 있게 될것입니다."), eventMoo);
                    break;
                }
                break;

            case 우호_강:
                pk::message_box(pk::u8encode("주공! 이제 막 도착했습니다."), eventMoo);
                pk::message_box(pk::u8encode("오.. 그래. \x1b[2x강\x1b[0x은 어떻던가?"), eventKunshu);
                switch (eventRapprochmentLevel)
                {
                case 0:
                    pk::message_box(pk::u8encode("\x1b[2x강족장\x1b[0x은 저희의 방문을 몹시 반가워했습니다."), eventMoo);
                    pk::message_box(pk::u8encode("주공의 배려에 감탄한 족장은 \x1b[1x량주\x1b[0x를 침략하지 않겠다고 했습니다."), eventMoo);
                    pk::message_box(pk::u8encode("또 주기적으로 병력과 물자를 보내 화친을 돈독히 하고자한다는 성의를 표시한다고 했습니다."), eventMoo);
                    break;

                case 1:
                    pk::message_box(pk::u8encode("\x1b[2x강족장\x1b[0x은 여전히 저희를 반가워했습니다."), eventMoo);
                    pk::message_box(pk::u8encode("족장은 주공에게 큰 힘이 될 수 있게 더 많은 물자를 보내기로 약속했습니다."), eventMoo);
                    pk::message_box(pk::u8encode("그리고 매년 그들의 경험을 아군 무장들에게 전수해줄거라 전했습니다."), eventMoo);
                    break;

                case 2:
                    pk::message_box(pk::u8encode("\x1b[2x강족장\x1b[0x은 여전히 저희를 반가워했습니다."), eventMoo);
                    pk::message_box(pk::u8encode("\x1b[2x강족장\x1b[0x은 주공에 호의에 감탄하여 그들의 노련한 용사들을 파견해주었습니다."), eventMoo);
                    pk::message_box(pk::u8encode("그들의 경험을 살린 기마술로 하여금 아군의 기마군단은 적들의 추격에서 효과적으로 후퇴할 수 있을것입니다."), eventMoo);
                    break;
                }
                break;

            case 우호_남만:
                pk::message_box(pk::u8encode("주공! 이제 막 도착했습니다."), eventMoo);
                pk::message_box(pk::u8encode("오.. 그래. \x1b[2x남만\x1b[0x은 어떻던가?"), eventKunshu);
                switch (eventRapprochmentLevel)
                {
                case 0:
                    pk::message_box(pk::u8encode("\x1b[2x남만족장\x1b[0x은 저희의 방문을 몹시 반가워했습니다."), eventMoo);
                    pk::message_box(pk::u8encode("주공의 배려에 감탄한 족장은 \x1b[1x남중\x1b[0x을 침략하지 않겠다고 했습니다."), eventMoo);
                    pk::message_box(pk::u8encode("또 주기적으로 병력과 물자를 보내 화친을 돈독히 하고자한다는 성의를 표시한다고 했습니다."), eventMoo);
                    break;

                case 1:
                    pk::message_box(pk::u8encode("\x1b[2x남만족장\x1b[0x은 여전히 저희를 반가워했습니다."), eventMoo);
                    pk::message_box(pk::u8encode("족장은 주공에게 큰 힘이 될 수 있게 더 많은 물자를 보내기로 약속했습니다."), eventMoo);
                    pk::message_box(pk::u8encode("그리고 매년 그들의 경험을 아군 무장들에게 전수해줄거라 전했습니다."), eventMoo);
                    break;

                case 2:
                    pk::message_box(pk::u8encode("\x1b[2x남만족장\x1b[0x은 여전히 저희를 반가워했습니다."), eventMoo);
                    pk::message_box(pk::u8encode("\x1b[2x남만족장\x1b[0x은 주공에 호의에 감탄하여 그들의 노련한 용사들을 파견해주었습니다."), eventMoo);
                    pk::message_box(pk::u8encode("그들의 경험을 살린 전투술로 하여금 아군의 병사들은 숲에서 더욱 뛰어난 위력을 발휘할 수 있을것입니다."), eventMoo);
                    break;
                }
                break;

            case 우호_산월:
                pk::message_box(pk::u8encode("주공! 이제 막 도착했습니다."), eventMoo);
                pk::message_box(pk::u8encode("오.. 그래. \x1b[2x산월\x1b[0x은 어떻던가?"), eventKunshu);
                switch (eventRapprochmentLevel)
                {
                case 0:
                    pk::message_box(pk::u8encode("\x1b[2x산월족장\x1b[0x은 저희의 방문을 몹시 반가워했습니다."), eventMoo);
                    pk::message_box(pk::u8encode("주공의 배려에 감탄한 족장은 \x1b[1x양주\x1b[0x를 침략하지 않겠다고 했습니다."), eventMoo);
                    pk::message_box(pk::u8encode("또 주기적으로 병력과 물자를 보내 관계를 돈독히 하고자하는 성의를 표시한다고 했습니다."), eventMoo);
                    break;

                case 1:
                    pk::message_box(pk::u8encode("\x1b[2x산월족장\x1b[0x은 여전히 저희를 반가워했습니다."), eventMoo);
                    pk::message_box(pk::u8encode("족장은 주공에게 큰 힘이 될 수 있게 더 많은 물자를 보내기로 약속했습니다."), eventMoo);
                    pk::message_box(pk::u8encode("그리고 매년 그들의 경험을 아군 무장들에게 전수해줄거라 전했습니다."), eventMoo);
                    break;

                case 2:
                    pk::message_box(pk::u8encode("\x1b[2x산월족장\x1b[0x은 여전히 저희를 반가워했습니다."), eventMoo);
                    pk::message_box(pk::u8encode("\x1b[2x산월족장\x1b[0x은 주공에 호의에 감탄하여 그들의 노련한 용사들을 파견해주었습니다."), eventMoo);
                    pk::message_box(pk::u8encode("그들의 경험을 살린 전투술로 하여금 아군의 극병부대는 적의 무장들을 효과적으로 제압할 수 있을것입니다."), eventMoo);
                    break;
                }
                break;
            }

            pk::message_box(pk::u8encode("그것 참 훌륭한 소식이군. 수고했네."), eventKunshu);
            pk::fade(0);
            pk::sleep();
            pk::background(-1);
            pk::fade(255);
        }

        void RomanUpgradeEvent(pk::force@ force, int level)
        {
            @eventKunshu = pk::get_person(force.kunshu);
            string forceName;
            eventForceId = 우호_대진국;
            eventLevel = level;

            if (force.kokugou != -1)
            {
                forceName = pk::get_kokugou(force.kokugou).get_name() + pk::u8encode("군");
            }
            else
            {
                forceName = pk::get_name(eventKunshu) + pk::u8encode("군");
            }

            @tradeForce = force;

            if (true == force.is_player())
            {
                pk::scene(pk::scene_t(TradeEventScene));
            }
            else
            {
                pk::person@ p = pk::get_person(무장_문관);
                pk::play_se(27);
                switch (eventLevel)
                {
                case 0:
                    pk::message_box(pk::u8encode(pk::format("{}이 \x1b[1x귀갑진\x1b[0x을 획득했다고 합니다.", pk::u8decode(forceName))), p);
                    break;

                case 1:
                    // 만약 해당 기교가 개발중이면 개발 취소
                    if (tradeForce.researching_tech == 기교_투석개발)
                    {
                        auto officers = pk::get_person_list(tradeForce, pk::mibun_flags(신분_군주, 신분_도독, 신분_태수, 신분_일반));

                        for (int i = 0; i < officers.count; ++i)
                        {
                            if (officers[i].order == 무장임무_기교연구)
                            {
                                officers[i].order = 무장임무_없음;
                                officers[i].absence_timer = 0;
                                officers[i].action_done = false;
                            }
                        }
                        
                        tradeForce.researching_tech = -1;
                    }
                    // 투석기교 확득
                    tradeForce.tech[기교_투석개발] = true;
                    ChangeWeaponCatapult(tradeForce);
                    pk::message_box(pk::u8encode(pk::format("{}이 \x1b[1x발석거\x1b[0x를 획득했다고 합니다.", pk::u8decode(forceName))), p);
                    break;

                case 2:
                    pk::message_box(pk::u8encode(pk::format("{}이 \x1b[1x군단병\x1b[0x을 획득했다고 합니다.", pk::u8decode(forceName))), p);
                    break;
                }
            }

            switch (eventLevel)
            {
            case 0:
                pk::history_log(eventKunshu.get_pos(), force.color, pk::u8encode(pk::format("{}이 \x1b[1x귀갑진\x1b[0x을 획득", pk::u8decode(forceName))));
                break;

            case 1:
                pk::history_log(eventKunshu.get_pos(), force.color, pk::u8encode(pk::format("{}이 \x1b[1x발석거\x1b[0x를 획득", pk::u8decode(forceName))));
                break;

            case 2:
                pk::history_log(eventKunshu.get_pos(), force.color, pk::u8encode(pk::format("{}이 \x1b[1x군단병\x1b[0x을 획득", pk::u8decode(forceName))));
                break;
            }
        }

        void ParthianUpgradeEvent(pk::force@ force, int level)
        {
            @eventKunshu = pk::get_person(force.kunshu);
            string forceName;
            eventForceId = 우호_안식국;
            eventLevel = level;

            if (force.kokugou != -1)
            {
                forceName = pk::get_kokugou(force.kokugou).get_name() + pk::u8encode("군");
            }
            else
            {
                forceName = pk::get_name(eventKunshu) + pk::u8encode("군");
            }

            @tradeForce = force;

            if (true == force.is_player())
            {
                pk::scene(pk::scene_t(TradeEventScene));
            }
            else
            {
                pk::person@ p = pk::get_person(무장_문관);
                pk::play_se(27);
                switch (eventLevel)
                {
                case 0:
                    pk::message_box(pk::u8encode(pk::format("{}이 \x1b[1x파도기병술\x1b[0x을 획득했다고 합니다.", pk::u8decode(forceName))), p);
                    break;

                case 1:
                    // 만약 해당 기교가 개발중이면 개발 취소
                    if (tradeForce.researching_tech == 기교_기사)
                    {
                        auto officers = pk::get_person_list(tradeForce, pk::mibun_flags(신분_군주, 신분_도독, 신분_태수, 신분_일반));

                        for (int i = 0; i < officers.count; ++i)
                        {
                            if (officers[i].order == 무장임무_기교연구)
                            {
                                officers[i].order = 무장임무_없음;
                                officers[i].absence_timer = 0;
                                officers[i].action_done = false;
                            }
                        }

                        tradeForce.researching_tech = -1;
                    }
                    // 투석기교 확득
                    tradeForce.tech[기교_기사] = true;
                    pk::message_box(pk::u8encode(pk::format("{}이 \x1b[1x안식사법\x1b[0x을 획득했다고 합니다.", pk::u8decode(forceName))), p);
                    break;

                case 2:
                    pk::message_box(pk::u8encode(pk::format("{}이 \x1b[1x철갑기병\x1b[0x을 획득했다고 합니다.", pk::u8decode(forceName))), p);
                    break;
                }
            }

            switch (eventLevel)
            {
            case 0:
                pk::history_log(eventKunshu.get_pos(), force.color, pk::u8encode(pk::format("{}이 \x1b[1x파도기병술\x1b[0x을 획득", pk::u8decode(forceName))));
                break;

            case 1:
                pk::history_log(eventKunshu.get_pos(), force.color, pk::u8encode(pk::format("{}이 \x1b[1x안식사법\x1b[0x을 획득", pk::u8decode(forceName))));
                break;

            case 2:
                pk::history_log(eventKunshu.get_pos(), force.color, pk::u8encode(pk::format("{}이 \x1b[1x철갑기병\x1b[0x을 획득", pk::u8decode(forceName))));
                break;
            }
        }

        void IndiaUpgradeEvent(pk::force@ force, int level)
        {
            @eventKunshu = pk::get_person(force.kunshu);
            string forceName;
            eventForceId = 우호_천축국;
            eventLevel = level;

            if (force.kokugou != -1)
            {
                forceName = pk::get_kokugou(force.kokugou).get_name() + pk::u8encode("군");
            }
            else
            {
                forceName = pk::get_name(eventKunshu) + pk::u8encode("군");
            }

            @tradeForce = force;

            if (true == force.is_player())
            {
                pk::scene(pk::scene_t(TradeEventScene));
            }
            else
            {
                pk::person@ p = pk::get_person(무장_문관);
                pk::play_se(27);
                switch (eventLevel)
                {
                case 0:
                    // 만약 해당 기교가 개발중이면 개발취소
                    if (tradeForce.researching_tech == 기교_공병육성)
                    {
                        auto officers = pk::get_person_list(tradeForce, pk::mibun_flags(신분_군주, 신분_도독, 신분_태수, 신분_일반));

                        for (int i = 0; i < officers.count; ++i)
                        {
                            if (officers[i].order == 무장임무_기교연구)
                            {
                                officers[i].order = 무장임무_없음;
                                officers[i].absence_timer = 0;
                                officers[i].action_done = false;
                            }
                        }

                        tradeForce.researching_tech = -1;
                    }
                    // 공병육성 획득
                    tradeForce.tech[기교_공병육성] = true;
                    pk::message_box(pk::u8encode(pk::format("{}이 \x1b[1x마누법전\x1b[0x을 획득했다고 합니다.", pk::u8decode(forceName))), p);
                    break;

                case 1:
                    // 만약 해당 기교가 개발중이면 개발 취소
                    if (tradeForce.researching_tech == 기교_법령정비)
                    {
                        auto officers = pk::get_person_list(tradeForce, pk::mibun_flags(신분_군주, 신분_도독, 신분_태수, 신분_일반));

                        for (int i = 0; i < officers.count; ++i)
                        {
                            if (officers[i].order == 무장임무_기교연구)
                            {
                                officers[i].order = 무장임무_없음;
                                officers[i].absence_timer = 0;
                                officers[i].action_done = false;
                            }
                        }

                        tradeForce.researching_tech = -1;
                    }
                    // 투석기교 확득
                    tradeForce.tech[기교_법령정비] = true;
                    pk::message_box(pk::u8encode(pk::format("{}이 \x1b[1x실리론\x1b[0x을 획득했다고 합니다.", pk::u8decode(forceName))), p);
                    break;

                case 2:
                    pk::message_box(pk::u8encode(pk::format("{}이 \x1b[1x가루다진법\x1b[0x을 획득했다고 합니다.", pk::u8decode(forceName))), p);
                    break;
                }
            }

            switch (eventLevel)
            {
            case 0:
                pk::history_log(pk::get_building(eventKunshu.service).pos, force.color, pk::u8encode(pk::format("{}이 \x1b[1x마누법전\x1b[0x을 획득", pk::u8decode(forceName))));
                break;

            case 1:
                pk::history_log(pk::get_building(eventKunshu.service).pos, force.color, pk::u8encode(pk::format("{}이 \x1b[1x실리론\x1b[0x을 획득", pk::u8decode(forceName))));
                break;

            case 2:
                pk::history_log(pk::get_building(eventKunshu.service).pos, force.color, pk::u8encode(pk::format("{}이 \x1b[1x가루다진법\x1b[0x를 획득", pk::u8decode(forceName))));
                break;
            }
        }

        void KushanUpgradeEvent(pk::force@ force, int level)
        {
            @eventKunshu = pk::get_person(force.kunshu);
            string forceName;
            eventForceId = 우호_귀상국;
            eventLevel = level;

            if (force.kokugou != -1)
            {
                forceName = pk::get_kokugou(force.kokugou).get_name() + pk::u8encode("군");
            }
            else
            {
                forceName = pk::get_name(eventKunshu) + pk::u8encode("군");
            }

            @tradeForce = force;

            if (true == force.is_player())
            {
                pk::scene(pk::scene_t(TradeEventScene));
            }
            else
            {
                pk::person@ p = pk::get_person(무장_문관);
                pk::play_se(27);
                switch (eventLevel)
                {
                case 0:
                    // 만약 해당 기교가 개발중이면 개발 취소
                    if (tradeForce.researching_tech == 기교_목우유마)
                    {
                        auto officers = pk::get_person_list(tradeForce, pk::mibun_flags(신분_군주, 신분_도독, 신분_태수, 신분_일반));

                        for (int i = 0; i < officers.count; ++i)
                        {
                            if (officers[i].order == 무장임무_기교연구)
                            {
                                officers[i].order = 무장임무_없음;
                                officers[i].absence_timer = 0;
                                officers[i].action_done = false;
                            }
                        }

                        tradeForce.researching_tech = -1;
                    }
                    // 투석기교 확득
                    tradeForce.tech[기교_목우유마] = true;
                    pk::message_box(pk::u8encode(pk::format("{}이 \x1b[1x전륜왕수송술\x1b[0x을 획득했다고 합니다.", pk::u8decode(forceName))), p);
                    break;

                case 1:
                    pk::message_box(pk::u8encode(pk::format("{}이 \x1b[1x우파베다\x1b[0x를 획득했다고 합니다.", pk::u8decode(forceName))), p);
                    break;

                case 2:
                    pk::message_box(pk::u8encode(pk::format("{}이 \x1b[1x아미타바\x1b[0x를 획득했다고 합니다.", pk::u8decode(forceName))), p);
                    break;
                }
            }

            switch (eventLevel)
            {
            case 0:
                pk::history_log(pk::get_building(eventKunshu.service).pos, force.color, pk::u8encode(pk::format("{}이 \x1b[1x전륜왕수송술\x1b[0x을 획득", pk::u8decode(forceName))));
                break;

            case 1:
                pk::history_log(pk::get_building(eventKunshu.service).pos, force.color, pk::u8encode(pk::format("{}이 \x1b[1x우파베다\x1b[0x를 획득", pk::u8decode(forceName))));
                break;

            case 2:
                pk::history_log(pk::get_building(eventKunshu.service).pos, force.color, pk::u8encode(pk::format("{}이 \x1b[1x아미타바\x1b[0x를 획득", pk::u8decode(forceName))));
                break;
            }
        }

        void RapprochmentUpgradeEvent(pk::force@ force, int type, int level)
        {
            @eventKunshu = pk::get_person(force.kunshu);
            string forceName;
            eventRapprochmentLevel = level;
            eventAlienId = type;

            if (force.kokugou != -1)
            {
                forceName = pk::get_kokugou(force.kokugou).get_name() + pk::u8encode("군");
            }
            else
            {
                forceName = pk::get_name(eventKunshu) + pk::u8encode("군");
            }

            @tradeForce = force;

            if (true == force.is_player())
            {
                pk::scene(pk::scene_t(RapprochmentEventScene));
            }
            else
            {
                pk::person@ p = pk::get_person(무장_문관);
                pk::play_se(27);
                switch (eventRapprochmentLevel)
                {
                case 0:
                    pk::message_box(pk::u8encode(pk::format("{}이 \x1b[1x{}\x1b[0x과 우호관계를 맺은 듯 합니다.", pk::u8decode(forceName), 교역대상_이름[eventAlienId])));
                    break;

                case 1:
                    pk::message_box(pk::u8encode(pk::format("{}이 \x1b[1x{}\x1b[0x과 더욱 친밀해진것 같습니다.", pk::u8decode(forceName), 교역대상_이름[eventAlienId])));
                    break;

                case 2:
                    pk::message_box(pk::u8encode(pk::format("{}이 \x1b[1x{}\x1b[0x과 아주 가까운 사이가 되었다고 합니다.", pk::u8decode(forceName), 교역대상_이름[eventAlienId])));
                    break;
                }
            }

            // 우호가 생성됐을 경우 이민족 철군 및 동맹
            if (eventRapprochmentLevel == 0)
            {
                pk::set_ally(force, 교역대상_아이디[eventAlienId], true);
                ResetBarbarianUnits(eventAlienId, 이민족_철군_동맹);
            }

            pk::history_log(eventKunshu.get_pos(), force.color, pk::u8encode(pk::format("\x1b[1x{}\x1b[0x과 \x1b[1x{}\x1b[0x의 우호가 상승", pk::u8decode(forceName), 교역대상_이름[eventAlienId])));
        }

        void RelationDownGradeEvent(pk::force@ force, int type, int level)
        {
            pk::person@ kunshu = pk::get_person(force.kunshu);
            pk::person@ moo = pk::get_person(무장_문관);
            string forceName = "";

            if (force.kokugou != -1)
            {
                forceName = pk::get_kokugou(force.kokugou).get_name() + pk::u8encode("군");
            }
            else
            {
                forceName = pk::get_name(kunshu) + pk::u8encode("군");
            }

            if (true == force.is_player())
            {
                pk::play_se(11);
                if (level > 1)
                {
                    pk::message_box(pk::u8encode(pk::format("\x1b[1x{}\x1b[0x이 아군을 수상하게 생각하는것 같습니다.", 교역대상_이름[type])), moo);
                }
                else
                {
                    pk::message_box(pk::u8encode(pk::format("\x1b[1x{}\x1b[0x이 더 이상 아군에게 호의적이지 않습니다.", 교역대상_이름[type])), moo);
                }
            }
            else
            {
                pk::play_se(27);
                if (level > 0)
                {
                    pk::message_box(pk::u8encode(pk::format("{}과 \x1b[1x{}\x1b[0x의 관계가 어색해진것 같습니다.", pk::u8decode(forceName), 교역대상_이름[type])), moo);
                }
                else
                {
                    pk::message_box(pk::u8encode(pk::format("{}과 \x1b[1x{}\x1b[0x이 서로 돌아선것 같습니다.", pk::u8decode(forceName), 교역대상_이름[type])), moo);
                }
            }

            // 우호도가 모두 하락했을 경우 동맹 파기
            if (level <= 0)
            {
                pk::unally(force, 교역대상_아이디[eventAlienId]);
            }

            pk::history_log(pk::get_person(force.kunshu).get_pos(), force.color, pk::u8encode(pk::format("\x1b[1x{}\x1b[0x과 \x1b[1x{}\x1b[0x의 관계가 악화", pk::u8decode(forceName), 교역대상_이름[type])));
        }

        // ==========================================================================================================================================

        // ================================================= Shift 우클릭 메뉴 추가 ========================================================================

           /* =========================================================== 지역이점 출력 ==================================================================== */
        void AddPrintRegionBuffMenu()
        {
            pk::menu_item item;
            item.menu = 2;
            item.is_enabled = pk::menu_item_is_enabled_t(IsPrintEnabled);
            item.get_text = pk::menu_item_get_text_t(GetPrintRegionBuffText);
            item.get_desc = pk::menu_item_get_desc_t(GetPrintRegionBuffDesc);
            item.handler = pk::menu_item_handler_t(PrintRegionBuffHandler);
            pk::add_menu_item(item);
        }

        bool IsPrintEnabled()
        {
            return true;
        }

        string GetPrintRegionBuffText()
        {
            return pk::u8encode("지역이점 출력");
        }

        string GetPrintRegionBuffDesc()
        {
            return pk::u8encode("선택하면 각 세력의 지역이점을 출력합니다");
        }

        bool PrintRegionBuffHandler()
        {
            PrintRegionBuffInfo();
            return true;
        }

        /* =========================================================== 지역이점 도움말 ==================================================================== */
        pk::person@ helpMoo;

        void AddRegionBuffHelpMenu()
        {
            pk::menu_item item;
            item.menu = 2;
            item.is_enabled = pk::menu_item_is_enabled_t(IsHelpEnabled);
            item.get_text = pk::menu_item_get_text_t(GetRegionBuffHelpText);
            item.get_desc = pk::menu_item_get_desc_t(GetRegionBuffHelpDesc);
            item.handler = pk::menu_item_handler_t(RegionBuffHelpHandler);
            pk::add_menu_item(item);
        }

        bool IsHelpEnabled()
        {
            return true;
        }

        string GetRegionBuffHelpText()
        {
            return pk::u8encode("지역이점이란?");
        }

        string GetRegionBuffHelpDesc()
        {
            return pk::u8encode("선택하면 각 지역이점에 대한 설명을 볼 수 있습니다");
        }

        bool RegionBuffHelpHandler()
        {
            @helpMoo = pk::get_person(무장_주유);

            array<string> helpList =
            {
                pk::u8encode("지역이점 개요"),
                pk::u8encode("각 주의 지역이점"),
                pk::u8encode("이민족과의 외교"),
                pk::u8encode("교역"),
                pk::u8encode("뒤로가기")
            };

            int n = pk::choose(helpList, pk::u8encode("궁금한 사항을 선택해주십시오."), helpMoo);

            switch (n)
            {
            case 0:
                return HelpOutline();

            case 1:
                return HelpAdvantage();

            case 2:
                return HelpRapprochment();

            case 3:
                return HelpTrade();

            case 4:
                return false;
            }

            return false;
        }
        

        // 지역이점 개요
        bool HelpOutline()
        {
            pk::message_box(pk::u8encode("\x1b[2x삼국지11\x1b[0x에는 총 16개의 주가 존재하는데, 각각의 주마다 다른 효과의 \x1b[1x지역이점\x1b[0x이 책정되어 있습니다."), helpMoo);
            pk::message_box(pk::u8encode("각 주마다 주를 제패하는 조건이 다르게 설정되어 있고, 조건을 만족하는 세력에게 그 주의 지역이점이 적용됩니다."), helpMoo);
            pk::message_box(pk::u8encode("몇몇 이점은 주를 제패하는 순간 바로 적용되고, 몇몇은 타 세력과 교역을 실행해야 적용됩니다."), helpMoo);

            return  RegionBuffHelpHandler();
        }

        // 각 주의 지역이점
        bool HelpAdvantage()
        {
            array<string> helpList =
            {
                pk::u8encode("병주, 기주, 청주, 서주의 지역이점"),
                pk::u8encode("회남, 연주, 예주, 형북의 지역이점"),
                pk::u8encode("유주, 량주, 양주, 남중의 이민족"),
                pk::u8encode("사예, 경조, 형남, 익주의 교역"),
                pk::u8encode("뒤로가기")
            };

            int n = pk::choose(helpList, pk::u8encode("궁금한 지역을 선택해주십시오."), helpMoo);

            switch (n)
            {
            case 0:
                pk::message_box(pk::u8encode("\x1b[1x병주\x1b[0x의 지역이점은 \x1b[1x진양\x1b[0x을 소유한 세력에게 적용됩니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[1x병주\x1b[0x를 제패한 세력은 자세력의 영토가 아닌 지역에서 전투부대의 매턴 기력이 회복되고"), helpMoo);
                pk::message_box(pk::u8encode("병기, 수군을 제외한 부대의 이동속도가 증가합니다."), helpMoo);

                pk::message_box(pk::u8encode("\x1b[1x기주\x1b[0x의 지역이점은 \x1b[1x업\x1b[0x과 \x1b[1x남피\x1b[0x를 소유한 세력에게 적용됩니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[1x기주\x1b[0x를 제패한 세력은 부하 무장들의 충성도가 매월 증가하고 봉록의 일부를 절약할 수 있게됩니다."), helpMoo);
                
                pk::message_box(pk::u8encode("\x1b[1x청주\x1b[0x의 지역이점은 \x1b[1x평원\x1b[0x과 \x1b[1x북해\x1b[0x를 소유한 세력에게 적용됩니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[1x청주\x1b[0x를 제패한 세력은 매 턴 내정시설의 체력이 증가하며, 매월 초에 모든 도시의 치안이 증가합니다."), helpMoo);
               
                pk::message_box(pk::u8encode("\x1b[1x서주\x1b[0x의 지역이점은 \x1b[1x하비\x1b[0x와 \x1b[1x소패\x1b[0x를 소유한 세력에게 적용됩니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[1x서주\x1b[0x를 제패한 세력은 거점의 공격력이 증가하고, 매 턴 도시의 내구도가 조금씩 추가 회복됩니다."), helpMoo);
                return HelpAdvantage();

            case 1:
                pk::message_box(pk::u8encode("\x1b[1x회남\x1b[0x의 지역이점은 \x1b[1x수춘\x1b[0x과 \x1b[1x여강\x1b[0x을 소유한 세력에게 적용됩니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[1x회남\x1b[0x을 제패한 세력은 부대가 계략을 실행할때 소비 기력이 일부 감소합니다."), helpMoo);

                pk::message_box(pk::u8encode("\x1b[1x연주\x1b[0x의 지역이점은 \x1b[1x진류\x1b[0x와 \x1b[1x복양\x1b[0x을 소유한 세력에게 적용됩니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[1x연주\x1b[0x를 제패한 세력은 도시의 창,극,노의 생산량이 증가합니다."), helpMoo);

                pk::message_box(pk::u8encode("\x1b[1x예주\x1b[0x의 지역이점은 \x1b[1x허창\x1b[0x과 \x1b[1x여남\x1b[0x을 소유한 세력에게 적용됩니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[1x예주\x1b[0x를 제패한 세력은 무장의 이동,소환,귀환의 필요일수가 감소합니다."), helpMoo);

                pk::message_box(pk::u8encode("\x1b[1x형북\x1b[0x의 지역이점은 \x1b[1x양양\x1b[0x, \x1b[1x강릉\x1b[0x, \x1b[1x강하\x1b[0x, \x1b[1x신야\x1b[0x중 \x1b[1x양양\x1b[0x을 포함한 세 도시를 소유한 세력에게 적용됩니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[1x형북\x1b[0x을 제패한 세력은 매월 기교포인트가 증가하고 재야,포로 무장의 등용확률이 증가합니다."), helpMoo);
                return HelpAdvantage();

            case 2:
                pk::message_box(pk::u8encode("\x1b[1x유주\x1b[0x의 지역이점은 \x1b[1x북평\x1b[0x, \x1b[1x계\x1b[0x, \x1b[1x양평\x1b[0x중 \x1b[1x북평\x1b[0x을 포함한 두 도시를 소유한 세력에게 적용됩니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[1x유주\x1b[0x를 제패한 세력은 \x1b[2x오환\x1b[0x과의 외교가 가능해집니다."), helpMoo);

                pk::message_box(pk::u8encode("\x1b[1x량주\x1b[0x의 지역이점은 \x1b[1x무위\x1b[0x, \x1b[1x천수\x1b[0x, \x1b[1x안정\x1b[0x중 \x1b[1x무위\x1b[0x를 포함한 두 도시를 소유한 세력에게 적용됩니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[1x량주\x1b[0x를 제패한 세력은 \x1b[2x강\x1b[0x과의 외교가 가능해집니다."), helpMoo);

                pk::message_box(pk::u8encode("\x1b[1x양주\x1b[0x의 지역이점은 \x1b[1x건업\x1b[0x, \x1b[1x오\x1b[0x, \x1b[1x회계\x1b[0x, \x1b[1x시상\x1b[0x중 \x1b[1x건업\x1b[0x을 포함한 세 도시를 소유한 세력에게 적용됩니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[1x양주\x1b[0x를 제패한 세력은 \x1b[2x산월\x1b[0x과의 외교가 가능해집니다."), helpMoo);

                pk::message_box(pk::u8encode("\x1b[1x남중\x1b[0x의 지역이점은 \x1b[1x운남\x1b[0x과 \x1b[1x건녕\x1b[0x을 소유한 세력에게 적용됩니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[1x남중\x1b[0x을 제패한 세력은 \x1b[2x남만\x1b[0x과의 외교가 가능해집니다."), helpMoo);
                return HelpAdvantage();

            case 3:
                pk::message_box(pk::u8encode("\x1b[1x사예\x1b[0x의 지역이점은 \x1b[1x낙양\x1b[0x을 소유한 세력에게 적용됩니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[1x사예\x1b[0x를 제패한 세력은 \x1b[2x대진국\x1b[0x과의 교역이 가능해집니다."), helpMoo);

                pk::message_box(pk::u8encode("\x1b[1x경조\x1b[0x의 지역이점은 \x1b[1x장안\x1b[0x, \x1b[1x상용\x1b[0x, \x1b[1x완\x1b[0x중 \x1b[1x장안\x1b[0x을 포함한 두 도시를 소유한 세력에게 적용됩니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[1x경조\x1b[0x를 제패한 세력은 \x1b[2x안식국\x1b[0x과의 교역이 가능해집니다."), helpMoo);

                pk::message_box(pk::u8encode("\x1b[1x형남\x1b[0x의 지역이점은 \x1b[1x장사\x1b[0x, \x1b[1x무릉\x1b[0x, \x1b[1x계양\x1b[0x, \x1b[1x영릉\x1b[0x중 \x1b[1x장사\x1b[0x를 포함한 세 도시를 소유한 세력에게 적용됩니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[1x형남\x1b[0x을 제패한 세력은 \x1b[2x천축국\x1b[0x과의 교역이 가능해집니다."), helpMoo);

                pk::message_box(pk::u8encode("\x1b[1x익주\x1b[0x의 지역이점은 \x1b[1x성도\x1b[0x, \x1b[1x한중\x1b[0x, \x1b[1x자동\x1b[0x, \x1b[1x강주\x1b[0x, \x1b[1x영안\x1b[0x중 \x1b[1x성도\x1b[0x를 포함한 세 도시를 소유한 세력에게 적용됩니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[1x익주\x1b[0x를 제패한 세력은 \x1b[2x귀상국\x1b[0x과의 교역이 가능해집니다."), helpMoo);
                return HelpAdvantage();

            case 4:
                return RegionBuffHelpHandler();
            }

            return RegionBuffHelpHandler();
        }
        
        // 이민족
        bool HelpRapprochment()
        {
            array<string> helpList =
            {
                pk::u8encode("이민족 개요"),
                pk::u8encode("오환족"),
                pk::u8encode("강족"),
                pk::u8encode("남만족"),
                pk::u8encode("산월족"),
                pk::u8encode("뒤로가기")
            };

            int n = pk::choose(helpList, pk::u8encode("궁금한 항목을 선택해주십시오."), helpMoo);

            switch (n)
            {
            case 0:
                pk::message_box(pk::u8encode("이민족과 외교가 가능한 지역이점을 획득하면 도시의 외교 메뉴에서 \x1b[2x이민족\x1b[0x이라는 항목을 사용할 수 있습니다."), helpMoo);
                pk::message_box(pk::u8encode("이민족과의 외교에는 기교포인트와 금이 필요하고, 단계가 올라갈수록 더 많은 금이 필요합니다."), helpMoo);
                pk::message_box(pk::u8encode("해당 이민족과 친분이 있는 무장이 세력에 존재할 경우 필요한 금이 일부분 감소됩니다."), helpMoo);
                pk::message_box(pk::u8encode("이민족과의 우호단계는 0단계부터 최대 3단계가 있습니다. 우호는 외교의 \x1b[2x이민족\x1b[0x 항목을 통해서만 증가시킬 수 있습니다."), helpMoo);
                pk::message_box(pk::u8encode("이민족과 우호도가 하락하는 요인에는 해당 지역이점 상실 또는 해당 주의 도시 치안이 특정 수치 이하로 떨어지는 것 입니다."), helpMoo);
                pk::message_box(pk::u8encode("우호도가 하락하게되면 상위 단계의 효과를 상실하게 됩니다."), helpMoo);
                return HelpRapprochment();
            case 1:
                pk::message_box(pk::u8encode("\x1b[2x오환\x1b[0x과의 외교는 \x1b[1x유주\x1b[0x 지역을 제패하면 가능해집니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[2x오환\x1b[0x과 1단계의 우호도를 달성하면 분기마다 \x1b[1x유주\x1b[0x의 한 도시에 병력과 군마를 약간 공급받게 됩니다."), helpMoo);
                pk::message_box(pk::u8encode("2단계의 우호도를 달성하면 분기마다 공급받는 물자의 양이 조금 상승하고, 매년 1월에 무장 한명에게 \x1b[2x오환\x1b[0x의 특기를 전수할 수 있게 됩니다."), helpMoo);
                pk::message_box(pk::u8encode("3단계의 우호도를 달성하면 아군 기병이 적을 사로잡는 확률을 높여줍니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[2x오환\x1b[0x과의 우호도가 1단계 이상인 동안에는  \x1b[1x유주\x1b[0x 지역에 도적과 오환족이 출몰하지 않습니다."), helpMoo);
                return HelpRapprochment();
            case 2:
                pk::message_box(pk::u8encode("\x1b[2x강\x1b[0x과의 외교는 \x1b[1x량주\x1b[0x 지역을 제패하면 가능해집니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[2x강\x1b[0x과 1단계의 우호도를 달성하면 분기마다 \x1b[1x량주\x1b[0x의 한 도시에 병력과 군마를 약간 공급받게 됩니다."), helpMoo);
                pk::message_box(pk::u8encode("2단계의 우호도를 달성하면 분기마다 공급받는 물자의 양이 조금 상승하고, 매년 10월에 무장 한명에게 \x1b[2x강\x1b[0x의 특기를 전수할 수 있게 됩니다."), helpMoo);
                pk::message_box(pk::u8encode("3단계의 우호도를 달성하면 아군 기병이 적에게 포로가 될 확률을 줄여줍니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[2x강\x1b[0x과의 우호도가 1단계 이상인 동안에는  \x1b[1x량주\x1b[0x 지역에 도적과 강족이 출몰하지 않습니다."), helpMoo);
                return HelpRapprochment();
            case 3:
                pk::message_box(pk::u8encode("\x1b[2x남만\x1b[0x과의 외교는 \x1b[1x남중\x1b[0x 지역을 제패하면 가능해집니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[2x남만\x1b[0x과 1단계의 우호도를 달성하면 매 달 \x1b[1x남중\x1b[0x의 한 도시에 병력과 창,극을 약간 공급받게 됩니다."), helpMoo);
                pk::message_box(pk::u8encode("2단계의 우호도를 달성하면 분기마다 공급받는 물자의 양이 조금 상승하고, 매년 4월에 무장 한명에게 \x1b[2x남만\x1b[0x의 특기를 전수할 수 있게 됩니다."), helpMoo);
                pk::message_box(pk::u8encode("3단계의 우호도를 달성하면 아군의 검,창,극,노병이 숲에 위치할때 공격력이 증가합니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[2x남만\x1b[0x과의 우호도가 1단계 이상인 동안에는  \x1b[1x남중\x1b[0x 지역에 도적과 남만족이 출몰하지 않습니다."), helpMoo);
                return HelpRapprochment();
            case 4:
                pk::message_box(pk::u8encode("\x1b[2x산월\x1b[0x과의 외교는 \x1b[1x양주\x1b[0x 지역을 제패하면 가능해집니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[2x산월\x1b[0x과 1단계의 우호도를 달성하면 분기마다 \x1b[1x양주\x1b[0x의 한 도시에 병력과 극을 약간 공급받게 됩니다."), helpMoo);
                pk::message_box(pk::u8encode("2단계의 우호도를 달성하면 분기마다 투함을 추가로 제공받고, 매년 7월에 무장 한명에게 \x1b[2x산월\x1b[0x의 특기를 전수할 수 있게 됩니다."), helpMoo);
                pk::message_box(pk::u8encode("3단계의 우호도를 달성하면 아군의 극병이 일반공격으로도 포로를 사로잡을 확률이 증가하게 됩니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[2x산월\x1b[0x과의 우호도가 1단계 이상인 동안에는  \x1b[1x양주\x1b[0x 지역에 도적과 산월족이 출몰하지 않습니다."), helpMoo);
            case 5:
                return RegionBuffHelpHandler();
            }

            return  RegionBuffHelpHandler();
        }


        //교역
        bool HelpTrade()
        {
            array<string> helpList =
            {
                pk::u8encode("교역 개요"),
                pk::u8encode("대진국"),
                pk::u8encode("안식국"),
                pk::u8encode("천축국"),
                pk::u8encode("귀상국"),
                pk::u8encode("뒤로가기")
            };

            int n = pk::choose(helpList, pk::u8encode("궁금한 항목을 선택해주십시오."), helpMoo);
            switch (n)
            {
            case 0:
                pk::message_box(pk::u8encode("외국과 교역이 가능한 지역이점을 획득하면 도시의 외교 메뉴에서 \x1b[2x교역\x1b[0x이라는 항목을 사용할 수 있습니다."), helpMoo);
                pk::message_box(pk::u8encode("교역에는 기교포인트와 금,군량,병력이 필요하고, 단계가 올라갈수록 더 많은 물자들이 필요합니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[2x대진국\x1b[0x과 \x1b[2x안식국\x1b[0x, 그리고 \x1b[1x천축국\x1b[0x과 \x1b[1x귀상국\x1b[0x은 서로 적대적인 관계에 있기 때문에 동시 교역은 불가능합니다."), helpMoo);
                pk::message_box(pk::u8encode("교역을 통한 우호단계는 0단계부터 최대 3단계가 있습니다. 우호는 외교의 \x1b[2x교역\x1b[0x 항목을 통해서만 증가시킬 수 있습니다."), helpMoo);
                pk::message_box(pk::u8encode("특정 단계의 교역을 달성하게 되면 기존에 개발하지 않던 기교연구를 얻을수 있고 부가효과까지 얻을 수 있습니다."), helpMoo);
                pk::message_box(pk::u8encode("현재 외국과의 우호도는 하락하지 않기 때문에 높은단계의 우호도를 쌓게된다면 해당 지역이점을 상실해도 우호도는 유지되지만"), helpMoo);
                pk::message_box(pk::u8encode("지역이점을 상실한 경우에는 교역으로 인한 부가효과가 절반으로 감소하게 됩니다."), helpMoo);
                return HelpTrade();
            case 1:
                pk::message_box(pk::u8encode("\x1b[2x대진국\x1b[0x과의 교역은 \x1b[1x사예\x1b[0x 지역을 제패하면 가능해집니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[2x대진국\x1b[0x과 1단계의 우호도를 달성하면 \x1b[1x귀갑진\x1b[0x을 얻게되며 아군 창병부대의 방어력이 추가로 증가합니다."), helpMoo);
                pk::message_box(pk::u8encode("2단계의 우호도를 달성하면 그들의 공성병기 \x1b[1x발석거\x1b[0x를 얻게됩니다. 효과는 기교 \x1b[2x투석\x1b[0x을 획득하며 아군 투석부대의 공격력이 추가로 증가합니다."), helpMoo);
                pk::message_box(pk::u8encode("3단계의 우호도를 달성하면 \x1b[2x대진국\x1b[0x이 자랑하는 \x1b[1x군단병\x1b[0x을 전수받아 아군 창병부대의 방어력이 더욱 증가합니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[2x대진국\x1b[0x과 교역을 시작하게 되면 \x1b[2x안식국\x1b[0x과는 교역이 불가능해집니다."), helpMoo);
                return HelpTrade();
            case 2:
                pk::message_box(pk::u8encode("\x1b[2x안식국\x1b[0x과의 교역은 \x1b[1x경조\x1b[0x 지역을 제패하면 가능해집니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[2x안식국\x1b[0x과 1단계의 우호도를 달성하면 \x1b[1x파도기병술\x1b[0x을 통해 아군 기병부대의 공격력이 추가로 증가합니다."), helpMoo);
                pk::message_box(pk::u8encode("2단계의 우호도를 달성하면 \x1b[1x안식사법\x1b[0x을 전수받습니다. 효과는 기교 \x1b[2x기사\x1b[0x를 획득하며 아군 기병이 행동종료시 일정 확률로 적에게 추가 사격을 합니다."), helpMoo);
                pk::message_box(pk::u8encode("3단계의 우호도를 달성하면 \x1b[2x안식국\x1b[0x이 자랑하는 \x1b[1x철갑기병\x1b[0x을 전수받아 아군 기병부대의 공격력이 더욱 증가합니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[2x안식국\x1b[0x과 교역을 시작하게 되면 \x1b[2x대진국\x1b[0x과는 교역이 불가능해집니다."), helpMoo);
                return HelpTrade();
            case 3:
                pk::message_box(pk::u8encode("\x1b[2x천축국\x1b[0x과의 교역은 \x1b[1x형남\x1b[0x 지역을 제패하면 가능해집니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[2x천축국\x1b[0x과 1단계의 우호도를 달성하면 \x1b[1x마누법전\x1b[0x을 전수받습니다. 효과는 기교 \x1b[2x공병육성\x1b[0x을 획득하며"), helpMoo);
                pk::message_box(pk::u8encode("도시 점령시 파괴되는 시설과 소실되는 금, 군량, 병사의 양을 줄여줍니다."), helpMoo);
                pk::message_box(pk::u8encode("2단계의 우호도를 달성하면 \x1b[1x실리론\x1b[0x을 전수받습니다. 효과는 기교 \x1b[2x법령정비\x1b[0x를 획득하며 징병시 감소되는 치안이 경감됩니다."), helpMoo);
                pk::message_box(pk::u8encode("3단계의 우호도를 달성하면 \x1b[1x가루다진법\x1b[0x을 전수받아 기병,병기를 제외한 아군 부대가 도시 근처에서 추가 전투력을 얻게됩니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[2x천축국\x1b[0x과 교역을 시작하게 되면 \x1b[2x귀상국\x1b[0x과는 교역이 불가능해집니다."), helpMoo);
                return HelpTrade();
            case 4:
                pk::message_box(pk::u8encode("\x1b[2x귀상국\x1b[0x과의 교역은 \x1b[1x익주\x1b[0x 지역을 제패하면 가능해집니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[2x귀상국\x1b[0x과 1단계의 우호도를 달성하면 \x1b[1x전륜왕수송술\x1b[0x을 얻게됩니다."), helpMoo);
                pk::message_box(pk::u8encode("효과는 기교 \x1b[2x목우유마\x1b[0x를 획득하며 수송부대의 기동력이 추가로 증가합니다."), helpMoo);
                pk::message_box(pk::u8encode("2단계의 우호도를 달성하면 \x1b[1x우파베다\x1b[0x를 전수받아 아군 노병부대의 공격력이 추가로 증가합니다."), helpMoo);
                pk::message_box(pk::u8encode("3단계의 우호도를 달성하면 \x1b[1x아미타바\x1b[0x를 통해 매 턴이 시작될때 일정확률로 상태이상인 아군 부대가 상태회복이 되며, 회복된 부대는 그 턴에 행동이 가능하게 됩니다."), helpMoo);
                pk::message_box(pk::u8encode("\x1b[2x귀상국\x1b[0x과 교역을 시작하게 되면 \x1b[2x천축국\x1b[0x과는 교역이 불가능해집니다."), helpMoo);
                return HelpTrade();
            case 5:
                return RegionBuffHelpHandler();
            }
            return RegionBuffHelpHandler();
        }
        // ===============================================================================================================================================

        // ====================================================== 이민족 원군요청 ==========================================================================

        void AddSupportMenu()
        {
            pk::menu_item item;
            item.menu = 103;
            item.pos = 9;
            item.shortcut = "B";
            item.init = pk::building_menu_item_init_t(SupportInit);
            item.is_enabled = pk::menu_item_is_enabled_t(SupportEnabled);
            item.get_text = pk::menu_item_get_text_t(GetSupportText);
            item.get_desc = pk::menu_item_get_desc_t(GetSupportDescription);
            item.handler = pk::menu_item_handler_t(SupportHandler);
            pk::add_menu_item(item);
        }

        void SupportInit(pk::building@ building)
        {
            @tradeBuilding = @building;
            tradeBuildingGold = pk::get_gold(building);
            @tradeForce = pk::get_force(building.get_force_id());
            @tradeKunshu = pk::get_person(tradeForce.kunshu);
            @tradeCity = pk::building_to_city(tradeBuilding);
            tradeBuildingGold = pk::get_gold(building);
            tradeData = GetPossibleTrade(tradeForce, tradeBuilding, tradeStatus);
        }

        bool SupportEnabled()
        {
            if (이민족지원_사용여부 == 0)
                return false;

            int year = pk::get_elapsed_years();
            year = pk::min(year, 10);

            int gold = 이민족_원군요청_기본금 + year * 이민족_원군요청_추가금;

            if (tradeBuildingGold < gold)
            {
                return false;
            }

            if (tradeForce.tp < 이민족_원군요청_기교)
            {
                return false;
            }

            if (GetSupportData(tradeForce) > 0)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        string GetSupportText()
        {
            return  pk::u8encode("이민족 요청");
        }

        string GetSupportDescription()
        {
            if (이민족지원_사용여부 == 0)
                return pk::u8encode("이민족 지원이 사용금지 상태입니다.");

            int year = pk::get_elapsed_years();
            year = pk::min(year, 10);

            int gold = 이민족_원군요청_기본금 + year * 이민족_원군요청_추가금;

            if (tradeBuildingGold < gold)
            {
                return pk::u8encode(pk::format("원군요청에 필요한 금이 부족합니다. (금 : {} 필요)", gold));
            }

            int data = GetSupportData(tradeForce);

            if (data > 0)
            {
                return pk::u8encode(pk::format("이민족에게 지원군을 요청합니다. (기교P : {} , 금 : {} 소비)", 이민족_원군요청_기교, gold));
            }
            else
            {
                if (0 == data)
                {
                    return pk::u8encode("요청 가능한 이민족이 없습니다.");
                }
                else if (-1 == data)
                {
                    return pk::u8encode(pk::format("기교가 부족합니다. (기교 P : {} 필요)", 이민족_원군요청_기교));
                }
                else if (-2 == data)
                {
                    return pk::u8encode("요청 가능한 도시가 없습니다.");
                }
                else
                {
                    return "";
                }
            }
        }

        bool SupportHandler()
        {
            int year = pk::get_elapsed_years();

            int gold = 이민족_원군요청_기본금 + year * 이민족_원군요청_추가금;

            pk::person@ barbarianMoo;
            int forceId = tradeForce.get_force_id();
            //pk::list<pk::force@> force_sel = pk::force_selector(pk::u8encode("세력 선택"), pk::u8encode("교류의 대상을 선택합니다."), forceList, 1, 1);
            pk::list<pk::force@> forceList;
            pk::list<pk::city@> validCityList;

            int targetForceId = -1;

            int data = GetSupportData(tradeForce);
            
            if (data <= 0)
            {
                return false;
            }
             
            if (data % 2 == 1)
            {
                forceList.add(pk::get_force(세력_오환));
            }
            // 강
            if ((data / 2) % 2 == 1)
            {
                forceList.add(pk::get_force(세력_강));
            }
            // 남만
            if ((data / 4) % 2 == 1)
            {
                forceList.add(pk::get_force(세력_남만));
            }
            // 산월
            if ((data / 8) % 2 == 1)
            {
                forceList.add(pk::get_force(세력_산월));
            }

            if (forceList.count != 0)
            {
                pk::list<pk::force@> force_sel = pk::force_selector(pk::u8encode("세력 선택"), pk::u8encode("지원을 요청할 세력을 선택합니다."), forceList, 1, 1);

                if (force_sel.count == 0)
                {
                    return false; // 미선택 시 취소 종료
                }

                switch (force_sel[0].get_id())
                {
                case 세력_오환:
                    targetForceId = 우호_오환;
                    @barbarianMoo = pk::get_person(무장_오환두목);
                    break;

                case 세력_강:
                    targetForceId = 우호_강;
                    @barbarianMoo = pk::get_person(무장_강두목);
                    break;

                case 세력_남만:
                    targetForceId = 우호_남만;
                    @barbarianMoo = pk::get_person(무장_남만두목);
                    break;

                case 세력_산월:
                    targetForceId = 우호_산월;
                    @barbarianMoo = pk::get_person(무장_산월두목);
                    break;
                }
            }

            validCityList = GetValidSupportCityList(tradeForce, targetForceId);

            pk::list<pk::city@> city_sel = pk::city_selector2(pk::u8encode("도시 선택"), pk::u8encode("도움을 요청할 지역을 선택합니다."), validCityList, 1, 1);

            if (city_sel.count <= 0)
            {
                return false;
            }

            if (city_sel[0].get_force_id() == forceId)
            {
                // 수비 요청 불가
                //if (true == pk::yes_no(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x에게 \x1b[1x{}\x1b[0x의 방어를 요청하시겠습니까?", 교역대상_이름[targetForceId], pk::u8decode(pk::get_name(city_sel[0]))))))
                //{
                //    SetBarbarianForceData(targetForceId, 이민족_지속기간);
                //    pk::add_tp(tradeForce, -이민족_원군요청_기교, tradeBuilding.get_pos());
                //    SummonBarbarianForce(city_sel[0], 부대임무_수복, targetForceId, GetBarbarianSupportUnitCount, GetBarbarianSupportUnitTroops());
                //}
            }
            else
            {
                // 공격 요청
                if (true == pk::yes_no(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x에게 \x1b[1x{}\x1b[0x의 공격을 요청하시겠습니까?", 교역대상_이름[targetForceId], pk::u8decode(pk::get_name(city_sel[0]))))))
                {
                    MoveScreen(city_sel[0].get_pos());
                    SetBarbarianForceData(forceId, city_sel[0].get_id(), targetForceId, 이민족_지속기간);
                    pk::add_tp(tradeForce, -이민족_원군요청_기교, tradeBuilding.get_pos());
                    pk::add_gold(tradeBuilding, -gold, true);
                    SummonBarbarianForce(tradeForce, city_sel[0], 부대임무_정복, targetForceId, GetBarbarianSupportUnitCount(), GetBarbarianSupportUnitTroops());
                    pk::play_se(10);
                    if (true == pk::rand_bool(50))
                    {
                        pk::message_box(pk::u8encode(pk::format("후후.. 걱정마시오. \x1b[1x{}\x1b[0x 따위는 단숨에 점령해주겠소.", pk::u8decode(pk::get_name(city_sel[0])))), barbarianMoo);
                    }
                    else
                    {
                        pk::message_box(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x공의 부탁이라면 거절할 수 없지. 바로 쳐들어가도록 하겠소.", pk::u8decode(pk::get_name(tradeKunshu)))), barbarianMoo);
                    }
                }
            }

            return true;
        }

        // ============================================================ 자세력 내 대회개최 ================================================================
        pk::list<pk::person@> singleCompetitionPersonList;
        int competitionType;

        void AddCompetitionMenu()
        {
            pk::menu_item item;
            item.menu = 105;
            item.pos = 9;
            item.shortcut = "C";
            item.init = pk::building_menu_item_init_t(CompetitionInit);
            item.is_enabled = pk::menu_item_is_enabled_t(CompetitionEnabled);
            item.get_text = pk::menu_item_get_text_t(GetCompetitionText);
            item.get_desc = pk::menu_item_get_desc_t(GetCompetitionDescription);
            item.handler = pk::menu_item_handler_t(CompetitionHandler);
            pk::add_menu_item(item);
        }

        void CompetitionInit(pk::building@ building)
        {
            @tradeBuilding = @building;
            @tradeForce = pk::get_force(building.get_force_id());
            tradeBuildingGold = pk::get_gold(building);
            tradeData = GetPossibleHoldSingleCompetition(tradeForce, tradeBuilding);
        }

        bool CompetitionEnabled()
        {
            if (자세력_대회_개최여부 == 0)
            {
                return false;
            }

            if (tradeData > 2 || -1 == tradeData)
            {
                return false;
            }

            return true;
        }

        string GetCompetitionText()
        {
            return  pk::u8encode("대회");
        }

        string GetCompetitionDescription()
        {
            if (자세력_대회_개최여부 == 0)
            {
                return pk::u8encode("세력 대회 개최가 비활성화 상태입니다.");
            }

            // 012 : 개최가능,  3 : 한황실 대회 개최가능(사용안함) , 4 : 작위부족 , 5 : 이미 대회를 개최함,  6 : 기교 부족, 7 : 금 부족, 8 : 장수부족
            switch (tradeData)
            {
            case -1:
                return pk::u8encode("황건 세력은 대회 개최가 불가능합니다.");
                break;

            case 0:
            case 1:
            case 2:
                return pk::u8encode(pk::format("자세력 무장들이 겨루는 대회를 개최합니다. (기교P : {}, 금 : {} 소비 )", 대회_개최기교, 대회_개최비용));
                break;

            case 3:
                return pk::u8encode("아직 황제를 따르는 제후들이 많이 남아있습니다.");      // 사용안함
                break;

            case 4:
                return pk::u8encode("대회를 개최하려면 공 이상의 작위가 필요합니다.");
                break;
            case 5:
                return pk::u8encode("이번 해에 이미 대회를 개최했습니다.");
                break;
            case 6:
                return pk::u8encode(pk::format("기교가 부족합니다. (기교P : {} 필요 )", 대회_개최기교));
                break;
            case 7:
                return pk::u8encode(pk::format("도시의 금이 부족합니다. (금 : {} 필요 )", 대회_개최비용));
                break;
            case 8:
                return pk::u8encode("대회에 참가할 수 있는 무장이 부족합니다.");
                break;
            }

            return "";
        }

        bool CompetitionHandler()
        {
            int n;
            int c;
            if (tradeData == 0)
            {
                n = 3;
            }
            else
            {
                n = 2;
            }

            array<string> CompetitionList(n);
            array<int> cArray(n - 1);
            if (tradeData == 0)
            {
                CompetitionList[0] = pk::u8encode("무술대회");
                CompetitionList[1] = pk::u8encode("설전대회");
                cArray[0] = 대회_무술;
                cArray[1] = 대회_설전;
            }
            else if (tradeData == 1)
            {
                CompetitionList[0] = pk::u8encode("무술대회");
                cArray[0] = 대회_무술;
            }
            else if (tradeData == 2)
            {
                CompetitionList[0] = pk::u8encode("설전대회");
                cArray[0] = 대회_설전;
            }
            else
            {
                return false;
            }

            CompetitionList[n - 1] = pk::u8encode("취소");

            c = pk::choose(pk::u8encode("개최할 대회를 선택하십시오."), CompetitionList);

            if (c == n - 1)
            {
                return false;
            }

            competitionType = cArray[c];
            int ability; 

            if (대회_무술 == competitionType)
            {
                ability = 무장능력_무력;
            }
            else if (대회_설전 == competitionType)
            {
                ability = 무장능력_지력;
            }
            else
            {
                return false;
            }

            auto list = GetCompetitionPersonList(tradeForce, competitionType, true);

            auto validList = GetSortedCompetitionPersonList(list, ability);

            singleCompetitionPersonList.clear();
            pk::list<pk::person@> person_sel = pk::person_selector(pk::u8encode("장수 선택"), pk::u8encode("대회에 참가할 무장을 선택합니다.(8인 선택)"), validList, 8, 8);

            if (person_sel.count < 8)
            {
                return CompetitionHandler();
            }

            singleCompetitionPersonList = person_sel;

            pk::scene(pk::scene_t(SingleCompetitionScene));

            return true;
        }

        void SingleCompetitionScene()
        {
            @eventKunshu = pk::get_person(tradeForce.kunshu);
            pk::person@ winner = null;
            pk::person@ runnerUp = null;

            pk::move_screen(eventKunshu.get_pos());

            pk::fade(0);
            pk::sleep();
            pk::background(1);
            pk::fade(255);
            string a;
            string ment = "를 개최하도록 하겠소. 훌륭한 실력을 보여주길 기대하겠소.";

            if (대회_무술 == competitionType)
            {
                a = "\x1b[2x무술대회\x1b[0x";
            }
            else if (대회_설전 == competitionType)
            {
                a = "\x1b[2x설전대회\x1b[0x";
            }
            else
            {
                return;
            }
            
            pk::message_box(pk::u8encode(a + ment), eventKunshu);
            
            array<pk::person@> backUpArray = pk::list_to_array(singleCompetitionPersonList);
            singleCompetitionPersonList.shuffle();

            if (대회_무술 == competitionType)
            {
                pk::fade(0);
                pk::sleep();
                pk::background(57);
                pk::fade(255);

                RunDuelCompetition(singleCompetitionPersonList, winner, runnerUp, true);
            }
            else if (대회_설전 == competitionType)
            {
                pk::fade(0);
                pk::sleep();
                pk::background(37);
                pk::fade(255);

                RunEloquenceCompetition(singleCompetitionPersonList, winner, runnerUp, true);
            }

            pk::fade(0);
            pk::sleep();
            pk::background(19);
            pk::fade(255);
            pk::play_se(10);
            pk::message_box(pk::u8encode(pk::format("우승자는 \x1b[2x{}\x1b[0x인가. 앞으로도 나를 위해 더욱 힘써주시오.", pk::u8decode(pk::get_name(winner)))), eventKunshu);
            pk::message_box(pk::u8encode("이건 내가 그대에게 내리는 포상이오."), eventKunshu);
            pk::message_box(pk::u8encode("영광이옵니다."), winner);
            pk::add_kouseki(winner, 자세력_우승_공적);
            pk::message_box(pk::u8encode(pk::format("공적이 \x1b[1x{}\x1b[0x만큼 올랐습니다", 자세력_우승_공적)));
            pk::message_box(pk::u8encode(pk::format("\x1b[2x{}\x1b[0x에게도 포상을 내리겠소.", pk::u8decode(pk::get_name(runnerUp)))), eventKunshu);
            pk::message_box(pk::u8encode("영광이옵니다."), runnerUp);
            pk::add_kouseki(runnerUp, 자세력_준우승_공적);
            pk::message_box(pk::u8encode(pk::format("공적이 \x1b[1x{}\x1b[0x만큼 올랐습니다", 자세력_준우승_공적)));
            pk::message_box(pk::u8encode("이것으로 대회를 폐하겠소"), eventKunshu);
            pk::play_se(6);
            if (대회_무술 == competitionType)
            {
                pk::message_box(pk::u8encode("대회에 참가한 모든 무장의 통솔과 무력 경험치가 상승했습니다."));
                for (int i = 0; i < backUpArray.length; ++i)
                {
                    pk::person@ p = backUpArray[i];
                    p.stat_exp[무장능력_통솔] = p.stat_exp[무장능력_통솔] + 자체_대회_경험치;
                    p.stat_exp[무장능력_무력] = p.stat_exp[무장능력_무력] + 자체_대회_경험치;
                }
            }
            else if (대회_설전 == competitionType)
            {
                pk::message_box(pk::u8encode("대회에 참가한 모든 무장의 지력과 정치 경험치가 상승했습니다."));
                for (int i = 0; i < backUpArray.length; ++i)
                {
                    pk::person@ p = backUpArray[i];
                    p.stat_exp[무장능력_지력] = p.stat_exp[무장능력_지력] + 자체_대회_경험치;
                    p.stat_exp[무장능력_정치] = p.stat_exp[무장능력_정치] + 자체_대회_경험치;
                }
            }
            SetSingleCompetitionWinner(tradeForce.get_force_id(), winner.get_id());
            // 퇴장 
            pk::fade(0);
            pk::sleep();
            pk::background(-1);
            pk::fade(255);
        }

        // ================================================================================================================================================

        // ============================================ 고유기교 선택 ================================================================

        void AddUniqueTechMenu()
        {
            pk::menu_item item;
            item.menu = 105;
            item.pos = 8;
            item.shortcut = "U";
            item.init = pk::building_menu_item_init_t(UniqueTechInit);
            item.is_enabled = pk::menu_item_is_enabled_t(UniqueTechEnabled);
            item.get_text = pk::menu_item_get_text_t(GetUniqueTechText);
            item.get_desc = pk::menu_item_get_desc_t(GetUniqueTechDescription);
            item.handler = pk::menu_item_handler_t(UniqueTechHandler);
            pk::add_menu_item(item);
        }

        void UniqueTechInit(pk::building@ building)
        {
            @helpMoo = pk::get_person(무장_문관);
            @tradeBuilding = @building;
            @tradeForce = pk::get_force(building.get_force_id());
        }

        bool UniqueTechEnabled()
        {
            return true;
        }

        string GetUniqueTechText()
        {
            return  pk::u8encode("고유기교");
        }

        string GetUniqueTechDescription()
        {
            int data = GetUniqueTechApplyData(tradeForce);

            if (data == 4)
                return pk::u8encode("고유기교가 Off로 설정되어 있습니다.");

            return pk::u8encode("세력의 고유기교를 설정합니다. (추가 시 필요 기교p : 500)");
        }

        string GetUniqueTechAddDescription(int data)
        {
            switch (data)
            {
            case 0:
                return "고유기교 슬롯이 부족합니다.";

            case 1:
                return "적용 가능한 고유기교 무장이 없습니다.";

            case 2:
                return "기교p가 부족합니다. (기교p : 500)";

            case 3:
                return "세력의 고유기교를 설정합니다. (필요 기교p : 500).";
            
            case 4:
                return "고유기교가 Off로 설정되어 있습니다.";

            default:
                return "예상치 못한 오류가 발생했습니다.";
            }

            return "";
        }

        bool UniqueTechHandler()
        {
            int data = GetUniqueTechApplyData(tradeForce);

            array<string> helpList =
            {
                pk::u8encode("고유기교 \x1b[2x추가\x1b[0x"),
                pk::u8encode("교유기교 \x1b[29x해제\x1b[0x"),
                pk::u8encode("뒤로가기")
            };

            int n = pk::choose(helpList, pk::u8encode("항목을 선택해 주십시오."), helpMoo);

            if (n == 0)
            {
                if (data == 3)
                {
                    return UniqueTechAdd();
                }
                else
                {
                    pk::message_box(pk::u8encode(GetUniqueTechAddDescription(data)), helpMoo);
                    return  UniqueTechHandler();
                }
            }
            else if (n == 1)
            {
                return  UniqueTechDelete();
            }

            return false;
        }

        bool UniqueTechAdd()
        {
            array<string> arr(5);
            int force_id = tradeForce.get_force_id();

            int slot_count = uniqueTechCount[force_id];
            int data = GetUniqueTechData(force_id);

            array<int> uniqueTechArr(4);

            uniqueTechArr[0] = data / 1000000;
            uniqueTechArr[1] = (data / 10000) % 100;
            uniqueTechArr[2] = (data / 100) % 100;
            uniqueTechArr[3] = data % 100;

            for (int i = 0; i < 4; ++i)
            {
                if (i >= slot_count)
                {
                    arr[i] = pk::u8encode("미개방");
                }
                else
                {
                    if (uniqueTechArr[i] == 0)
                    {
                        arr[i] = pk::u8encode("빈 슬롯");
                    }
                    else
                    {
                        arr[i] = pk::u8encode(고유기교_이름[uniqueTechArr[i]]);
                    }
                }
            }

            arr[4] = pk::u8encode("뒤로 가기");

            pk::list<pk::person@> valid_list = GetValidUniqueTechMooList(tradeForce);

            int n = pk::choose(arr, pk::u8encode("변경할 고유기교 슬롯을 선택해 주십시오."), helpMoo);

            if (n == 4)
                return UniqueTechHandler();
            else
            {
                if (n >= slot_count)
                    return UniqueTechAdd();

                pk::list<pk::person@> person_sel = pk::person_selector(pk::u8encode("무장 선택"), pk::u8encode("적용할 고유기교를 가진 무장을 선택해 주십시오."), valid_list, 1, 1);
                
                if (person_sel.count <= 0)
                {
                    UniqueTechAdd();
                }
                else
                {
                    int sel_ut = GetPersonUniqueTech(person_sel[0].get_id());

                    int result = IsOverapUniqueTech(uniqueTechArr, n, sel_ut);

                    switch (result)
                    {
                    case 0:
                        if (pk::yes_no(pk::u8encode(pk::format("고유기교 {}(을)를 적용하시겠습니까?", 고유기교_이름[sel_ut]))))
                        {
                            SetUniqueTech(force_id, sel_ut, n);
                            pk::play_se(10);
                            pk::add_tp(tradeForce, -500, tradeBuilding.get_pos());
                            pk::message_box(pk::u8encode("고유기교가 변경 되었습니다."));
                        }
                        else
                        {
                            return  UniqueTechAdd();
                        }
                        break;

                    case 1:
                    case 2: 
                        pk::play_se(27);
                        pk::message_box(pk::u8encode(pk::format("고유기교 {}(은)는 이미 적용중입니다.", 고유기교_이름[sel_ut])));
                        return UniqueTechAdd();
                    }
                }
            }

            return UniqueTechHandler();
        }

        bool UniqueTechDelete()
        {
            array<string> arr(5);
            int force_id = tradeForce.get_force_id();

            int slot_count = uniqueTechCount[force_id];
            int data = GetUniqueTechData(force_id);

            array<int> uniqueTechArr(4);

            uniqueTechArr[0] = data / 1000000;
            uniqueTechArr[1] = (data / 10000) % 100;
            uniqueTechArr[2] = (data / 100) % 100;
            uniqueTechArr[3] = data % 100;

            for (int i = 0; i < 4; ++i)
            {
                if (i >= slot_count)
                {
                    arr[i] = pk::u8encode("미개방");
                }
                else
                {
                    if (uniqueTechArr[i] == 0)
                    {
                        arr[i] = pk::u8encode("빈 슬롯");
                    }
                    else
                    {
                        arr[i] = pk::u8encode(고유기교_이름[uniqueTechArr[i]]);
                    }
                }
            }

            arr[4] = pk::u8encode("뒤로 가기");

            int n = pk::choose(arr, pk::u8encode("제거할 고유기교 슬롯을 선택해 주십시오."), helpMoo);

            if(n == 4)
                return UniqueTechHandler();
            else
            {
                if (uniqueTechArr[n] != 0)
                {
                    if (pk::yes_no(pk::u8encode(pk::format("고유기교 {}(을)를 해제하시겠습니까?", 고유기교_이름[uniqueTechArr[n]]))))
                    {
                        SetUniqueTech(force_id, 0, n);
                    }
                }

                return UniqueTechDelete();
            }

            return UniqueTechHandler();
        }

        // 0 중복없음, 1 현재 자리와 동일한 고유기교, 2 현재 자리와는 동일하지 않지만 중복된 고유기교 
        int IsOverapUniqueTech(array<int> arr, int curr_slot, int sel_ut)
        {
            bool is_overap = false;
            bool is_same = false;
            int slot_ut = arr[curr_slot];

            for (int i = 0; i < arr.length; ++i)
            {
                if (arr[i] == sel_ut)
                {
                    is_overap = true;

                    if (i == curr_slot)
                    {
                        is_same = true;
                    }
                }
            }

            if (!is_overap)
                return 0;
            else
            {
                if (is_same)
                    return 1;
                else
                    return 2;
            }

            return -1;
        }
        // ========================================================================================================================

        // ============================================ 고유기교 설명 =================================================================

        void AddUniqueTechHelpMenu()
        {
            pk::menu_item item;
            item.menu = 2;
            item.is_enabled = pk::menu_item_is_enabled_t(IsUniqueTechHelpEnabled);
            item.get_text = pk::menu_item_get_text_t(GetUniqueTechHelpText);
            item.get_desc = pk::menu_item_get_desc_t(GetUniqueTechHelpDesc);
            item.handler = pk::menu_item_handler_t(UniqueTechHelpHandler);
            pk::add_menu_item(item);
        }

        bool IsUniqueTechHelpEnabled()
        {
            return true;
        }

        string GetUniqueTechHelpText()
        {
            return pk::u8encode("고유기교 설명");
        }

        string GetUniqueTechHelpDesc()
        {
            return pk::u8encode("각각의 고유기교에 대한 설명을 볼 수 있습니다");
        }

        bool UniqueTechHelpHandler()
        {
            @helpMoo = pk::get_person(무장_제갈량);

            array<string> helpList =
            {
                pk::u8encode("첫번째 항목"),
                pk::u8encode("두번째 항목"),
                pk::u8encode("뒤로가기")
            };

            int n = pk::choose(helpList, pk::u8encode("항목을 선택해주십시오."), helpMoo);

            switch (n)
            {
            case 0:
                return UniqueTechHelpFirstHandler();

            case 1:
                return UniqueTechHelpSecondHandler();

            case 2:
                return false;
            }

            return false;
        }

        bool UniqueTechHelpFirstHandler()
        {
            @helpMoo = pk::get_person(무장_제갈량);

            array<string> helpList =
            {
                pk::u8encode("위무지강, 대기대덕, 맹호조아, 소패왕, 수성강화"),
                pk::u8encode("주지육림, 비마대, 자모위용, 당도고, 백마의종"),
                pk::u8encode("유시, 팔준, 오두미도, 서량철기, 남만왕"),
                pk::u8encode("속전고수, 황천당립, 덕왕위덕, 팔진도, 군신, 질풍"),
                pk::u8encode("원융노병, 청주병, 동주병, 함진영, 신기"),
                pk::u8encode("뒤로가기")
            };

            int n = pk::choose(helpList, pk::u8encode("궁금한 사항을 선택해주십시오."), helpMoo);

            switch (n)
            {
            case 0:
                return HelpUnique1();

            case 1:
                return HelpUnique2();

            case 2:
                return HelpUnique3();

            case 3:
                return HelpUnique4();

            case 4:
                return HelpUnique5();

            case 5:
                return UniqueTechHelpHandler();
            }

            return UniqueTechHelpHandler();
        }

        bool UniqueTechHelpSecondHandler()
        {
            @helpMoo = pk::get_person(무장_제갈량);

            array<string> helpList =
            {
                pk::u8encode("미주랑, 묘수, 만인지적, 효명진천, 일신시담"),
                pk::u8encode("왕좌지재, 팔문금쇄, 허유엄살, 일치단결, 후위대"),
                pk::u8encode("이간계, 정예수군, 인화, 침략황폐, 왕귀"),
                pk::u8encode("뒤로가기")
            };

            int n = pk::choose(helpList, pk::u8encode("궁금한 사항을 선택해주십시오."), helpMoo);

            switch (n)
            {
            case 0:
                return HelpUnique6();

            case 1:
                return HelpUnique7();

            case 2:
                return HelpUnique8();

            case 5:
                return UniqueTechHelpHandler();
            }

            return UniqueTechHelpHandler();
        }

        bool HelpUnique1()
        {
            pk::message_box(pk::u8encode("\x1b[2x위무지강\x1b[0x의 효과는 부대의 병량 소비를 줄여주고,"), helpMoo);
            pk::message_box(pk::u8encode("부대의 병력 백분율이 낮아질수록 \x1b[1x전투력\x1b[0x이 일정 비율로 강화됩니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x대기대덕\x1b[0x의 효과는 매턴 부대의 부상병을 일부 \x1b[1x치료\x1b[0x해주고,"), helpMoo);
            pk::message_box(pk::u8encode("세력이 도시를 점령할 때 유지되는 시설을 대폭 늘려줍니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x맹호조아\x1b[0x의 효과는 부대의 \x1b[1x일반공격\x1b[0x 피해량을 증가시키고,"), helpMoo);
            pk::message_box(pk::u8encode("병력 수 부족으로 인한 \x1b[1x상태이상\x1b[0x을 방지합니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x소패왕\x1b[0x의 효과는 적의 영토에서 아군 부대의 \x1b[1x전투력\x1b[0x을 고정수치로 상승시킵니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x수성강화\x1b[0x의 효과는 아군 영토에서 아군 \x1b[1x건물\x1b[0x이 받는 피해를 크게 경감시켜줍니다."), helpMoo);

            return UniqueTechHelpFirstHandler();
        }

        bool HelpUnique2()
        {
            pk::message_box(pk::u8encode("\x1b[2x주지육림\x1b[0x의 효과는 아군의 공격이 적의 \x1b[1x사망병\x1b[0x을 증가시킵니다. 즉 \x1b[1x부상병\x1b[0x의 발생이 줄어듭니다."), helpMoo);
            pk::message_box(pk::u8encode("또한 부대가 적의 도시 근처에 주둔해있다면, 매 턴 소량의 \x1b[1x금\x1b[0x을 약탈합니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x비마대\x1b[0x의 효과는 아군 기마부대의 \x1b[1x적성\x1b[0x이 최소 A로 고정되며,"), helpMoo);
            pk::message_box(pk::u8encode("아군 기마부대가 \x1b[1x교란\x1b[0x, \x1b[1x위보\x1b[0x에 걸릴 확률이 감소됩니다."), helpMoo);
            pk::message_box(pk::u8encode("이 효과는 무장의 \x1b[1x특기\x1b[0x로 인해 확정되는 확률은 감소시키지 않습니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x자모위용\x1b[0x의 효과는 자세력 도시에 억류당한 포로의 \x1b[1x충성도\x1b[0x 하락을 가속하고,"), helpMoo);
            pk::message_box(pk::u8encode("부대의 병력 백분율이 높아질수록 \x1b[1x전투력\x1b[0x이 일정 비율로 강화됩니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x당도고\x1b[0x의 효과는 군주의 \x1b[1x작위\x1b[0x가 높아짐에 따라 아군이 강화되는 기교입니다."), helpMoo);
            pk::message_box(pk::u8encode("이 효과는 부대의 대장이 \x1b[1x한실무시\x1b[0x인 경우 무효가 됩니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x백마의종\x1b[0x의 효과는 아군 기마대가 \x1b[1x일반공격\x1b[0x 후 일정 기력을 얻게되고,"), helpMoo);
            pk::message_box(pk::u8encode("\x1b[1x전법공격\x1b[0x에 성공했다면, 전법 후 주변 적 부대의 기력을 감소시킵니다."), helpMoo);

            return UniqueTechHelpFirstHandler();
        }

        bool HelpUnique3()
        {
            pk::message_box(pk::u8encode("\x1b[2x유시\x1b[0x의 효과는 건물의 공격이 낮은 확률로 적 무장에게 \x1b[1x부상\x1b[0x을 발생시킵니다."), helpMoo);
            pk::message_box(pk::u8encode("이 효과는 \x1b[1x등갑\x1b[0x, \x1b[1x호위\x1b[0x 특기로 방어할 수 있습니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x팔준\x1b[0x의 효과는 매 계절마다 \x1b[1x교련\x1b[0x을 실행할 수 있게됩니다."), helpMoo);
            pk::message_box(pk::u8encode("교련을 실행하는 무장과 사사받는 무장들의 능력차와 관계에 따라서 효과가 달라집니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x오두미도\x1b[0x의 효과는 아군 부대의 \x1b[1x사망병\x1b[0x을 줄입니다. 즉 \x1b[1x부상병\x1b[0x으로 전환되는 비율이 늘어납니다."), helpMoo);
            pk::message_box(pk::u8encode("그리고 농가가 아닌 도시시설에서도 \x1b[1x군량\x1b[0x을 일부 생산합니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x서량철기\x1b[0x의 효과는 기마부대가 전법공격에 성공했다면, 전법 후 주변 적 부대에 약간의 피해를 추가로 입힙니다."), helpMoo);
            pk::message_box(pk::u8encode("해당 고유기교 \x1b[1x보유자\x1b[0x는 두배의 효과가 적용됩니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x남만왕\x1b[0x의 효과는 아군 영토내의 적 부대의 \x1b[1x이동력\x1b[0x을 감소시키고,"), helpMoo);
            pk::message_box(pk::u8encode("매턴 \x1b[1x기력\x1b[0x을 추가로 감소시킵니다."), helpMoo);

            return UniqueTechHelpFirstHandler();
        }

        bool HelpUnique4()
        {
            pk::message_box(pk::u8encode("\x1b[2x속전고수\x1b[0x의 효과는 모든 아군부대의 \x1b[1x이동력\x1b[0x을 증가시킵니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x황천당립\x1b[0x의 아군 부대의 기력이 적을수록 \x1b[1x전투력\x1b[0x이 상승하고, \x1b[1x검병\x1b[0x부대의 공격,방어,이동이 증가합니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x덕왕위덕\x1b[0x의 자세력에서 \x1b[1x본거지\x1b[0x가 발생하지 않고, 주변 적 도시의 \x1b[1x치안\x1b[0x을 매 턴 하락시킵니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x팔진도\x1b[0x의 효과는 건물의 공격이 낮은 확률로 적 부대에 임의의 해로운 효과를 부여합니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x군신\x1b[0x의 효과는 아군 부대의 전법  \x1b[1x성공률\x1b[0x이 일정 비율로 증가합니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[1x질풍\x1b[0x의 효과는 아군 노병부대가 전법공격에 성공했다면 임의의 주변 적 부대에 추가 사격을 실시합니다."), helpMoo);

            return UniqueTechHelpFirstHandler();
        }


        bool HelpUnique5()
        {
            pk::message_box(pk::u8encode("\x1b[2x원융노병\x1b[0x의 효과는 아군 노병부대의 \x1b[1x적성\x1b[0x이 최소 A로 고정되며,"), helpMoo);
            pk::message_box(pk::u8encode("아군 노병부대가 \x1b[1x교란\x1b[0x, \x1b[1x위보\x1b[0x에 걸릴 확률이 감소됩니다."), helpMoo);
            pk::message_box(pk::u8encode("이 효과는 무장의 \x1b[1x특기\x1b[0x로 인해 확정되는 확률은 감소시키지 않습니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x청주병\x1b[0x의 효과는 아군 창병부대의 \x1b[1x적성\x1b[0x이 최소 A로 고정되며,"), helpMoo);
            pk::message_box(pk::u8encode("아군 창병부대가 \x1b[1x교란\x1b[0x, \x1b[1x위보\x1b[0x에 걸릴 확률이 감소됩니다."), helpMoo);
            pk::message_box(pk::u8encode("이 효과는 무장의 \x1b[1x특기\x1b[0x로 인해 확정되는 확률은 감소시키지 않습니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x동주병\x1b[0x의 효과는 아군 극병부대의 \x1b[1x적성\x1b[0x이 최소 A로 고정되며,"), helpMoo);
            pk::message_box(pk::u8encode("아군 극병부대가 \x1b[1x교란\x1b[0x, \x1b[1x위보\x1b[0x에 걸릴 확률이 감소됩니다."), helpMoo);
            pk::message_box(pk::u8encode("이 효과는 무장의 \x1b[1x특기\x1b[0x로 인해 확정되는 확률은 감소시키지 않습니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x함진영\x1b[0x의 효과는 거점에 주는 피해가 증가하고 적 \x1b[1x건물\x1b[0x에게 받는 피해가 감소합니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x신기\x1b[0x의 효과는 적 부대의 공성을 제외한 전법 성공률을 하락시킵니다."), helpMoo);

            return UniqueTechHelpFirstHandler();
        }

        bool HelpUnique6()
        {
            pk::message_box(pk::u8encode("\x1b[2x미주랑\x1b[0x의 효과는 \x1b[1x화계 지형\x1b[0x에 있는 적 부대에 대한 전법 크리티컬 확률을 증가시키고,"), helpMoo);
            pk::message_box(pk::u8encode("\x1b[1x화계 지형\x1b[0x에 있는 아군 부대의 전투력을 증가시킵니다."), helpMoo);
            pk::message_box(pk::u8encode("해당 고유기교 \x1b[1x보유자\x1b[0x는 두배의 효과가 적용됩니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x묘수\x1b[0x의 효과는 \x1b[1x전법\x1b[0x의 피해량이 적 부대와의 \x1b[1x지력차\x1b[0x에 비례해 증가합니다."), helpMoo);
            pk::message_box(pk::u8encode("해당 증가량은 광역 전법의 경우 경감합니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x만인지적\x1b[0x의 효과는 \x1b[1x공격력\x1b[0x이 낮은 적 부대에 주는 피해량이 증가하고,"), helpMoo);
            pk::message_box(pk::u8encode("\x1b[1x공격력\x1b[0x이 낮은 적에게 받는 피해량이 감소합니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x효명진천\x1b[0x의 효과는 \x1b[1x상태이상\x1b[0x인 적 부대에게 주는 피해량이 증가하고,"), helpMoo);
            pk::message_box(pk::u8encode("\x1b[2x인접\x1b[0x 적군부대가 아군부대보다 많을 수록 부대 공격력이 증가합니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x일신시담\x1b[0x의 효과는 \x1b[1x상태이상\x1b[0x인 아군 부대가 받는 피해량이 감소하고,"), helpMoo);
            pk::message_box(pk::u8encode("\x1b[2x인접\x1b[0x 적군부대가 아군부대보다 많을 수록 부대 방어력이 증가합니다."), helpMoo);

            return UniqueTechHelpSecondHandler();
        }

        bool HelpUnique7()
        {
            pk::message_box(pk::u8encode("\x1b[2x왕좌지재\x1b[0x의 효과는 거점의 \x1b[1x부상병\x1b[0x 회복량이 증가하고,"), helpMoo);
            pk::message_box(pk::u8encode("\x1b[1x시장\x1b[0x이 아닌 도시시설에도 금 수입이 일부 발생합니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x팔문금쇄\x1b[0x의 효과는 자세력 영토에서 부대의 \x1b[1x방어력\x1b[0x과 \x1b[1x반격 피해\x1b[0x를 증가시킵니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x허유엄살\x1b[0x의 효과는 \x1b[1x교란, 위보, 동토\x1b[0x가 성공했을 경우 인접한 임의의 적 1부대에게"), helpMoo);
            pk::message_box(pk::u8encode("아군 부대의 \x1b[1x병력 수\x1b[0x 및 적 부대와의 \x1b[1x지력 차\x1b[0x에 비례해 추가 피해를 입힙니다."), helpMoo);
            pk::message_box(pk::u8encode("해당 고유기교 \x1b[1x보유자\x1b[0x는 두배의 효과가 적용됩니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x일치단결\x1b[0x의 효과는 \x1b[1x인접한\x1b[0x 아군 부대 수에 비례해 부대의 전투력을 증가시킵니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x후위대\x1b[0x의 효과는 아군 부대가 전멸했을 경우 포로 확률을 감소시킵니다."), helpMoo);

            return UniqueTechHelpSecondHandler();
        }

        bool HelpUnique8()
        {
            pk::message_box(pk::u8encode("\x1b[2x이간계\x1b[0x의 효과는 무장이 \x1b[1x2명 이상\x1b[0x인 적 부대에 대한 계략 \x1b[1x성공률\x1b[0x이 증가합니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x정예수군\x1b[0x의 효과는 아군 수군부대의 \x1b[1x공격,방어,기동력\x1b[0x이 증가합니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x인화\x1b[0x의 효과는 모든 아군 부대의 \x1b[1x지원공격\x1b[0x 확률을 증가시킵니다."), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x침략황폐\x1b[0x의 효과는 \x1b[1x내정시설\x1b[0x에 주는 피해가 증가하고,"), helpMoo);
            pk::message_box(pk::u8encode("6칸 이하의 적 도시의 \x1b[1x치안\x1b[0x을 매 턴마다 일정 확률로 감소시킵니다. "), helpMoo);

            pk::message_box(pk::u8encode("\x1b[2x왕귀\x1b[0x의 효과는 선택한 무장의 능력치를 4년 후 증가시킵니다."), helpMoo);
            pk::message_box(pk::u8encode("해당 효과는 \x1b[1x낮은\x1b[0x 능력치일 수록 효과가 증가하고, AI 세력은 사용할 수 없습니다."), helpMoo);
            pk::message_box(pk::u8encode("선택된 무장이 \x1b[1x하야,배신,사망\x1b[0x할 경우 또는 왕귀 고유기교가 해제된 경우 무효처리 됩니다."), helpMoo);

            return UniqueTechHelpSecondHandler();
        }

        // ============================================= 대회 우승 횟수 =============================================================

        pk::list<pk::person@> duel_competition_person_list;
        pk::list<pk::person@> eloquence_competition_person_list;

        void AddCheckCompetitionCountMenu()
        {
            @helpMoo = pk::get_person(무장_관우);
            pk::menu_item item;
            item.menu = 2;
            item.is_enabled = pk::menu_item_is_enabled_t(IsCheckCompetitionCountEnabled);
            item.get_text = pk::menu_item_get_text_t(GetCheckCompetitionCountText);
            item.get_desc = pk::menu_item_get_desc_t(GetCheckCompetitionCountDesc);
            item.handler = pk::menu_item_handler_t(CheckCompetitionCountHandler);
            pk::add_menu_item(item);
        }

        bool IsCheckCompetitionCountEnabled()
        {
            return true;
        }

        string GetCheckCompetitionCountText()
        {
            return pk::u8encode("대회 우승횟수 확인");
        }

        string GetCheckCompetitionCountDesc()
        {
            return pk::u8encode("황제가 개최한 대회의 우승횟수를 확인합니다.");
        }

        bool CheckCompetitionCountHandler()
        {
            duel_competition_person_list.clear();

            for (int i = 0; i < competitionCountArray.length; ++i)
            {
                pk::person@ person = pk::get_person(i);

                if (person != null || person.is_alive())
                {
                    if (GetCompetitionCount(person, 대회_무술) >= 1)
                    {
                        duel_competition_person_list.add(person);
                    }
                }
            }

            eloquence_competition_person_list.clear();

            for (int i = 0; i < competitionCountArray.length; ++i)
            {
                pk::person@ person = pk::get_person(i);

                if (person != null || person.is_alive())
                {
                    if (GetCompetitionCount(person, 대회_설전) >= 1)
                    {
                        eloquence_competition_person_list.add(person);
                    }
                }
            }

            array<string> helpList =
            {
                pk::u8encode("무술대회 우승횟수"),
                pk::u8encode("설전대회 우승횟수"),
                pk::u8encode("뒤로가기")
            };

            int n = pk::choose(helpList, pk::u8encode("궁금한 사항을 선택해주십시오."), helpMoo);

            switch (n)
            {
            case 0:
                return CheckDuelCompetitionCount();

            case 1:
                return CheckEloquenceCompetitionCount();

            case 2:
                return false;
            }

            return false;
        }

        bool CheckDuelCompetitionCount()
        {
            if (duel_competition_person_list.count <= 0)
            {
                pk::message_box(pk::u8encode("무술대회를 우승한 무장이 존재하지 않습니다."));
                return CheckCompetitionCountHandler();
            }

            pk::list<pk::person@> person_sel = pk::person_selector(pk::u8encode("무장 선택"), pk::u8encode("확인할 무장을 선택합니다."), duel_competition_person_list, 1, 1);

            if (person_sel.count <= 0)
            {
                return CheckCompetitionCountHandler();
            }
            else
            {
                int count = GetCompetitionCount(person_sel[0], 대회_무술);
                pk::message_box(pk::u8encode(pk::format("\x1b[1x{}\x1b[0x의 무술대회 우승 횟수는 \x1b[2x{}\x1b[0x회 입니다.", pk::u8decode(pk::get_name(person_sel[0])), count)));
                return CheckDuelCompetitionCount();
            }
        }

        bool CheckEloquenceCompetitionCount()
        {
            if (eloquence_competition_person_list.count <= 0)
            {
                pk::message_box(pk::u8encode("설전대회를 우승한 무장이 존재하지 않습니다."));
                return CheckCompetitionCountHandler();
            }

            pk::list<pk::person@> person_sel = pk::person_selector(pk::u8encode("무장 선택"), pk::u8encode("확인할 무장을 선택합니다."), eloquence_competition_person_list, 1, 1);

            if (person_sel.count <= 0)
            {
                return CheckCompetitionCountHandler();
            }
            else
            {
                int count = GetCompetitionCount(person_sel[0], 대회_설전);
                pk::message_box(pk::u8encode(pk::format("\x1b[1x{}\x1b[0x의 설전대회 우승 횟수는 \x1b[2x{}\x1b[0x회 입니다.", pk::u8decode(pk::get_name(person_sel[0])), count)));
                return CheckEloquenceCompetitionCount();
            }
        }
        
        // 지역이점 설정메뉴 추가
        void AddSettingDataMenu()
        {
            @helpMoo = pk::get_person(무장_유비);
            pk::menu_item item;
            item.menu = 2;
            item.is_enabled = pk::menu_item_is_enabled_t(IsSettingDataEnabled);
            item.get_text = pk::menu_item_get_text_t(GetSettingDataText);
            item.get_desc = pk::menu_item_get_desc_t(GetSettingDataDesc);
            item.handler = pk::menu_item_handler_t(CheckSettingDataHandler);
            pk::add_menu_item(item);
        }

        bool IsSettingDataEnabled()
        {
            return true;
        }

        string GetSettingDataText()
        {
            return pk::u8encode("지역이점 설정");
        }

        string GetSettingDataDesc()
        {
            return pk::u8encode("지역이점 스크립트에 관련된 기능을 설정합니다.");
        }

        bool CheckSettingDataHandler()
        {
            array<string> helpList =
            {
                pk::u8encode("지역이점 설정"),
                pk::u8encode("대회 설정"),
                pk::u8encode("기타 설정"),
                pk::u8encode("진행도 표시 설정"),
                pk::u8encode("뒤로가기")
            };

            int n = pk::choose(helpList, pk::u8encode("변경할 기능을 선택해주십시오."), helpMoo);

            switch (n)
            {
            case 0:
                return SettingRegionBuff();

            case 1:
                return SettingCompetition();

            case 3:
                return SettingProgress();

            case 2:
                return SettingEtcetera();

            case 4:
                return false;
            }

            return false;
        }

        bool SettingRegionBuff()
        {
            string 지역이점_사용여부_출력;
            string 이민족지원_사용여부_출력;
            string 이민족_특기전수_사용여부_출력;
            string 고유기교_사용여부_출력;

            if (지역이점_사용여부 == 1)
            {
                지역이점_사용여부_출력 = "지역이점 \x1b[2xOn\x1b[0x";
            }
            else
            {
                지역이점_사용여부_출력 = "지역이점 \x1b[29xOff\x1b[0x";
            }

            if (이민족지원_사용여부 == 1)
            {
                이민족지원_사용여부_출력 = "이민족 지원 \x1b[2xOn\x1b[0x";
            }
            else
            {
                이민족지원_사용여부_출력 = "이민족 지원 \x1b[29xOff\x1b[0x";
            }

            if (이민족_특기전수_사용여부 == 1)
            {
                이민족_특기전수_사용여부_출력 = "이민족 특기전수 \x1b[2xOn\x1b[0x";
            }
            else
            {
                이민족_특기전수_사용여부_출력 = "이민족 특기전수 \x1b[29xOff\x1b[0x";
            }

            if (고유기교_사용여부 == 1)
            {
                고유기교_사용여부_출력 = "고유기교 \x1b[2xOn\x1b[0x";
            }
            else
            {
                고유기교_사용여부_출력 = "고유기교 \x1b[29xOff\x1b[0x";
            }

            array<string> helpList =
            {
                pk::u8encode(지역이점_사용여부_출력),
                pk::u8encode(이민족지원_사용여부_출력),
                pk::u8encode(이민족_특기전수_사용여부_출력),
                pk::u8encode(고유기교_사용여부_출력),
                pk::u8encode("뒤로가기")
            };


            int n = pk::choose(helpList, pk::u8encode("변경할 기능을 선택해주십시오."), helpMoo);

            switch (n)
            {
            case 0:
                지역이점_사용여부 = (지역이점_사용여부 + 1) % 2;
                break;

            case 1:
                이민족지원_사용여부 = (이민족지원_사용여부 + 1) % 2;
                break;

            case 2:
                이민족_특기전수_사용여부 = (이민족_특기전수_사용여부 + 1) % 2;
                break;

            case 3:
                고유기교_사용여부 = (고유기교_사용여부 + 1) % 2;
                break;
            case 4:
                return CheckSettingDataHandler();
            }

            return SettingRegionBuff();
        }

        bool SettingCompetition()
        {
            string 무술대회_개최여부_출력;
            string 대회_개최시기_무술_출력;
            string 설전대회_개최여부_출력;
            string 대회_개최시기_설전_출력;
            string 자세력_대회_개최여부_출력;
            
            if (무술대회_개최여부 == 0)
            {
                무술대회_개최여부_출력 = "한실 무술대회 \x1b[29x개최안함\x1b[0x";
            }
            else if (무술대회_개최여부 == 1)
            {
                무술대회_개최여부_출력 = "한실 무술대회 \x1b[2x홀수년도 개최\x1b[0x";
            }
            else if(무술대회_개최여부 == 2)
            {
                무술대회_개최여부_출력 = "한실 무술대회 \x1b[2x짝수년도 개최\x1b[0x";
            }
            else
            {
                무술대회_개최여부_출력 = "한실 무술대회 \x1b[2매년 개최\x1b[0x";
            }

            if (설전대회_개최여부 == 0)
            {
                설전대회_개최여부_출력 = "한실 설전대회 \x1b[29x개최안함\x1b[0x";
            }
            else if (설전대회_개최여부 == 1)
            {
                설전대회_개최여부_출력 = "한실 설전대회 \x1b[2x홀수년도 개최\x1b[0x";
            }
            else if (설전대회_개최여부 == 2)
            {
                설전대회_개최여부_출력 = "한실 설전대회 \x1b[2x짝수년도 개최\x1b[0x";
            }
            else
            {
                설전대회_개최여부_출력 = "한실 설전대회 \x1b[2매년 개최\x1b[0x";
            }

            if (자세력_대회_개최여부 == 1)
            {
                자세력_대회_개최여부_출력 = "자세력 대회 \x1b[2xOn\x1b[0x";
            }
            else
            {
                자세력_대회_개최여부_출력 = "자세력 대회 \x1b[2xOff\x1b[0x";
            }

            대회_개최시기_무술_출력 = pk::format("한실 무술대회 개최 : \x1b[2x{}\x1b[0x 월", 대회_개최시기_무술);
            대회_개최시기_설전_출력 = pk::format("한실 설전대회 개최 : \x1b[1x{}\x1b[0x 월", 대회_개최시기_설전);


            array<string> helpList =
            {
                pk::u8encode(무술대회_개최여부_출력),
                pk::u8encode(대회_개최시기_무술_출력),
                pk::u8encode(설전대회_개최여부_출력),
                pk::u8encode(대회_개최시기_설전_출력),
                pk::u8encode(자세력_대회_개최여부_출력),
                pk::u8encode("뒤로가기")
            };

            int n = pk::choose(helpList, pk::u8encode("변경할 기능을 선택해주십시오."), helpMoo);

            switch (n)
            {
            case 0:
                무술대회_개최여부 = (무술대회_개최여부 + 1) % 4;
                break;

            case 1:
                대회_개최시기_무술 = pk::numberpad(pk::u8encode("숫자 입력"), 1, 12, 대회_개최시기_무술, pk::numberpad_t(pad_callback)).first;
                break;

            case 2:
                설전대회_개최여부 = (설전대회_개최여부 + 1) % 4;
                break;

            case 3:
                대회_개최시기_설전 = pk::numberpad(pk::u8encode("숫자 입력"), 1, 12, 대회_개최시기_설전, pk::numberpad_t(pad_callback)).first;
                break;

            case 4:
                자세력_대회_개최여부 = (자세력_대회_개최여부 + 1) % 2;
                break;

            case 5:
                return CheckSettingDataHandler();
            }

            return SettingCompetition();
        }

        bool SettingProgress()
        {
            //const int 설정_능력연구_표시_사용여부 = 60021; // 1: 사용, 0 : 사용안함
            //const int 설정_이민족외교_표시_사용여부 = 60022; // 1: 사용, 0 : 사용안함
            //const int 설정_교역_표시_사용여부 = 60023; // 1: 사용, 0 : 사용안함
            //const int 설정_왕귀_표시_사용여부 = 60024; // 1: 사용, 0 : 사용안함


            string 능력연구_표시_사용여부_출력;
            string 이민족외교_표시_사용여부_출력;
            string 교역_표시_사용여부_출력;
            string 왕귀_표시_사용여부_출력;
        
            if (능력연구_표시_사용여부 == 1)
            {
                능력연구_표시_사용여부_출력 = "능력연구_표시 \x1b[2xOn\x1b[0x";
            }
            else
            {
                능력연구_표시_사용여부_출력 = "능력연구_표시 \x1b[29xOff\x1b[0x";
            }
            
            if (이민족외교_표시_사용여부 == 1)
            {
                이민족외교_표시_사용여부_출력 = "이민족외교_표시 : \x1b[2xOn\x1b[0x";
            }
            else
            {
                이민족외교_표시_사용여부_출력 = "이민족외교_표시 : \x1b[29xOff\x1b[0x";
            }
            
            if (교역_표시_사용여부 == 1)
            {
                교역_표시_사용여부_출력 = "교역_표시 : \x1b[2xOn\x1b[0x";
            }
            else
            {
                교역_표시_사용여부_출력 = "교역_표시 : \x1b[29xOff\x1b[0x";
            }
            
            if (왕귀_표시_사용여부 == 1)
            {
                왕귀_표시_사용여부_출력 = "왕귀_표시 : \x1b[2xOn\x1b[0x";
            }
            else
            {
                왕귀_표시_사용여부_출력 = "왕귀_표시 : \x1b[29xOff\x1b[0x";
            }

            //
            //세력별_최대_고유기교_출력 = pk::format("세력별 최대 고유기교 : \x1b[2x{}\x1b[0x개", 세력별_최대_고유기교);
            //
            array<string> helpList =
            {
                pk::u8encode(능력연구_표시_사용여부_출력),
                pk::u8encode(이민족외교_표시_사용여부_출력),
                pk::u8encode(교역_표시_사용여부_출력),
                pk::u8encode(왕귀_표시_사용여부_출력),
                pk::u8encode("뒤로가기")
            };
            //
            int n = pk::choose(helpList, pk::u8encode("변경할 기능을 선택해주십시오."), helpMoo);
            
            switch (n)
            {
            case 0:
                능력연구_표시_사용여부 = (능력연구_표시_사용여부 + 1) % 2;
                break;
            
            case 1:
                이민족외교_표시_사용여부 = (이민족외교_표시_사용여부 + 1) % 2;
                break;
            
            case 2:
                교역_표시_사용여부 = (교역_표시_사용여부 + 1) % 2;
                break;
            
            case 3:
                왕귀_표시_사용여부 = (왕귀_표시_사용여부 + 1) % 2;
                break;
            
            case 4:
                return CheckSettingDataHandler();
            }
            
            return SettingProgress();
        }

        bool SettingEtcetera()
        {
            string 백출_기력반감_출력;
            string 부상병시스템_사용여부_출력;
            string 수정된_등용확률_출력;
            string 수정된_포로확률_출력;
            string 멸망시_공적감소_출력;

            if (백출_기력반감 == 1)
            {
                백출_기력반감_출력 = "백출 : \x1b[1x기력반감\x1b[0x";
            }
            else
            {
                백출_기력반감_출력 = "백출 : \x1b[2x원본\x1b[0x";
            }

            if (부상병시스템_사용여부 == 1)
            {
                부상병시스템_사용여부_출력 = "부상병 \x1b[2xOn\x1b[0x";
            }
            else
            {
                부상병시스템_사용여부_출력 = "부상병 \x1b[29xOff\x1b[0x";
            }

            if (수정된_등용확률 == 3)
            {
                수정된_등용확률_출력 = "등용 난이도 : 유저만 \x1b[29x증가\x1b[0x";
            }
            else if (수정된_등용확률 == 2)
            {
                수정된_등용확률_출력 = "등용 난이도 : AI만 \x1b[29x증가\x1b[0x";
            }
            else if (수정된_등용확률 == 1)
            {
                수정된_등용확률_출력 = "등용 난이도 : 모두 \x1b[29x증가\x1b[0x";
            }
            else
            {
                수정된_등용확률_출력 = "등용 난이도 : \x1b[2x원본\x1b[0x";
            }

            if (수정된_포로확률 == 3)
            {
                수정된_포로확률_출력 = "포로 난이도 : 유저만 \x1b[29x증가\x1b[0x";
            }
            else if (수정된_포로확률 == 2)
            {
                수정된_포로확률_출력 = "포로 난이도 : AI만 \x1b[29x증가\x1b[0x";
            }
            else if (수정된_포로확률 == 1)
            {
                수정된_포로확률_출력 = "포로 난이도 : 모두 \x1b[29x증가\x1b[0x";
            }
            else
            {
                수정된_포로확률_출력 = "포로 확률 : \x1b[2x원본\x1b[0x";
            }

            if (멸망시_공적감소 == 1)
            {
                멸망시_공적감소_출력 = "멸망 시 무장 공적감소 \x1b[2xOn\x1b[0x";
            }
            else
            {
                멸망시_공적감소_출력 = "멸망 시 무장 공적감소 \x1b[29xOff\x1b[0x";
            }

            array<string> helpList =
            {
                pk::u8encode(백출_기력반감_출력),
                pk::u8encode(부상병시스템_사용여부_출력),
                pk::u8encode(수정된_등용확률_출력),
                pk::u8encode(수정된_포로확률_출력),
                pk::u8encode(멸망시_공적감소_출력),
                pk::u8encode("뒤로가기")
            };

            int n = pk::choose(helpList, pk::u8encode("변경할 기능을 선택해주십시오."), helpMoo);

            switch (n)
            {
            case 0:
                백출_기력반감 = (백출_기력반감 + 1) % 2;
                OnGameInit();
                break;

            case 1:
                부상병시스템_사용여부 = (부상병시스템_사용여부 + 1) % 2;
                break;

            case 2:
                수정된_등용확률 = (수정된_등용확률 + 1) % 4;
                break;

            case 3:
                수정된_포로확률 = (수정된_포로확률 + 1) % 4;
                break;

            case 4:
                멸망시_공적감소 = (멸망시_공적감소 + 1) % 2;
                break;

            case 5:
                return CheckSettingDataHandler();
            }

            return SettingEtcetera();
        }

        string pad_callback(int line, int original_value, int current_value)
        {
            return pk::u8encode("숫자 입력");
        }
    }
    
    RegionBuff regionBuff;
}